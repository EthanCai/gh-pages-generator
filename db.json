{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/samples/expvarsample.go","path":"samples/expvarsample.go","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"e71593534c6b530fd2df06be07c8d940b985529c","modified":1745773489541},{"_id":"source/_posts/2016-03-26-product-design-vs-requirement-analysis.md","hash":"92b1a79f1d6d9b7364be70ea186bf65d519b5329","modified":1745773489539},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog.md","hash":"2dba448b1c4895cb9e41654e3c6dc2bb555dd26e","modified":1745773489536},{"_id":"source/_posts/2016-06-23-bad-parts-about-json-serialization-in-Golang.md","hash":"d318da3721ea98d2d00aac1227e62fc3f63f16ba","modified":1745773489541},{"_id":"source/_posts/2017-12-29-error-handling-in-go.md","hash":"d9013bc8df6251775e2a0688a3b0d20c62c87907","modified":1747667235842},{"_id":"source/categories/index.md","hash":"344157c3e9b54d9247f213e085e193030ff66def","modified":1745773489543},{"_id":"source/samples/expvarsample.go","hash":"40e471129b2c9c1599977e73955d9ff19ea6f821","modified":1745773489542},{"_id":"source/tags/index.md","hash":"d32085ddec1214e036e7c7e8dbdb105455cf4332","modified":1745773489542},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/channel.png","hash":"07fa353dc547212f594f859c2dde0c217eff983b","modified":1745773489538},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/use_channel.png","hash":"853e9b256bf1db8aee27f55ec881305eb52d1ab6","modified":1745773489537},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/expvarmon_screen.png","hash":"3cf57a3f5a4de25e898ce566770f123a6efb8eb4","modified":1745773489537},{"_id":"source/.DS_Store","hash":"c048747414aaef389fd25208f019d470677157f2","modified":1745773489535},{"_id":"source/images/avatar.jpg","hash":"c4dd28a263439f83c15ddc069d97642fcf22065f","modified":1745773489535},{"_id":"source/favicon.ico","hash":"1f7d35b787b1751eef2793a2a8c6171dff51820f","modified":1745773489535},{"_id":"source/_posts/2017-12-29-error-handling-in-go/d2a2d12e1a00f819d7fd7af4b536efa2.png","hash":"ae40aa7e6dcc2d443100f55eeebea79c3fa6b305","modified":1745773489536},{"_id":"source/_posts/assets/2017-12-29-error-handling-in-go/d2a2d12e1a00f819d7fd7af4b536efa2.png","hash":"ae40aa7e6dcc2d443100f55eeebea79c3fa6b305","modified":1745773489540},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/2016-04-21_07-12-40.png","hash":"328e623a575da9a88b9a2cbb058d787e520ece1b","modified":1745773489539},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1745773489614},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1745773489543},{"_id":"themes/next/.stylelintrc","hash":"9346cca6a24256a79f433670da634e8329f9a2a9","modified":1745773489601},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1745773489595},{"_id":"themes/next/README.md","hash":"692bdee76ce51138cd1c09f684e518b08d50dd4c","modified":1745773489600},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1745773489601},{"_id":"themes/next/_config.yml","hash":"d60c019bb75c3858df899c41f830398de26a6dbc","modified":1745773489602},{"_id":"themes/next/package.json","hash":"eaf826c46804a8da9ec6ddf325c4670a3e3ecfa7","modified":1745773489601},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1745773489595},{"_id":"themes/next/_vendors.yml","hash":"49743c5be6dfff1fb78db0c8042f1b72b596201b","modified":1745773489601},{"_id":"themes/next/.githooks/install.js","hash":"0977cb57c8b91ea166b5bbc481e4ddeaf77e9b18","modified":1745773489544},{"_id":"themes/next/eslint.config.js","hash":"14b5636ce297048ea6835f7db4b1e4cf625a2c79","modified":1745773489614},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1745773489547},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"e78ec4eb6ce49a44ec321c49424ee0a0c1846537","modified":1745773489610},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"2296426023773991b0c48c7fffeb790baca59b19","modified":1745773489612},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1745773489612},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1745773489614},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1745773489613},{"_id":"themes/next/.github/release.yml","hash":"112310b81f959747f8eaafc2ca2150e1dcf916d8","modified":1745773489610},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1745773489544},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"22d7dd8661cb2f22ff271ee96e444457814c66fd","modified":1745773489610},{"_id":"themes/next/.github/labeler.yml","hash":"b7f67daa031c535940be82ea96f0fb9db59e1022","modified":1745773489610},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1745773489598},{"_id":"themes/next/languages/bn.yml","hash":"564bed75da6e05b11dce6164508f97a15e2fb6c2","modified":1745773489600},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1745773489593},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1745773489593},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1745773489595},{"_id":"themes/next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1745773489599},{"_id":"themes/next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1745773489598},{"_id":"themes/next/languages/default.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1745773489596},{"_id":"themes/next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1745773489598},{"_id":"themes/next/languages/eo.yml","hash":"e34bb33ae827bf2f0727088599a73bc64bdad1b0","modified":1745773489599},{"_id":"themes/next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1745773489598},{"_id":"themes/next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1745773489597},{"_id":"themes/next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1745773489598},{"_id":"themes/next/languages/fr.yml","hash":"8ac44e58f71a38b7697a2f7f98a6971ed818cb5b","modified":1745773489599},{"_id":"themes/next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1745773489597},{"_id":"themes/next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1745773489597},{"_id":"themes/next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1745773489598},{"_id":"themes/next/languages/pt.yml","hash":"b62faaa767a45a613dd042b5f1903675eb5a8cf9","modified":1745773489597},{"_id":"themes/next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1745773489599},{"_id":"themes/next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1745773489596},{"_id":"themes/next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1745773489600},{"_id":"themes/next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1745773489597},{"_id":"themes/next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1745773489596},{"_id":"themes/next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1745773489600},{"_id":"themes/next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1745773489595},{"_id":"themes/next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1745773489597},{"_id":"themes/next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1745773489600},{"_id":"themes/next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1745773489600},{"_id":"themes/next/languages/zh-HK.yml","hash":"8eb6a9f231ce1bfa54cc54418ccf14f01dcc9a31","modified":1745773489599},{"_id":"themes/next/layout/_layout.njk","hash":"b17d44bd7379c23241053a0b7fbd38c9c43cc239","modified":1745773489554},{"_id":"themes/next/languages/zh-TW.yml","hash":"5c0f00cdac3f4727b880dd223f622a535736fa8e","modified":1745773489599},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1745773489548},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1745773489548},{"_id":"themes/next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1745773489548},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1745773489547},{"_id":"themes/next/layout/page.njk","hash":"af6d7570621be760536c216a56d74e40a1cceae2","modified":1745773489554},{"_id":"themes/next/test/index.js","hash":"b08b244fb6fa940aa2ea186e699edaaff7825d8f","modified":1745773489544},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1745773489548},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.yml","hash":"3f19cbf0c2b2fee6bf3788870b842c9ccc1425ca","modified":1745773489613},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.yml","hash":"fbc3062cd4591c8329fab9db72803746f0d11920","modified":1745773489613},{"_id":"themes/next/.github/workflows/codeql.yml","hash":"70a8975c47f4334ebcdd4e543b940346940054d6","modified":1745773489612},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"48e6e1e1406705379112766f4fd8388e1c53b281","modified":1745773489611},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1745773489613},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"44eb8b9706b31a4917cacddde2b3aca4ff82955b","modified":1745773489612},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.yml","hash":"10eca518b91a19984f6a5a912d41222042f61d63","modified":1745773489613},{"_id":"themes/next/.github/workflows/linter.yml","hash":"1d3d8fe53e9350e35d8349a19f65664789665e54","modified":1745773489611},{"_id":"themes/next/.github/workflows/npm-publish.yml","hash":"9749fe1114727e7e39bc65dd476b4a138f24816b","modified":1745773489611},{"_id":"themes/next/.github/workflows/lock.yml","hash":"275650a678684523f37187d0532f96aa0f49ce00","modified":1745773489612},{"_id":"themes/next/docs/ru/README.md","hash":"b0ba3546bc9e10f8e024e5a5aa2292c5fcb39d61","modified":1745773489593},{"_id":"themes/next/.github/workflows/tester.yml","hash":"9a8c366c8a0bf0e0b92035fedd93e8979adaa560","modified":1745773489611},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"12a6631617695504d5cf2a94b57d87bd331bef6f","modified":1745773489594},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"313637fe3569f98fd926e8cd0fcc75d098eb6e6e","modified":1745773489563},{"_id":"themes/next/layout/_macro/post.njk","hash":"ec9bb9c5ede773c02f0c8d8475245a8a437a2b71","modified":1745773489563},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8e9871fd9cdcccfd3441826dde236410200dc8ac","modified":1745773489594},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1745773489563},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1745773489550},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1745773489595},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1745773489552},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1745773489551},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"7261e24287984853c8ef08cda8bbc80cacf9bd6f","modified":1745773489548},{"_id":"themes/next/layout/_scripts/index.njk","hash":"2a7dfffebad19b67dc9e3b2a6b2986d0630ef930","modified":1745773489548},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"d83fb59f02c5e6630a7770401a05c02f6f07358b","modified":1745773489551},{"_id":"themes/next/layout/_third-party/addtoany.njk","hash":"ef64c6bfb8540cd874701236b9be47db2496e98e","modified":1745773489560},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1745773489558},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1745773489556},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1745773489560},{"_id":"themes/next/layout/_third-party/index.njk","hash":"dfd7cdd6ba89f8c3deabc27726c7a350cadafd11","modified":1745773489558},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1745773489604},{"_id":"themes/next/layout/_partials/footer.njk","hash":"fbf8232cacf0df87e88e74860be66c9f86018302","modified":1745773489554},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1745773489604},{"_id":"themes/next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1745773489604},{"_id":"themes/next/scripts/helpers/engine.js","hash":"83235f2879567eb8686431c9554a4b99f14ab665","modified":1745773489609},{"_id":"themes/next/scripts/filters/minify.js","hash":"2063aaa1db448ebcf7b0fdbbc54d3991a368bbd3","modified":1745773489604},{"_id":"themes/next/scripts/helpers/font.js","hash":"4c84d45daac86396edf656d2a8abe6e7583491ea","modified":1745773489608},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1745773489609},{"_id":"themes/next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1745773489607},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"4bc2eb87f3fa26981652f517d1ab3f81de2ab89d","modified":1745773489609},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1745773489609},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1745773489606},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"af3946a595f997eb43d9af87428e4898c9acbc82","modified":1745773489609},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"6281d47c1de98eb38f3aa0f6df29bbb19d412173","modified":1745773489609},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1745773489606},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1745773489605},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"f57f7e09eb6220f681fa8385082b0960502ce5c4","modified":1745773489606},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1745773489605},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1745773489606},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1745773489606},{"_id":"themes/next/scripts/tags/index.js","hash":"1f6aba7820f1fb58b61969485148db21846e1aa9","modified":1745773489606},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1745773489605},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"7d7bbc4a9970bd4c5449bc71b94364a8ec61e5d2","modified":1745773489605},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1745773489606},{"_id":"themes/next/scripts/tags/wavedrom.js","hash":"b44dfeeb58b41945d469141787f3dbce4b117d08","modified":1745773489604},{"_id":"themes/next/source/css/_mixins.styl","hash":"e21309d4165ebb6645084eed8dd749846ae981f1","modified":1745773489580},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1745773489605},{"_id":"themes/next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1745773489580},{"_id":"themes/next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1745773489564},{"_id":"themes/next/source/css/_colors.styl","hash":"ebfe0954e3931431f46f913abe08d0212e06e7c2","modified":1745773489580},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1745773489584},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1745773489584},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1745773489584},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"a38c6d92b368bfc42c72ad799ad03f3274957065","modified":1745773489584},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1745773489585},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1745773489584},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1745773489586},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1745773489592},{"_id":"themes/next/source/js/bookmark.js","hash":"9ba4cceafd12c6d5ba8a6b986a046ef8319a7811","modified":1745773489592},{"_id":"themes/next/source/js/next-boot.js","hash":"523bbaeda463e82ab0be428cc0005717038ec63e","modified":1745773489586},{"_id":"themes/next/source/js/motion.js","hash":"6f751f5c9499a39d7c5e1d323db3260342dd9431","modified":1745773489586},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1745773489585},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1745773489585},{"_id":"themes/next/source/js/sidebar.js","hash":"2ee359ae48273b01ba1e0768704524e08702c7eb","modified":1745773489585},{"_id":"themes/next/source/js/pjax.js","hash":"694b271819aab37ce473b15db9e6aded971d82e5","modified":1745773489585},{"_id":"themes/next/source/js/utils.js","hash":"345a8158e6c34e19245a07c778f5699c8673f1b1","modified":1745773489586},{"_id":"themes/next/test/helpers/font.js","hash":"a1e7c7f7cff915c137ae8bbebfa032b656cc19e1","modified":1745773489546},{"_id":"themes/next/test/tags/button.js","hash":"17a82f3962472277dc33d99d9590ac0c926e634c","modified":1745773489546},{"_id":"themes/next/test/tags/center-quote.js","hash":"170312d9721897289c8f4bf8285ce1c9a0ba8aed","modified":1745773489545},{"_id":"themes/next/test/helpers/next-url.js","hash":"52497c848a74f5716f3de0d20d7803944e139ceb","modified":1745773489547},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1745773489547},{"_id":"themes/next/test/tags/caniuse.js","hash":"dad9fddae90beef82a7c77420b4063f6c4862d66","modified":1745773489545},{"_id":"themes/next/test/tags/group-pictures.js","hash":"3ca6fc85f078ec1ff3d8df438bfbce438390b815","modified":1745773489546},{"_id":"themes/next/test/tags/mermaid.js","hash":"df5ca57bb57c517b2381580b81f7deda7d2fff65","modified":1745773489545},{"_id":"themes/next/test/tags/link-grid.js","hash":"7f1a1b4189309278164fc5e70ed7cee32609d835","modified":1745773489545},{"_id":"themes/next/test/tags/note.js","hash":"81737656ebb8050fda3af129454d26650d201a0f","modified":1745773489546},{"_id":"themes/next/test/tags/pdf.js","hash":"69be476322e19f25447c8a4ef55e5c96df829fc1","modified":1745773489545},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1745773489545},{"_id":"themes/next/test/tags/label.js","hash":"7a86d6c9e6c9774a375498c024c9c3f15e719ba1","modified":1745773489546},{"_id":"themes/next/test/tags/tabs.js","hash":"6aa68012f7cfd0e7cb1587f74d775b91fc014535","modified":1745773489545},{"_id":"themes/next/test/tags/video.js","hash":"8acc7ddd41975b6dba4263ee99c87c821d64b663","modified":1745773489546},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"93c1d103d9d16581c944c51f3d0638f57c80ee41","modified":1745773489552},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1745773489553},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1745773489553},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1745773489553},{"_id":"themes/next/test/validate/index.js","hash":"54d9225b07c7c3313d63da96261b092406e7e225","modified":1745773489544},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1745773489553},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1745773489553},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1745773489551},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1745773489551},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"bfff923526d6800218f08dba6ce0bbf5c17755fd","modified":1745773489550},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1745773489550},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1745773489551},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"6ad43135bd3aecf933ffdd750763e27ade36f97c","modified":1745773489552},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"bc5708e38b6070dff0cab6bf9480971017ce4dda","modified":1745773489549},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1745773489549},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"16696990e4ce65fc8db18c4635082a5d5d06ff07","modified":1745773489551},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1745773489549},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1745773489549},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1745773489552},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1745773489550},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1745773489561},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1745773489562},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1745773489550},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1745773489562},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1745773489562},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1745773489561},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1745773489562},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1745773489563},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"1efeeda00db08a3c033798228dd0092ee532cc36","modified":1745773489561},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1745773489558},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"3343750682fbd8535e50f8129be3003ad26015b4","modified":1745773489561},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1745773489557},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1745773489558},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1745773489557},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1745773489557},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1745773489558},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1745773489557},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1745773489557},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1745773489557},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1745773489559},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1745773489559},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1745773489559},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1745773489560},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"55c2468b2b7f035881d494085527d6554f37b556","modified":1745773489556},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"41b28f05e6233fb37700f7151f55868be10a0965","modified":1745773489560},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1745773489556},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1745773489556},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1745773489556},{"_id":"themes/next/layout/_third-party/tags/wavedrom.njk","hash":"02202bf563fb5eedde2ccad4d6c5b9109d30a703","modified":1745773489559},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1745773489559},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1745773489560},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1745773489607},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"8a8f752260be5b8098393f9879b61ffe904465e8","modified":1745773489608},{"_id":"themes/next/scripts/events/lib/config.js","hash":"00af4f5f9a79eaccf051f9e372d233d65d44c8a5","modified":1745773489608},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"5942feb3f31ed3480bf50b0f5a4a305b5bdca3d6","modified":1745773489608},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1745773489608},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"e2b4a9d6b08155735ec336eedc506763d5671821","modified":1745773489607},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1745773489604},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1745773489602},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1745773489603},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1745773489603},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1745773489603},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1745773489603},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1745773489603},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"2c800eaab6c613e5d091be2111aaa786641aa0c2","modified":1745773489579},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1745773489603},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1745773489602},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1745773489579},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"20d5c6aa136bbb55e03906d98ee90ad3fbaa80a7","modified":1745773489579},{"_id":"themes/next/source/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1745773489589},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1745773489587},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1745773489587},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b724edca546373d5eaf9b3602868f971c9094cf6","modified":1745773489579},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"879b49f693af0c04c285b2dd0c9cccaf77347b7c","modified":1745773489579},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1745773489589},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b8445c828d78a38e2de50bdc86b3bff66285ea0f","modified":1745773489571},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1745773489577},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"48b2dfc04df6409c6e0736ccc11462ad97d349b1","modified":1745773489577},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1745773489571},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1745773489571},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1745773489565},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f316ba87f8d3299677fbf8345e1e993c35210e2e","modified":1745773489567},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1745773489566},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1745773489567},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1745773489566},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1745773489569},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1745773489583},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"bcbf498d8d3ecea84324f0a59b7f95f389a52b8d","modified":1745773489581},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"69c66aab4651e2e7ae9e65f08600144970648c60","modified":1745773489564},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1745773489569},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1745773489583},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f23c53e32d140091b819be2603d1afbbb5d66933","modified":1745773489583},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1745773489581},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1745773489580},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1745773489583},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e31f6adbb22a451f07e4661cff9a2f12e4e99a36","modified":1745773489581},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1745773489583},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"c29a827e82d2820ed8977c92994da73721200fac","modified":1745773489581},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1745773489581},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1745773489581},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e792a6233e1d4dbc5fd2f10ae97b7a790b82568b","modified":1745773489582},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"a03f16ffc7dfdbdc6053f9fd68d77257ba0c559e","modified":1745773489582},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"dc03835e42d82eaf2633cf3b627990ad3e1f5967","modified":1745773489582},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1745773489582},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1745773489582},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"a92c4eb16bdb7806079467eb022ccf193bb0f794","modified":1745773489582},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1745773489589},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1745773489592},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1745773489589},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1745773489592},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1745773489592},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1745773489592},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1745773489588},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1745773489587},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1745773489588},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1745773489587},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1745773489588},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1745773489588},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1745773489590},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1745773489590},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1745773489588},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"3968d972f47b79acc6c3fe44028bad77c9c5aab7","modified":1745773489591},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"1905978ef587bf08fe088ce4693a4c08db07cfbb","modified":1745773489591},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1745773489587},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"df01075f52302873f7de36050b5408c8d1afb452","modified":1745773489590},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1745773489590},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1745773489587},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1745773489570},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1745773489590},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"809bab3414b1eb1ae44444eb821126868f764414","modified":1745773489571},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"93f014809d6442da23f8b7d729f7375e2badba7d","modified":1745773489569},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"026cd5735fd2a75bb60b7bf8bd09139583d602b9","modified":1745773489571},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1745773489570},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"0f4830e19026317ed850f3be2979556e38f97f4a","modified":1745773489569},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"424de4f64b12c521e8c6bfbc711d7961490ab36e","modified":1745773489570},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"b47fb36915962309553ff7fb1782341585ed2b76","modified":1745773489570},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1745773489572},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"ebfba158a0a4af3d1dabcacbc58986664de52140","modified":1745773489571},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1745773489570},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"54d12e2c5d9982f7b9e5b23be5133954a8514e9d","modified":1745773489572},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"1874e2b5d86cdeeaf2ccdc2669146a2b0c72d9db","modified":1745773489573},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1745773489572},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1745773489577},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1745773489573},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1745773489572},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1745773489578},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1745773489578},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"a3dd3edea9c01b66b28a8367185269b9dcc3bdee","modified":1745773489578},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1745773489578},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1745773489578},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1745773489574},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1745773489578},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1745773489573},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1745773489573},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"51a97a33879289904cb523ddc2d88b5b0c60fa72","modified":1745773489574},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"21acb11e397526132605eef23bde7b307aa1eab5","modified":1745773489575},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1745773489574},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"0847400d8579b0a2dd1bf662c78954c10adf2680","modified":1745773489575},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1745773489576},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1745773489576},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1745773489575},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"46eece42510c2c89bb9209afb0262ad76a4b0b36","modified":1745773489576},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"ce36bf1602233298e0351b4babc592315529eb26","modified":1745773489575},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1745773489576},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"741566d6ac5f852b5c8dee6a8996b65e48e7c97f","modified":1745773489577},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-copyright.styl","hash":"56805b77fe236fac19e19c716a49363bcf986311","modified":1745773489576},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"5c31f3a86e4e6fbf2f8419415620461fa8a63c56","modified":1745773489564},{"_id":"themes/next/source/css/_common/scaffolding/highlight/fold.styl","hash":"42a0b65491ad85438596b3fe0b7f23973e4cef34","modified":1745773489565},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"9b0217e1caecd91e05572c7e8e52d32016ca312f","modified":1745773489565},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1745773489576},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1745773489568},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1745773489568},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"22cd37bd5df9972d5074710896aba4424ad5161c","modified":1745773489567},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1745773489568},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"49329a7144f3413d1c832e52a1f4954171ef11e1","modified":1745773489567},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"8213015d9cae45d2c9945f8aba9d8db39c734efc","modified":1745773489568},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"c3be8b0738f693e750486bb71769c3dbbec174cc","modified":1745773489567},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1745773489567},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/2016-04-21_07-12-24.png","hash":"8b2db6e1b6c48cfdb7bf5d6f820d05bf1f5984ea","modified":1745773489538},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1745773489568},{"_id":"themes/next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"af113411ad9cca7674177be36af8dd399680834d","modified":1745773489568},{"_id":"public/404.html","hash":"c6444c089eb1c25e00126e383c9cb728bdf25726","modified":1745773740440},{"_id":"public/categories/index.html","hash":"f220f443b02f80618d1ef7d4f6be25a8d4971d43","modified":1745773740440},{"_id":"public/tags/index.html","hash":"ea0bacd147af16e624a8ceaa1e608885d276e175","modified":1745773740440},{"_id":"public/2017/12/29/error-handling-in-go/index.html","hash":"c0d1d839af36f5c37e08eb6705a96413d09c50c1","modified":1747667297817},{"_id":"public/2016/06/23/bad-parts-about-json-serialization-in-Golang/index.html","hash":"4d04e2f292162609240ca6f486b94b6664a07d24","modified":1745773740440},{"_id":"public/2016/04/20/experiences-about-develop-dlog/index.html","hash":"3af832c9cf53a33b3dfb651612a19f7ac3e43f22","modified":1745773740440},{"_id":"public/2016/03/26/product-design-vs-requirement-analysis/index.html","hash":"08df65c64ad874caabd35726a463e56902d71bfb","modified":1745773740440},{"_id":"public/archives/index.html","hash":"4db7ff4eb01d4415f6a645bfb9b772aea6c20bf5","modified":1745773740440},{"_id":"public/archives/2016/index.html","hash":"b106526cf3638723c49fd7e1fb7f19744ded9b08","modified":1745773740440},{"_id":"public/archives/2016/03/index.html","hash":"8aae305228bbb812503a674e977efc07909b7923","modified":1745773740440},{"_id":"public/archives/2016/04/index.html","hash":"4369fc9527f07b5e0d30f16dfe62bdf8e33857e2","modified":1745773740440},{"_id":"public/archives/2016/06/index.html","hash":"0be07d074ee158e2ed337abe71471f70f8768036","modified":1745773740440},{"_id":"public/archives/2017/index.html","hash":"c3db79a58a37c5f616724928f4f2aad1f699ac1a","modified":1745773740440},{"_id":"public/archives/2017/12/index.html","hash":"bf2b1c6aa519a0f7041824b5d77c6b48922d0531","modified":1745773740440},{"_id":"public/categories/产品/index.html","hash":"44da86c85bb6dfdc149d3f9b80dabb6de2dee0a5","modified":1745773740440},{"_id":"public/categories/编程开发/index.html","hash":"3681f20649ba3150e096d535ff55749fe5449b36","modified":1745773740440},{"_id":"public/index.html","hash":"e436823d071e6ba9a883bf84dfc0e5a7444979f3","modified":1747667297817},{"_id":"public/tags/产品设计/index.html","hash":"613ac6b96f2925f93cb2f6cf9f86168a78615798","modified":1745773740440},{"_id":"public/tags/需求分析/index.html","hash":"08765472edb26fafc0a79941057f2fefb4e86982","modified":1745773740440},{"_id":"public/tags/golang/index.html","hash":"b6e90899f1ccf30705552bd47185f4c1e47d808a","modified":1745773740440},{"_id":"public/tags/json/index.html","hash":"26d8a3e16eac39b55af5e59851c322d004f5daff","modified":1745773740440},{"_id":"public/samples/expvarsample.go","hash":"40e471129b2c9c1599977e73955d9ff19ea6f821","modified":1745773740440},{"_id":"public/images/avatar.jpg","hash":"c4dd28a263439f83c15ddc069d97642fcf22065f","modified":1745773740440},{"_id":"public/favicon.ico","hash":"1f7d35b787b1751eef2793a2a8c6171dff51820f","modified":1745773740440},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1745773740440},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1745773740440},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1745773740440},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"a38c6d92b368bfc42c72ad799ad03f3274957065","modified":1745773740440},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1745773740440},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1745773740440},{"_id":"public/2016/04/20/experiences-about-develop-dlog/channel.png","hash":"07fa353dc547212f594f859c2dde0c217eff983b","modified":1745773740440},{"_id":"public/2016/04/20/experiences-about-develop-dlog/use_channel.png","hash":"853e9b256bf1db8aee27f55ec881305eb52d1ab6","modified":1745773740440},{"_id":"public/css/main.css","hash":"3ee14cd83bbbb18bf1ec21b6b26f6896a0ae9646","modified":1745773740440},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1745773740440},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1745773740440},{"_id":"public/js/bookmark.js","hash":"9ba4cceafd12c6d5ba8a6b986a046ef8319a7811","modified":1745773740440},{"_id":"public/js/next-boot.js","hash":"523bbaeda463e82ab0be428cc0005717038ec63e","modified":1745773740440},{"_id":"public/js/pjax.js","hash":"694b271819aab37ce473b15db9e6aded971d82e5","modified":1745773740440},{"_id":"public/js/motion.js","hash":"6f751f5c9499a39d7c5e1d323db3260342dd9431","modified":1745773740440},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1745773740440},{"_id":"public/js/sidebar.js","hash":"2ee359ae48273b01ba1e0768704524e08702c7eb","modified":1745773740440},{"_id":"public/js/utils.js","hash":"345a8158e6c34e19245a07c778f5699c8673f1b1","modified":1745773740440},{"_id":"public/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1745773740440},{"_id":"public/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1745773740440},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1745773740440},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1745773740440},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1745773740440},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1745773740440},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1745773740440},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1745773740440},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1745773740440},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1745773740440},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1745773740440},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1745773740440},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1745773740440},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1745773740440},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1745773740440},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1745773740440},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1745773740440},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1745773740440},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1745773740440},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1745773740440},{"_id":"public/js/third-party/search/local-search.js","hash":"3968d972f47b79acc6c3fe44028bad77c9c5aab7","modified":1745773740440},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1745773740440},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1745773740440},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1745773740440},{"_id":"public/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1745773740440},{"_id":"public/js/third-party/tags/mermaid.js","hash":"df01075f52302873f7de36050b5408c8d1afb452","modified":1745773740440},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1745773740440},{"_id":"public/js/third-party/search/algolia-search.js","hash":"1905978ef587bf08fe088ce4693a4c08db07cfbb","modified":1745773740440},{"_id":"public/2016/04/20/experiences-about-develop-dlog/expvarmon_screen.png","hash":"3cf57a3f5a4de25e898ce566770f123a6efb8eb4","modified":1745773740440},{"_id":"public/2017/12/29/error-handling-in-go/d2a2d12e1a00f819d7fd7af4b536efa2.png","hash":"ae40aa7e6dcc2d443100f55eeebea79c3fa6b305","modified":1745773740440},{"_id":"public/2016/04/20/experiences-about-develop-dlog/2016-04-21_07-12-40.png","hash":"328e623a575da9a88b9a2cbb058d787e520ece1b","modified":1745773740440},{"_id":"public/2016/04/20/experiences-about-develop-dlog/2016-04-21_07-12-24.png","hash":"8b2db6e1b6c48cfdb7bf5d6f820d05bf1f5984ea","modified":1745773740440},{"_id":"public/2016/03/26/product-design-vs-requirement-analysis/0f819d7fd7af4b536efa2.png","hash":"ae40aa7e6dcc2d443100f55eeebea79c3fa6b305","modified":1745774101617}],"Category":[{"name":"产品","_id":"cm9zwlzc50004fdjhbnwv3p2a"},{"name":"编程开发","_id":"cm9zwlzc60009fdjh0j7u3jui"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","date":"2025-04-27T17:04:49.541Z","updated":"2025-04-27T17:04:49.541Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cm9zwlzc20000fdjh9r3qcsdi","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n"},{"title":"分类","date":"2016-04-23T12:10:41.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-04-23 20:10:41\ntype: \"categories\"\ncomments: false\n---\n","updated":"2025-04-27T17:04:49.543Z","path":"categories/index.html","layout":"page","_id":"cm9zwlzc40002fdjh4s6b1l0p","content":"","excerpt":"","more":""},{"title":"所有标签","date":"2016-04-23T12:05:07.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 所有标签\ndate: 2016-04-23 20:05:07\ntype: \"tags\"\ncomments: false\n---\n","updated":"2025-04-27T17:04:49.542Z","path":"tags/index.html","layout":"page","_id":"cm9zwlzc60006fdjh69z80ofz","content":"","excerpt":"","more":""}],"Post":[{"title":"需求分析：填补产品设计到技术实现之间的“信息断层”","date":"2016-03-26T13:13:28.000Z","_content":"\n    “体育运动有规则，而对格斗来说，是没有规则的。所以为了迎接格斗，你应该训练身体的所有部位。”\n    ——李小龙\n\n# 前言\n\n我参加工作是2006年，去的第一家公司是四维图新。那时在技术部从事软件开发工作，功能需求是由技术部的需求组提供的。业务部门要做什么东西，会先给需求组提需求，然后需求组将业务需求整理好，以需求单的形式提供给各个系统开发组。那时候，大家开会说“产品”，指的是公司出版的地图数据，而不是技术部门开发的各个系统、软件工具。学习的内容也是CMMI（软件能力成熟度模型）、RUP（统一软件开发过程）、MSF（微软解决方案框架结构）、UML。\n\n2011年我加入艺龙旅行网，那时艺龙有这么两个部门，一个是网站产品组，一个是业务流程改进组。网站产品负责给面向消费者的预订网站提需求，而业务流程改进组负责给内部呼叫中心使用的系统、面向酒店的业务系统提需求。这两个组后来合并成一个产品团队。我在艺龙负责Ebooking产品的开发和运维工作，和产品经理打了3年的交道，期间自己学习了产品经理的相关知识并且担任一段时间的产品经理。\n\n在艺龙期间以及后来的工作中，我看到一些团队的产品经理很优秀，开发人员技术也很强，但是有时候一个小的需求变更导致技术上的大调整，整个产品开发过程“鸡飞狗跳”，反倒有时候不如以前和一些经验丰富的需求分析师合作时候，产品开发过程更顺畅。\n\n# “产品设计”和“需求分析”比较\n\n在传统软件开发企业和互联网企业都工作过的软件工程师，会发现“传统”需求分析师、“互联网”产品经理这两种角色工作内容有着一些明显的区别。\n\n我们通过下面一个测试来了解一下大家所认为的这两个角色的工作内容。下面给出一些概念，如果你认为更接近产品设计，就在产品设计列打“x”，反之在需求分析列下打“x”。\n\n| 名词                            | 产品设计 | 需求分析 |\n|:--------------------------------|:---------|:---------|\n| 商业模式                        |          |          |\n| 用户体验                        |          |          |\n| 用户心智                        |          |          |\n| 用户习惯                        |          |          |\n| 用户愿景                        |          |          |\n| 用户需求驱动                    |          |          |\n| 业务需求驱动                    |          |          |\n| 渉众                            |          |          |\n| 用户角色                        |          |          |\n| 业务执行者                      |          |          |\n| 业务工人                        |          |          |\n| 以用户价值为中心                |          |          |\n| 以业务需求为中心                |          |          |\n| 甲方、乙方                      |          |          |\n| 数据分析                        |          |          |\n| 信息建模                        |          |          |\n| 信息架构                        |          |          |\n| 面向对象方法                    |          |          |\n| UML流程图、状态图、时序图、类图 |          |          |\n| E-R关系图                       |          |          |\n| 需求文档                        |          |          |\n| 产品原型                        |          |          |\n| Rational                        |          |          |\n| Axure RP                        |          |          |\n| Sketch                          |          |          |\n| UI、UE                          |          |          |\n| 视觉设计                        |          |          |\n| 交互设计                        |          |          |\n| 业务用例                        |          |          |\n| 推广策略                        |          |          |\n\n\n以上概念基本可以分为“关注点”、“考虑问题的模式和方法”、“工作内容”、“常用工具”、“工作交付物”这么几类。相信大部分人选择的接近下面这个答案：\n\n| 名词                            | 产品设计 | 需求分析 |\n|:--------------------------------|:---------|:---------|\n| 商业模式                        | x        |          |\n| 用户体验                        | x        |          |\n| 用户心智                        | x        |          |\n| 用户习惯                        | x        |          |\n| 用户愿景                        |          | x        |\n| 用户需求驱动                    | x        |          |\n| 业务需求驱动                    |          | x        |\n| 渉众                            |          | x        |\n| 用户角色                        | x        |          |\n| 业务执行者                      |          | x        |\n| 业务工人                        |          | x        |\n| 以用户价值为中心                | x        |          |\n| 以业务需求为中心                |          | x        |\n| 甲方、乙方                      |          | x        |\n| 数据分析                        | x        | x        |\n| 信息建模                        |          | x        |\n| 信息架构                        | x        |          |\n| 面向对象方法                    |          | x        |\n| UML流程图、状态图、时序图、类图 |          | x        |\n| E-R关系图                       |          | x        |\n| 需求文档                        |          | x        |\n| 产品原型                        | x        |          |\n| Rational                        |          | x        |\n| Axure RP                        | x        |          |\n| Sketch                          | x        |          |\n| UI、UE                          | x        |          |\n| 视觉设计                        | x        |          |\n| 交互设计                        | x        |          |\n| 业务用例                        |          | x        |\n| 推广策略                        | x        |          |\n\n不知道大家做完这个测试后，是不是觉得做产品设计比做需求分析牛逼多了。很多产品经理的书籍中都会将“产品设计”描述的高大上：\n\n- 产品设计是用户价值驱动，需求分析是业务需求驱动。\n- 所谓设计，就是通过创造与交流来认识我们生活在其中的世界。好的认识和发现，会让我们感到喜悦和骄傲。\n- 互联网产品设计绝不是编写产品交互说明书，也不是创造优美的界面，本质是创造一连串的体验，使用户能感知到产品的文化、价值和内涵，从而引发集群效应、创造社会价值。\n\n以上的话说的都对，绝对正确。在乔老爷子的引领下，如今很多公司重视产品设计，这是好事。但是于此同时产生另外一种做法：不重视需求分析，甚至直接忽略。老板、产品经理这么做可以理解，工程师如果也这么附和，就是做事不过大脑。\n\n# 需求分析是否有继续存在的价值\n\n产品设计要取代需求分析，只可能是下面两种情况：\n\n- 产品设计涵盖了需求分析的所有工作内容\n- 属于需求分析但是不属于产品设计的工作内容已不再重要，可以不用去做\n\n第一种情况，需求分析中的业务建模、画E-R关系图、UML流程图、时序图、状态图，在大多数公司中，是由需求分析师或者工程师来做，不属于产品设计的工作范畴。产品设计显然不涵盖需求分析的所有工作内容。\n\n第二种情况，面对复杂业务场景，通过业务建模、画E-R关系图、UML流程图、时序图、状态图等手段做需求分析，是前辈软件工程师总结出来宝贵方法和经验。产品经理一般会将整理后的产品需求通过各种方式（口述、文档、UI/UE设计等）传递给工程团队，但是这些信息一般都是站在业务边界或系统边界描述的产品功能需求，和工程实现存在**信息断层**。产品需求如何映射到代码实现，需要一个系统化的需求分析、设计过程，产品设计并不解决过去几十年软件开发行业发明各种软件需求分析方法所解决的问题。任何脑袋没有烧掉的公司都不会说软件需求分析工作不重要、不需要做。\n\n# 需求分析应继续得到坚持和重视\n\n如果只关注产品设计，更多的时候，你会认为设计出来的界面很美观，交互也很舒服，该说的需求都告诉工程团队了，但是工程开发阶段，出现各种问题：概念不明确、架构无法设计、逻辑混乱、后期变更困难。\n\n如果只关注需求分析，更多的时候，你会发现不知道如何提产品需求，产品开发出来了，认为做很牛逼，但是客户觉得不好用，产品不好卖。\n\n所有公司都希望做出成功的产品。但是未经仔细思考，就忽略软件需求分析方法，不是一个经得起推敲的做法。只有产品设计、需求分析都做好了，产品才能成功。\n\n# 参考\n\n- [UMLChina](http://www.umlchina.com/)\n- [李小龙截拳道](http://v.youku.com/v_show/id_XMTIzMzczNg==.html)\n","source":"_posts/2016-03-26-product-design-vs-requirement-analysis.md","raw":"---\ntitle: 需求分析：填补产品设计到技术实现之间的“信息断层”\ndate: 2016-03-26 21:13:28\ncategories:\n- 产品\ntags:\n- 产品设计\n- 需求分析\n---\n\n    “体育运动有规则，而对格斗来说，是没有规则的。所以为了迎接格斗，你应该训练身体的所有部位。”\n    ——李小龙\n\n# 前言\n\n我参加工作是2006年，去的第一家公司是四维图新。那时在技术部从事软件开发工作，功能需求是由技术部的需求组提供的。业务部门要做什么东西，会先给需求组提需求，然后需求组将业务需求整理好，以需求单的形式提供给各个系统开发组。那时候，大家开会说“产品”，指的是公司出版的地图数据，而不是技术部门开发的各个系统、软件工具。学习的内容也是CMMI（软件能力成熟度模型）、RUP（统一软件开发过程）、MSF（微软解决方案框架结构）、UML。\n\n2011年我加入艺龙旅行网，那时艺龙有这么两个部门，一个是网站产品组，一个是业务流程改进组。网站产品负责给面向消费者的预订网站提需求，而业务流程改进组负责给内部呼叫中心使用的系统、面向酒店的业务系统提需求。这两个组后来合并成一个产品团队。我在艺龙负责Ebooking产品的开发和运维工作，和产品经理打了3年的交道，期间自己学习了产品经理的相关知识并且担任一段时间的产品经理。\n\n在艺龙期间以及后来的工作中，我看到一些团队的产品经理很优秀，开发人员技术也很强，但是有时候一个小的需求变更导致技术上的大调整，整个产品开发过程“鸡飞狗跳”，反倒有时候不如以前和一些经验丰富的需求分析师合作时候，产品开发过程更顺畅。\n\n# “产品设计”和“需求分析”比较\n\n在传统软件开发企业和互联网企业都工作过的软件工程师，会发现“传统”需求分析师、“互联网”产品经理这两种角色工作内容有着一些明显的区别。\n\n我们通过下面一个测试来了解一下大家所认为的这两个角色的工作内容。下面给出一些概念，如果你认为更接近产品设计，就在产品设计列打“x”，反之在需求分析列下打“x”。\n\n| 名词                            | 产品设计 | 需求分析 |\n|:--------------------------------|:---------|:---------|\n| 商业模式                        |          |          |\n| 用户体验                        |          |          |\n| 用户心智                        |          |          |\n| 用户习惯                        |          |          |\n| 用户愿景                        |          |          |\n| 用户需求驱动                    |          |          |\n| 业务需求驱动                    |          |          |\n| 渉众                            |          |          |\n| 用户角色                        |          |          |\n| 业务执行者                      |          |          |\n| 业务工人                        |          |          |\n| 以用户价值为中心                |          |          |\n| 以业务需求为中心                |          |          |\n| 甲方、乙方                      |          |          |\n| 数据分析                        |          |          |\n| 信息建模                        |          |          |\n| 信息架构                        |          |          |\n| 面向对象方法                    |          |          |\n| UML流程图、状态图、时序图、类图 |          |          |\n| E-R关系图                       |          |          |\n| 需求文档                        |          |          |\n| 产品原型                        |          |          |\n| Rational                        |          |          |\n| Axure RP                        |          |          |\n| Sketch                          |          |          |\n| UI、UE                          |          |          |\n| 视觉设计                        |          |          |\n| 交互设计                        |          |          |\n| 业务用例                        |          |          |\n| 推广策略                        |          |          |\n\n\n以上概念基本可以分为“关注点”、“考虑问题的模式和方法”、“工作内容”、“常用工具”、“工作交付物”这么几类。相信大部分人选择的接近下面这个答案：\n\n| 名词                            | 产品设计 | 需求分析 |\n|:--------------------------------|:---------|:---------|\n| 商业模式                        | x        |          |\n| 用户体验                        | x        |          |\n| 用户心智                        | x        |          |\n| 用户习惯                        | x        |          |\n| 用户愿景                        |          | x        |\n| 用户需求驱动                    | x        |          |\n| 业务需求驱动                    |          | x        |\n| 渉众                            |          | x        |\n| 用户角色                        | x        |          |\n| 业务执行者                      |          | x        |\n| 业务工人                        |          | x        |\n| 以用户价值为中心                | x        |          |\n| 以业务需求为中心                |          | x        |\n| 甲方、乙方                      |          | x        |\n| 数据分析                        | x        | x        |\n| 信息建模                        |          | x        |\n| 信息架构                        | x        |          |\n| 面向对象方法                    |          | x        |\n| UML流程图、状态图、时序图、类图 |          | x        |\n| E-R关系图                       |          | x        |\n| 需求文档                        |          | x        |\n| 产品原型                        | x        |          |\n| Rational                        |          | x        |\n| Axure RP                        | x        |          |\n| Sketch                          | x        |          |\n| UI、UE                          | x        |          |\n| 视觉设计                        | x        |          |\n| 交互设计                        | x        |          |\n| 业务用例                        |          | x        |\n| 推广策略                        | x        |          |\n\n不知道大家做完这个测试后，是不是觉得做产品设计比做需求分析牛逼多了。很多产品经理的书籍中都会将“产品设计”描述的高大上：\n\n- 产品设计是用户价值驱动，需求分析是业务需求驱动。\n- 所谓设计，就是通过创造与交流来认识我们生活在其中的世界。好的认识和发现，会让我们感到喜悦和骄傲。\n- 互联网产品设计绝不是编写产品交互说明书，也不是创造优美的界面，本质是创造一连串的体验，使用户能感知到产品的文化、价值和内涵，从而引发集群效应、创造社会价值。\n\n以上的话说的都对，绝对正确。在乔老爷子的引领下，如今很多公司重视产品设计，这是好事。但是于此同时产生另外一种做法：不重视需求分析，甚至直接忽略。老板、产品经理这么做可以理解，工程师如果也这么附和，就是做事不过大脑。\n\n# 需求分析是否有继续存在的价值\n\n产品设计要取代需求分析，只可能是下面两种情况：\n\n- 产品设计涵盖了需求分析的所有工作内容\n- 属于需求分析但是不属于产品设计的工作内容已不再重要，可以不用去做\n\n第一种情况，需求分析中的业务建模、画E-R关系图、UML流程图、时序图、状态图，在大多数公司中，是由需求分析师或者工程师来做，不属于产品设计的工作范畴。产品设计显然不涵盖需求分析的所有工作内容。\n\n第二种情况，面对复杂业务场景，通过业务建模、画E-R关系图、UML流程图、时序图、状态图等手段做需求分析，是前辈软件工程师总结出来宝贵方法和经验。产品经理一般会将整理后的产品需求通过各种方式（口述、文档、UI/UE设计等）传递给工程团队，但是这些信息一般都是站在业务边界或系统边界描述的产品功能需求，和工程实现存在**信息断层**。产品需求如何映射到代码实现，需要一个系统化的需求分析、设计过程，产品设计并不解决过去几十年软件开发行业发明各种软件需求分析方法所解决的问题。任何脑袋没有烧掉的公司都不会说软件需求分析工作不重要、不需要做。\n\n# 需求分析应继续得到坚持和重视\n\n如果只关注产品设计，更多的时候，你会认为设计出来的界面很美观，交互也很舒服，该说的需求都告诉工程团队了，但是工程开发阶段，出现各种问题：概念不明确、架构无法设计、逻辑混乱、后期变更困难。\n\n如果只关注需求分析，更多的时候，你会发现不知道如何提产品需求，产品开发出来了，认为做很牛逼，但是客户觉得不好用，产品不好卖。\n\n所有公司都希望做出成功的产品。但是未经仔细思考，就忽略软件需求分析方法，不是一个经得起推敲的做法。只有产品设计、需求分析都做好了，产品才能成功。\n\n# 参考\n\n- [UMLChina](http://www.umlchina.com/)\n- [李小龙截拳道](http://v.youku.com/v_show/id_XMTIzMzczNg==.html)\n","slug":"product-design-vs-requirement-analysis","published":1,"updated":"2025-04-27T17:04:49.539Z","comments":1,"layout":"post","photos":[],"_id":"cm9zwlzc20001fdjh8l2s8eko","content":"<pre><code>“体育运动有规则，而对格斗来说，是没有规则的。所以为了迎接格斗，你应该训练身体的所有部位。”\n——李小龙\n</code></pre>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我参加工作是2006年，去的第一家公司是四维图新。那时在技术部从事软件开发工作，功能需求是由技术部的需求组提供的。业务部门要做什么东西，会先给需求组提需求，然后需求组将业务需求整理好，以需求单的形式提供给各个系统开发组。那时候，大家开会说“产品”，指的是公司出版的地图数据，而不是技术部门开发的各个系统、软件工具。学习的内容也是CMMI（软件能力成熟度模型）、RUP（统一软件开发过程）、MSF（微软解决方案框架结构）、UML。</p>\n<p>2011年我加入艺龙旅行网，那时艺龙有这么两个部门，一个是网站产品组，一个是业务流程改进组。网站产品负责给面向消费者的预订网站提需求，而业务流程改进组负责给内部呼叫中心使用的系统、面向酒店的业务系统提需求。这两个组后来合并成一个产品团队。我在艺龙负责Ebooking产品的开发和运维工作，和产品经理打了3年的交道，期间自己学习了产品经理的相关知识并且担任一段时间的产品经理。</p>\n<p>在艺龙期间以及后来的工作中，我看到一些团队的产品经理很优秀，开发人员技术也很强，但是有时候一个小的需求变更导致技术上的大调整，整个产品开发过程“鸡飞狗跳”，反倒有时候不如以前和一些经验丰富的需求分析师合作时候，产品开发过程更顺畅。</p>\n<h1 id=\"“产品设计”和“需求分析”比较\"><a href=\"#“产品设计”和“需求分析”比较\" class=\"headerlink\" title=\"“产品设计”和“需求分析”比较\"></a>“产品设计”和“需求分析”比较</h1><p>在传统软件开发企业和互联网企业都工作过的软件工程师，会发现“传统”需求分析师、“互联网”产品经理这两种角色工作内容有着一些明显的区别。</p>\n<p>我们通过下面一个测试来了解一下大家所认为的这两个角色的工作内容。下面给出一些概念，如果你认为更接近产品设计，就在产品设计列打“x”，反之在需求分析列下打“x”。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">产品设计</th>\n<th align=\"left\">需求分析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">商业模式</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户体验</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户心智</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户习惯</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户愿景</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户需求驱动</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务需求驱动</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">渉众</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户角色</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务执行者</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务工人</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">以用户价值为中心</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">以业务需求为中心</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">甲方、乙方</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">数据分析</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">信息建模</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">信息架构</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">面向对象方法</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">UML流程图、状态图、时序图、类图</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">E-R关系图</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">需求文档</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">产品原型</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Rational</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Axure RP</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Sketch</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">UI、UE</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">视觉设计</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">交互设计</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务用例</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">推广策略</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>以上概念基本可以分为“关注点”、“考虑问题的模式和方法”、“工作内容”、“常用工具”、“工作交付物”这么几类。相信大部分人选择的接近下面这个答案：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">产品设计</th>\n<th align=\"left\">需求分析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">商业模式</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户体验</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户心智</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户习惯</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户愿景</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">用户需求驱动</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务需求驱动</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">渉众</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">用户角色</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务执行者</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">业务工人</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">以用户价值为中心</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">以业务需求为中心</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">甲方、乙方</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">数据分析</td>\n<td align=\"left\">x</td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">信息建模</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">信息架构</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">面向对象方法</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">UML流程图、状态图、时序图、类图</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">E-R关系图</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">需求文档</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">产品原型</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Rational</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">Axure RP</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Sketch</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">UI、UE</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">视觉设计</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">交互设计</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务用例</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">推广策略</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>不知道大家做完这个测试后，是不是觉得做产品设计比做需求分析牛逼多了。很多产品经理的书籍中都会将“产品设计”描述的高大上：</p>\n<ul>\n<li>产品设计是用户价值驱动，需求分析是业务需求驱动。</li>\n<li>所谓设计，就是通过创造与交流来认识我们生活在其中的世界。好的认识和发现，会让我们感到喜悦和骄傲。</li>\n<li>互联网产品设计绝不是编写产品交互说明书，也不是创造优美的界面，本质是创造一连串的体验，使用户能感知到产品的文化、价值和内涵，从而引发集群效应、创造社会价值。</li>\n</ul>\n<p>以上的话说的都对，绝对正确。在乔老爷子的引领下，如今很多公司重视产品设计，这是好事。但是于此同时产生另外一种做法：不重视需求分析，甚至直接忽略。老板、产品经理这么做可以理解，工程师如果也这么附和，就是做事不过大脑。</p>\n<h1 id=\"需求分析是否有继续存在的价值\"><a href=\"#需求分析是否有继续存在的价值\" class=\"headerlink\" title=\"需求分析是否有继续存在的价值\"></a>需求分析是否有继续存在的价值</h1><p>产品设计要取代需求分析，只可能是下面两种情况：</p>\n<ul>\n<li>产品设计涵盖了需求分析的所有工作内容</li>\n<li>属于需求分析但是不属于产品设计的工作内容已不再重要，可以不用去做</li>\n</ul>\n<p>第一种情况，需求分析中的业务建模、画E-R关系图、UML流程图、时序图、状态图，在大多数公司中，是由需求分析师或者工程师来做，不属于产品设计的工作范畴。产品设计显然不涵盖需求分析的所有工作内容。</p>\n<p>第二种情况，面对复杂业务场景，通过业务建模、画E-R关系图、UML流程图、时序图、状态图等手段做需求分析，是前辈软件工程师总结出来宝贵方法和经验。产品经理一般会将整理后的产品需求通过各种方式（口述、文档、UI&#x2F;UE设计等）传递给工程团队，但是这些信息一般都是站在业务边界或系统边界描述的产品功能需求，和工程实现存在<strong>信息断层</strong>。产品需求如何映射到代码实现，需要一个系统化的需求分析、设计过程，产品设计并不解决过去几十年软件开发行业发明各种软件需求分析方法所解决的问题。任何脑袋没有烧掉的公司都不会说软件需求分析工作不重要、不需要做。</p>\n<h1 id=\"需求分析应继续得到坚持和重视\"><a href=\"#需求分析应继续得到坚持和重视\" class=\"headerlink\" title=\"需求分析应继续得到坚持和重视\"></a>需求分析应继续得到坚持和重视</h1><p>如果只关注产品设计，更多的时候，你会认为设计出来的界面很美观，交互也很舒服，该说的需求都告诉工程团队了，但是工程开发阶段，出现各种问题：概念不明确、架构无法设计、逻辑混乱、后期变更困难。</p>\n<p>如果只关注需求分析，更多的时候，你会发现不知道如何提产品需求，产品开发出来了，认为做很牛逼，但是客户觉得不好用，产品不好卖。</p>\n<p>所有公司都希望做出成功的产品。但是未经仔细思考，就忽略软件需求分析方法，不是一个经得起推敲的做法。只有产品设计、需求分析都做好了，产品才能成功。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://www.umlchina.com/\">UMLChina</a></li>\n<li><a href=\"http://v.youku.com/v_show/id_XMTIzMzczNg==.html\">李小龙截拳道</a></li>\n</ul>\n","excerpt":"","more":"<pre><code>“体育运动有规则，而对格斗来说，是没有规则的。所以为了迎接格斗，你应该训练身体的所有部位。”\n——李小龙\n</code></pre>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我参加工作是2006年，去的第一家公司是四维图新。那时在技术部从事软件开发工作，功能需求是由技术部的需求组提供的。业务部门要做什么东西，会先给需求组提需求，然后需求组将业务需求整理好，以需求单的形式提供给各个系统开发组。那时候，大家开会说“产品”，指的是公司出版的地图数据，而不是技术部门开发的各个系统、软件工具。学习的内容也是CMMI（软件能力成熟度模型）、RUP（统一软件开发过程）、MSF（微软解决方案框架结构）、UML。</p>\n<p>2011年我加入艺龙旅行网，那时艺龙有这么两个部门，一个是网站产品组，一个是业务流程改进组。网站产品负责给面向消费者的预订网站提需求，而业务流程改进组负责给内部呼叫中心使用的系统、面向酒店的业务系统提需求。这两个组后来合并成一个产品团队。我在艺龙负责Ebooking产品的开发和运维工作，和产品经理打了3年的交道，期间自己学习了产品经理的相关知识并且担任一段时间的产品经理。</p>\n<p>在艺龙期间以及后来的工作中，我看到一些团队的产品经理很优秀，开发人员技术也很强，但是有时候一个小的需求变更导致技术上的大调整，整个产品开发过程“鸡飞狗跳”，反倒有时候不如以前和一些经验丰富的需求分析师合作时候，产品开发过程更顺畅。</p>\n<h1 id=\"“产品设计”和“需求分析”比较\"><a href=\"#“产品设计”和“需求分析”比较\" class=\"headerlink\" title=\"“产品设计”和“需求分析”比较\"></a>“产品设计”和“需求分析”比较</h1><p>在传统软件开发企业和互联网企业都工作过的软件工程师，会发现“传统”需求分析师、“互联网”产品经理这两种角色工作内容有着一些明显的区别。</p>\n<p>我们通过下面一个测试来了解一下大家所认为的这两个角色的工作内容。下面给出一些概念，如果你认为更接近产品设计，就在产品设计列打“x”，反之在需求分析列下打“x”。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">产品设计</th>\n<th align=\"left\">需求分析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">商业模式</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户体验</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户心智</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户习惯</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户愿景</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户需求驱动</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务需求驱动</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">渉众</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户角色</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务执行者</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务工人</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">以用户价值为中心</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">以业务需求为中心</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">甲方、乙方</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">数据分析</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">信息建模</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">信息架构</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">面向对象方法</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">UML流程图、状态图、时序图、类图</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">E-R关系图</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">需求文档</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">产品原型</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Rational</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Axure RP</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Sketch</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">UI、UE</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">视觉设计</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">交互设计</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务用例</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">推广策略</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>以上概念基本可以分为“关注点”、“考虑问题的模式和方法”、“工作内容”、“常用工具”、“工作交付物”这么几类。相信大部分人选择的接近下面这个答案：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">产品设计</th>\n<th align=\"left\">需求分析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">商业模式</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户体验</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户心智</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户习惯</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">用户愿景</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">用户需求驱动</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务需求驱动</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">渉众</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">用户角色</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务执行者</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">业务工人</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">以用户价值为中心</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">以业务需求为中心</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">甲方、乙方</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">数据分析</td>\n<td align=\"left\">x</td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">信息建模</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">信息架构</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">面向对象方法</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">UML流程图、状态图、时序图、类图</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">E-R关系图</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">需求文档</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">产品原型</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Rational</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">Axure RP</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Sketch</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">UI、UE</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">视觉设计</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">交互设计</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">业务用例</td>\n<td align=\"left\"></td>\n<td align=\"left\">x</td>\n</tr>\n<tr>\n<td align=\"left\">推广策略</td>\n<td align=\"left\">x</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>不知道大家做完这个测试后，是不是觉得做产品设计比做需求分析牛逼多了。很多产品经理的书籍中都会将“产品设计”描述的高大上：</p>\n<ul>\n<li>产品设计是用户价值驱动，需求分析是业务需求驱动。</li>\n<li>所谓设计，就是通过创造与交流来认识我们生活在其中的世界。好的认识和发现，会让我们感到喜悦和骄傲。</li>\n<li>互联网产品设计绝不是编写产品交互说明书，也不是创造优美的界面，本质是创造一连串的体验，使用户能感知到产品的文化、价值和内涵，从而引发集群效应、创造社会价值。</li>\n</ul>\n<p>以上的话说的都对，绝对正确。在乔老爷子的引领下，如今很多公司重视产品设计，这是好事。但是于此同时产生另外一种做法：不重视需求分析，甚至直接忽略。老板、产品经理这么做可以理解，工程师如果也这么附和，就是做事不过大脑。</p>\n<h1 id=\"需求分析是否有继续存在的价值\"><a href=\"#需求分析是否有继续存在的价值\" class=\"headerlink\" title=\"需求分析是否有继续存在的价值\"></a>需求分析是否有继续存在的价值</h1><p>产品设计要取代需求分析，只可能是下面两种情况：</p>\n<ul>\n<li>产品设计涵盖了需求分析的所有工作内容</li>\n<li>属于需求分析但是不属于产品设计的工作内容已不再重要，可以不用去做</li>\n</ul>\n<p>第一种情况，需求分析中的业务建模、画E-R关系图、UML流程图、时序图、状态图，在大多数公司中，是由需求分析师或者工程师来做，不属于产品设计的工作范畴。产品设计显然不涵盖需求分析的所有工作内容。</p>\n<p>第二种情况，面对复杂业务场景，通过业务建模、画E-R关系图、UML流程图、时序图、状态图等手段做需求分析，是前辈软件工程师总结出来宝贵方法和经验。产品经理一般会将整理后的产品需求通过各种方式（口述、文档、UI&#x2F;UE设计等）传递给工程团队，但是这些信息一般都是站在业务边界或系统边界描述的产品功能需求，和工程实现存在<strong>信息断层</strong>。产品需求如何映射到代码实现，需要一个系统化的需求分析、设计过程，产品设计并不解决过去几十年软件开发行业发明各种软件需求分析方法所解决的问题。任何脑袋没有烧掉的公司都不会说软件需求分析工作不重要、不需要做。</p>\n<h1 id=\"需求分析应继续得到坚持和重视\"><a href=\"#需求分析应继续得到坚持和重视\" class=\"headerlink\" title=\"需求分析应继续得到坚持和重视\"></a>需求分析应继续得到坚持和重视</h1><p>如果只关注产品设计，更多的时候，你会认为设计出来的界面很美观，交互也很舒服，该说的需求都告诉工程团队了，但是工程开发阶段，出现各种问题：概念不明确、架构无法设计、逻辑混乱、后期变更困难。</p>\n<p>如果只关注需求分析，更多的时候，你会发现不知道如何提产品需求，产品开发出来了，认为做很牛逼，但是客户觉得不好用，产品不好卖。</p>\n<p>所有公司都希望做出成功的产品。但是未经仔细思考，就忽略软件需求分析方法，不是一个经得起推敲的做法。只有产品设计、需求分析都做好了，产品才能成功。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://www.umlchina.com/\">UMLChina</a></li>\n<li><a href=\"http://v.youku.com/v_show/id_XMTIzMzczNg==.html\">李小龙截拳道</a></li>\n</ul>\n"},{"title":"Golang中遇到的一些关于JSON处理的坑","date":"2016-06-23T00:09:39.000Z","_content":"\n\n# 前言\n\n一个人不会两次掉进同一个坑里，但是如果他（她）忘记了坑的位置，那就不一定了。\n\n这篇文章记录了最近使用Golang处理JSON遇到的一些坑。\n\n# 坑\n\n## 1号坑：`omitempty`的行为\n\nC#中最常用的JSON序列化类库`Newtonsoft.Json`中，把一个类的实例序列化成JSON，如果我们不想让某个属性输出到JSON中，可以通过`property annotation`或者`ShouldSerialize method`等方法，告知序列化程序。如下：\n\n```c#\n// 通过ShouldSerialize method指示不要序列化ObsoleteSetting属性\nclass Config\n{\n    public Fizz ObsoleteSetting { get; set; }\n\n    public bool ShouldSerializeObsoleteSetting()\n    {\n        return false;\n    }\n}\n\n// 通过JsonIgnore的annotation指示不需要序列化ObsoleteSetting属性\nclass Config\n{\n    [JsonIgnore]\n    public Fizz ObsoleteSetting { get; set; }\n\n    public Bang ReplacementSetting { get; set; }\n}\n```\n\n关于`Newtonsoft.Json`的Conditional Property Serialization的更多内容参考：\n\n- [Conditional Property Serialization](http://www.newtonsoft.com/json/help/html/ConditionalProperties.htm)\n- [Making a property deserialize but not serialize with json.net](http://stackoverflow.com/questions/11564091/making-a-property-deserialize-but-not-serialize-with-json-net)\n\n开始使用Golang的时候，以为`omitempty`的行为和C#中一样用来控制是否序列化字段，结果使用的时候碰了一头钉子。回头阅读[encoding/json package的官方文档](http://docs.studygolang.com/pkg/encoding/json/#Marshal)，找到对`omitempty`行为的描述：\n\n> Struct values encode as JSON objects. Each exported struct field becomes a member of the object unless\n>\n> - the field's tag is \"-\", or\n> - the field is empty and its tag specifies the \"omitempty\" option.\n>\n> The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero. The object's default key string is the struct field name but can be specified in the struct field's tag value. The \"json\" key in the struct field's tag value is the key name, followed by an optional comma and options. Examples:\n>\n> ```go\n> // Field is ignored by this package.\n> Field int `json:\"-\"`\n>\n> // Field appears in JSON as key \"myName\".\n> Field int `json:\"myName\"`\n>\n> // Field appears in JSON as key \"myName\" and\n> // the field is omitted from the object if its value is empty,\n> // as defined above.\n> Field int `json:\"myName,omitempty\"`\n>\n> // Field appears in JSON as key \"Field\" (the default), but\n> // the field is skipped if empty.\n> // Note the leading comma.\n> Field int `json:\",omitempty\"`\n> ```\n\nGolang中，如果指定一个`field`序列化成JSON的变量名字为`-`，则序列化的时候自动忽略这个`field`。这种用法，才是和上面`JsonIgnore`的用法的作用是一样的。\n\n而`omitempty`的作用是当一个`field`的值是`empty`的时候，序列化JSON时候忽略这个`field`（`Newtonsoft.Json`的类似用法参考[这里](http://stackoverflow.com/questions/6507889/how-to-ignore-a-property-in-class-if-null-using-json-net)和[例子](https://dotnetfiddle.net/VXqRnm)）。这里需要注意的是关于`emtpty`的定义：\n\n> The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero.\n\n通过下面的例子，来加深对`empty values`的了解：\n\n```go\npackage main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"log\"\n    \"os\"\n)\n\ntype S1 struct {\n    I1 int\n    I2 int `json:\",omitempty\"`\n\n    F1 float64\n    F2 float64 `json:\",omitempty\"`\n\n    S1 string\n    S2 string `json:\",omitempty\"`\n\n    B1 bool\n    B2 bool `json:\",omitempty\"`\n\n    Slice1 []int\n    Slice2 []int `json:\",omitempty\"`\n    Slice3 []int `json:\",omitempty\"`\n\n    Map1 map[string]string\n    Map2 map[string]string `json:\",omitempty\"`\n    Map3 map[string]string `json:\",omitempty\"`\n\n    O1 interface{}\n    O2 interface{} `json:\",omitempty\"`\n    O3 interface{} `json:\",omitempty\"`\n    O4 interface{} `json:\",omitempty\"`\n    O5 interface{} `json:\",omitempty\"`\n    O6 interface{} `json:\",omitempty\"`\n    O7 interface{} `json:\",omitempty\"`\n    O8 interface{} `json:\",omitempty\"`\n\n    P1 *int\n    P2 *int               `json:\",omitempty\"`\n    P3 *int               `json:\",omitempty\"`\n    P4 *float64           `json:\",omitempty\"`\n    P5 *string            `json:\",omitempty\"`\n    P6 *bool              `json:\",omitempty\"`\n    P7 *[]int             `json:\",omitempty\"`\n    P8 *map[string]string `json:\",omitempty\"`\n}\n\nfunc main() {\n\n    p3 := 0\n    p4 := float64(0)\n    p5 := \"\"\n    p6 := false\n    p7 := []int{}\n    p8 := map[string]string{}\n\n    s1 := S1{\n        I1: 0,\n        I2: 0,\n\n        F1: 0,\n        F2: 0,\n\n        S1: \"\",\n        S2: \"\",\n\n        B1: false,\n        B2: false,\n\n        Slice1: []int{},\n        Slice2: nil,\n        Slice3: []int{},\n\n        Map1: map[string]string{},\n        Map2: nil,\n        Map3: map[string]string{},\n\n        O1: nil,\n        O2: nil,\n        O3: int(0),\n        O4: float64(0),\n        O5: \"\",\n        O6: false,\n        O7: []int{},\n        O8: map[string]string{},\n\n        P1: nil,\n        P2: nil,\n        P3: &p3,\n        P4: &p4,\n        P5: &p5,\n        P6: &p6,\n        P7: &p7,\n        P8: &p8,\n    }\n\n    b, err := json.Marshal(s1)\n    if err != nil {\n        log.Printf(\"marshal error: %v\", err)\n        return\n    }\n\n    var out bytes.Buffer\n    json.Indent(&out, b, \"\", \"\\t\")\n    out.WriteTo(os.Stdout)\n    //Output:\n    //{\n    //\t\"I1\": 0,\n    //\t\"F1\": 0,\n    //\t\"S1\": \"\",\n    //\t\"B1\": false,\n    //\t\"Slice1\": [],\n    //\t\"Map1\": {},\n    //\t\"O1\": null,\n    //\t\"O3\": 0,\n    //\t\"O4\": 0,\n    //\t\"O5\": \"\",\n    //\t\"O6\": false,\n    //\t\"O7\": [],\n    //\t\"O8\": {},\n    //\t\"P1\": null,\n    //\t\"P2\": 0\n    //}%\n}\n```\n\n*点击[这里](https://play.golang.org/p/6y_m27r8EO)执行上面的程序*\n\n关于`empty value`的定义，这里面隐藏了一些坑。下面通过一个例子来说明。\n\n假设我们有一个社交类App，通过Restful API形式从服务端获取当前登录用户基本信息及粉丝数量。如果服务端对Response中`User`对象的定义如下：\n\n```go\ntype User struct {\n    ID        int `json:\"id\"`                  // 用户id\n    // 其它field\n    FansCount int `json:\"fansCount,omitempty\"` // 粉丝数\n}\n```\n\n如果正在使用App时一个还没有粉丝的用户，访问Restful API的得到Response如下：\n\n```json\n{\n    \"id\": 1000386,\n    ...\n}\n```\n\n这时候你会发现Response的User对象中没有`fansCount`，因为`fansCount`是个`int`类型且值为0，序列化的时候会被忽略。语义上，`User`对象中没有`fansCount`应该理解为**粉丝数量未知**，而不是**没有粉丝**。\n\n如果我们希望做到能够区分**粉丝数未知**和**没有粉丝**两种情况，需要修改`User`的定义：\n\n```go\ntype User struct {\n    ID        int  `json:\"id\"`                  // 用户id\n    // 其它field\n    FansCount *int `json:\"fansCount,omitempty\"` // 粉丝数\n}\n```\n\n将`FansCount`修改为指针类型，如果为`nil`，表示粉丝数未知；如果为整数（包括0），表示粉丝数。\n\n这么修改语义上没有漏洞了，但是代码中要给`FansCount`赋值的时候却要多一句废话。必须先将从数据源查询出粉丝数赋给一个变量，然后再将变量的指针传给`FansCount`。代码读起来实在是啰嗦：\n\n```go\n// FansCount是int类型时候\nuser := dataAccess.GetUserInfo(userId)\nuser.FansCount = dataAccess.GetFansCount(userId)\n\n// FansCount是*int类型的时候\nuser := dataAccess.GetUserInfo(userId)\nfansCount := dataAccess.GetFansCount(userId)\nuser.FansCount = &fansCount\n```\n\n## 2号坑：JSON反序列化成interface{}对Number的处理\n\n[JSON的规范](http://json.org/)中，对于数字类型，并不区分是整型还是浮点型。\n\n![](https://www.json.org/img/value.png)\n\n对于如下JSON文本:\n\n```json\n{\n    \"name\": \"ethancai\",\n    \"fansCount\": 9223372036854775807\n}\n```\n\n如果反序列化的时候指定明确的结构体和变量类型\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype User struct {\n    Name      string\n    FansCount int64\n}\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n    var user User  // 类型为User\n    err := json.Unmarshal([]byte(jsonStream), &user)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n\n    fmt.Printf(\"%+v \\n\", user)\n}\n// Output:\n//  {Name:ethancai FansCount:9223372036854775807}\n```\n\n*点击[这里](https://play.golang.org/p/203egccrea)执行上面的程序*\n\n如果反序列化不指定结构体类型或者变量类型，则JSON中的数字类型，默认被反序列化成`float64`类型：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n    var user interface{}  // 不指定反序列化的类型\n    err := json.Unmarshal([]byte(jsonStream), &user)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n    m := user.(map[string]interface{})\n\n    fansCount := m[\"fansCount\"]\n\n    fmt.Printf(\"%+v \\n\", reflect.TypeOf(fansCount).Name())\n    fmt.Printf(\"%+v \\n\", fansCount.(float64))\n}\n\n// Output:\n// \tfloat64\n//  \t9.223372036854776e+18\n```\n\n*点击[这里](https://play.golang.org/p/l4GzgA4WDA)执行上面的程序*\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype User struct {\n    Name      string\n    FansCount interface{}  // 不指定FansCount变量的类型\n}\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n    var user User\n    err := json.Unmarshal([]byte(jsonStream), &user)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n\n    fmt.Printf(\"%+v \\n\", user)\n}\n\n// Output:\n// \t{Name:ethancai FansCount:9.223372036854776e+18}\n```\n\n*点击[这里](https://play.golang.org/p/SoD6SOGuCM)执行上面的程序*\n\n从上面的程序可以发现，如果`fansCount`精度比较高，反序列化成`float64`类型的数值时存在丢失精度的问题。\n\n如何解决这个问题，先看下面程序：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"reflect\"\n    \"strings\"\n)\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n\n    decoder := json.NewDecoder(strings.NewReader(jsonStream))\n    decoder.UseNumber()    // UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.\n\n    var user interface{}\n    if err := decoder.Decode(&user); err != nil {\n        fmt.Println(\"error:\", err)\n            return\n        }\n\n    m := user.(map[string]interface{})\n    fansCount := m[\"fansCount\"]\n    fmt.Printf(\"%+v \\n\", reflect.TypeOf(fansCount).PkgPath() + \".\" + reflect.TypeOf(fansCount).Name())\n\n     v, err := fansCount.(json.Number).Int64()\n    if err != nil {\n        fmt.Println(\"error:\", err)\n            return\n    }\n    fmt.Printf(\"%+v \\n\", v)\n}\n\n// Output:\n// \tencoding/json.Number\n// \t9223372036854775807\n```\n*点击[这里](https://play.golang.org/p/KYrFshVMFD)执行上面的程序*\n\n上面的程序，使用了`func (*Decoder) UseNumber`方法告诉反序列化JSON的数字类型的时候，不要直接转换成`float64`，而是转换成`json.Number`类型。`json.Number`内部实现机制是什么，我们来看看源码：\n\n```go\n// A Number represents a JSON number literal.\ntype Number string\n\n// String returns the literal text of the number.\nfunc (n Number) String() string { return string(n) }\n\n// Float64 returns the number as a float64.\nfunc (n Number) Float64() (float64, error) {\n    return strconv.ParseFloat(string(n), 64)\n}\n\n// Int64 returns the number as an int64.\nfunc (n Number) Int64() (int64, error) {\n    return strconv.ParseInt(string(n), 10, 64)\n}\n```\n\n`json.Number`本质是字符串，反序列化的时候将JSON的数值先转成`json.Number`，其实是一种延迟处理的手段，待后续逻辑需要时候，再把`json.Number`转成`float64`或者`int64`。\n\n对比其它语言，Golang对JSON反序列化处理真是易用性太差（“蛋疼”）。\n\nJavaScript中所有的数值都是双精度浮点数（参考[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates)），反序列化JSON的时候不用考虑数值类型匹配问题。这里多说两句，JSON的全名JavaScript Object Notation（从名字上就能看出和JavaScript的关系非常紧密），发明人是Douglas Crockford，如果你自称熟悉JavaScript而不知道[Douglas Crockford](http://www.infoq.com/cn/news/2010/02/qconbeijing2010-douglas)是谁，就像是自称是苹果粉丝却不知道乔布斯是谁。\n\nC#语言的第三方JSON处理library [Json.NET](http://www.newtonsoft.com/json)反序列化JSON对数值的处理也比Golang要优雅的多：\n\n```c#\nusing System;\nusing Newtonsoft.Json;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string json = @\"{\n  'Name': 'Ethan',\n  'FansCount': 121211,\n  'Price': 99.99\n}\";\n\n        Product m = JsonConvert.DeserializeObject<Product>(json);\n\n        Console.WriteLine(m.FansCount);\n        Console.WriteLine(m.FansCount.GetType().FullName);\n\n        Console.WriteLine(m.Price);\n        Console.WriteLine(m.Price.GetType().FullName);\n\n    }\n}\n\npublic class Product\n{\n    public string Name\n    {\n        get;\n        set;\n    }\n\n    public object FansCount\n    {\n        get;\n        set;\n    }\n\n    public object Price\n    {\n        get;\n        set;\n    }\n}\n\n// Output:\n//      121211\n//      System.Int64\n//      99.99\n//      System.Double\n```\n\n*点击[这里](https://dotnetfiddle.net/IrlMae)执行上面的程序*\n\n`Json.NET`在反序列化的时候自动识别数值是浮点型还是整型，这一点对开发者非常友好。\n\n## 3号坑：选择什么格式表示日期\n\nJSON的规范中并没有日期类型，不同语言的library对日期序列化的处理也不完全一致：\n\nGo语言：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc main() {\n    type Product struct {\n        Name      string\n        CreatedAt time.Time\n    }\n    pdt := Product{\n        Name:      \"Reds\",\n        CreatedAt: time.Now(),\n    }\n    b, err := json.Marshal(pdt)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n    os.Stdout.Write(b)\n}\n// Output\n//      {\"Name\":\"Reds\",\"CreatedAt\":\"2016-06-27T07:40:54.69292134+08:00\"}\n```\n\nJavaScript语言：\n\n```sh\n➜  ~ node\n> var jo = { name: \"ethan\", createdAt: Date.now() };\nundefined\n> JSON.stringify(jo)\n'{\"name\":\"ethan\",\"createdAt\":1466984665633}'\n```\n\nC#语言：\n\n```c#\nusing System;\nusing Newtonsoft.Json;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Product product = new Product();\n        product.Name = \"Apple\";\n        product.CreatedAt = DateTime.Now;\n\n        string json = JsonConvert.SerializeObject(product,\n                            Newtonsoft.Json.Formatting.Indented,\n                            new JsonSerializerSettings {\n                                NullValueHandling = NullValueHandling.Ignore\n                            });\n        Console.WriteLine(json);\n    }\n}\n\npublic class Product\n{\n    public string Name\n    {\n        get;\n        set;\n    }\n\n    public DateTime CreatedAt\n    {\n        get;\n        set;\n    }\n}\n// Output:\n//      {\n//        \"Name\": \"Apple\",\n//        \"CreatedAt\": \"2016-06-26T23:46:57.3244307+00:00\"\n//      }\n```\n\nGo的`encoding/json` package、C#的Json.NET默认把日期类型序列化成[ISO 8601标准](http://www.w3.org/TR/NOTE-datetime)的格式，JavaScript默认把`Date`序列化从1970年1月1日0点0分0秒的毫秒数。但JavaScript的[`dateObj.toISOString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)能够将日期类型转成ISO格式的字符串，[`Date.parse(dateString)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse)方法能够将ISO格式的日期字符串转成日期。\n\n个人认为ISO格式的日期字符串可读性更好，但序列化和反序列化时的性能应该比整数更低。这一点从Go语言中`time.Time`的定义看出来。\n\n```go\ntype Time struct {\n    // sec gives the number of seconds elapsed since\n    // January 1, year 1 00:00:00 UTC.\n    sec int64\n\n    // nsec specifies a non-negative nanosecond\n    // offset within the second named by Seconds.\n    // It must be in the range [0, 999999999].\n    nsec int32\n\n    // loc specifies the Location that should be used to\n    // determine the minute, hour, month, day, and year\n    // that correspond to this Time.\n    // Only the zero Time has a nil Location.\n    // In that case it is interpreted to mean UTC.\n    loc *Location\n}\n```\n\n具体选择哪种形式在JSON中表示日期，有如下几点需要注意：\n\n- 选择标准格式。曾记得.NET Framework官方序列化JSON的方法中，会把日期转成如`\"\\/Date(1343660352227+0530)\\/\"`的专有格式，这样的专有格式对跨语言的访问特别不友好。\n- 如果你倾向性能，可以使用整数。如果你倾向可读性，可以使用ISO字符串。\n- 如果使用整数表示日期，而你的应用又是需要支持跨时区的，注意一定要是从`1970-1-1 00:00:00 UTC`开始计算的毫秒数，而不是当前时区的`1970-1-1 00:00:00`。\n\n\n# 参考\n\n文章：\n\n- [package encoding/json in Go](http://docs.studygolang.com/pkg/encoding/json/)\n- [http://docs.studygolang.com/src/encoding/json/example_test.go](http://docs.studygolang.com/src/encoding/json/example_test.go)\n- [The Go Blog: JSON and Go](https://blog.golang.org/json-and-go)\n- [Go by example: JSON](https://gobyexample.com/json)\n- [JSON decoding in Go](http://attilaolah.eu/2013/11/29/json-decoding-in-go/)\n- [go and json](https://eager.io/blog/go-and-json/)\n- [Decode JSON Documents In Go](https://www.goinggo.net/2014/01/decode-json-documents-in-go.html)\n- [ffjson: faster JSON serialization for Golang](https://journal.paul.querna.org/articles/2014/03/31/ffjson-faster-json-in-go/)\n- [Serialization in Go](http://www.slideshare.net/albertstrasheim/serialization-in-go)\n\n第三方类库：\n\n- [ffjson](https://github.com/pquerna/ffjson): faster JSON serialization for Go\n- [go-simplejson](https://github.com/bitly/go-simplejson): a Go package to interact with arbitrary JSON\n- [Jason](https://github.com/antonholmquist/jason): Easy-to-use JSON Library for Go\n- [easyjson](https://github.com/mailru/easyjson)\n- [gabs](https://github.com/Jeffail/gabs)\n- [jsonparser](https://github.com/buger/jsonparser)\n\n工具：\n\n- [JSON-to-Go](https://mholt.github.io/json-to-go/): instantly converts JSON into a Go type definition\n","source":"_posts/2016-06-23-bad-parts-about-json-serialization-in-Golang.md","raw":"---\ntitle: Golang中遇到的一些关于JSON处理的坑\ncategories:\n  - 编程开发\ntags:\n  - golang\n  - json\ndate: 2016-06-23 08:09:39\n---\n\n\n# 前言\n\n一个人不会两次掉进同一个坑里，但是如果他（她）忘记了坑的位置，那就不一定了。\n\n这篇文章记录了最近使用Golang处理JSON遇到的一些坑。\n\n# 坑\n\n## 1号坑：`omitempty`的行为\n\nC#中最常用的JSON序列化类库`Newtonsoft.Json`中，把一个类的实例序列化成JSON，如果我们不想让某个属性输出到JSON中，可以通过`property annotation`或者`ShouldSerialize method`等方法，告知序列化程序。如下：\n\n```c#\n// 通过ShouldSerialize method指示不要序列化ObsoleteSetting属性\nclass Config\n{\n    public Fizz ObsoleteSetting { get; set; }\n\n    public bool ShouldSerializeObsoleteSetting()\n    {\n        return false;\n    }\n}\n\n// 通过JsonIgnore的annotation指示不需要序列化ObsoleteSetting属性\nclass Config\n{\n    [JsonIgnore]\n    public Fizz ObsoleteSetting { get; set; }\n\n    public Bang ReplacementSetting { get; set; }\n}\n```\n\n关于`Newtonsoft.Json`的Conditional Property Serialization的更多内容参考：\n\n- [Conditional Property Serialization](http://www.newtonsoft.com/json/help/html/ConditionalProperties.htm)\n- [Making a property deserialize but not serialize with json.net](http://stackoverflow.com/questions/11564091/making-a-property-deserialize-but-not-serialize-with-json-net)\n\n开始使用Golang的时候，以为`omitempty`的行为和C#中一样用来控制是否序列化字段，结果使用的时候碰了一头钉子。回头阅读[encoding/json package的官方文档](http://docs.studygolang.com/pkg/encoding/json/#Marshal)，找到对`omitempty`行为的描述：\n\n> Struct values encode as JSON objects. Each exported struct field becomes a member of the object unless\n>\n> - the field's tag is \"-\", or\n> - the field is empty and its tag specifies the \"omitempty\" option.\n>\n> The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero. The object's default key string is the struct field name but can be specified in the struct field's tag value. The \"json\" key in the struct field's tag value is the key name, followed by an optional comma and options. Examples:\n>\n> ```go\n> // Field is ignored by this package.\n> Field int `json:\"-\"`\n>\n> // Field appears in JSON as key \"myName\".\n> Field int `json:\"myName\"`\n>\n> // Field appears in JSON as key \"myName\" and\n> // the field is omitted from the object if its value is empty,\n> // as defined above.\n> Field int `json:\"myName,omitempty\"`\n>\n> // Field appears in JSON as key \"Field\" (the default), but\n> // the field is skipped if empty.\n> // Note the leading comma.\n> Field int `json:\",omitempty\"`\n> ```\n\nGolang中，如果指定一个`field`序列化成JSON的变量名字为`-`，则序列化的时候自动忽略这个`field`。这种用法，才是和上面`JsonIgnore`的用法的作用是一样的。\n\n而`omitempty`的作用是当一个`field`的值是`empty`的时候，序列化JSON时候忽略这个`field`（`Newtonsoft.Json`的类似用法参考[这里](http://stackoverflow.com/questions/6507889/how-to-ignore-a-property-in-class-if-null-using-json-net)和[例子](https://dotnetfiddle.net/VXqRnm)）。这里需要注意的是关于`emtpty`的定义：\n\n> The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero.\n\n通过下面的例子，来加深对`empty values`的了解：\n\n```go\npackage main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"log\"\n    \"os\"\n)\n\ntype S1 struct {\n    I1 int\n    I2 int `json:\",omitempty\"`\n\n    F1 float64\n    F2 float64 `json:\",omitempty\"`\n\n    S1 string\n    S2 string `json:\",omitempty\"`\n\n    B1 bool\n    B2 bool `json:\",omitempty\"`\n\n    Slice1 []int\n    Slice2 []int `json:\",omitempty\"`\n    Slice3 []int `json:\",omitempty\"`\n\n    Map1 map[string]string\n    Map2 map[string]string `json:\",omitempty\"`\n    Map3 map[string]string `json:\",omitempty\"`\n\n    O1 interface{}\n    O2 interface{} `json:\",omitempty\"`\n    O3 interface{} `json:\",omitempty\"`\n    O4 interface{} `json:\",omitempty\"`\n    O5 interface{} `json:\",omitempty\"`\n    O6 interface{} `json:\",omitempty\"`\n    O7 interface{} `json:\",omitempty\"`\n    O8 interface{} `json:\",omitempty\"`\n\n    P1 *int\n    P2 *int               `json:\",omitempty\"`\n    P3 *int               `json:\",omitempty\"`\n    P4 *float64           `json:\",omitempty\"`\n    P5 *string            `json:\",omitempty\"`\n    P6 *bool              `json:\",omitempty\"`\n    P7 *[]int             `json:\",omitempty\"`\n    P8 *map[string]string `json:\",omitempty\"`\n}\n\nfunc main() {\n\n    p3 := 0\n    p4 := float64(0)\n    p5 := \"\"\n    p6 := false\n    p7 := []int{}\n    p8 := map[string]string{}\n\n    s1 := S1{\n        I1: 0,\n        I2: 0,\n\n        F1: 0,\n        F2: 0,\n\n        S1: \"\",\n        S2: \"\",\n\n        B1: false,\n        B2: false,\n\n        Slice1: []int{},\n        Slice2: nil,\n        Slice3: []int{},\n\n        Map1: map[string]string{},\n        Map2: nil,\n        Map3: map[string]string{},\n\n        O1: nil,\n        O2: nil,\n        O3: int(0),\n        O4: float64(0),\n        O5: \"\",\n        O6: false,\n        O7: []int{},\n        O8: map[string]string{},\n\n        P1: nil,\n        P2: nil,\n        P3: &p3,\n        P4: &p4,\n        P5: &p5,\n        P6: &p6,\n        P7: &p7,\n        P8: &p8,\n    }\n\n    b, err := json.Marshal(s1)\n    if err != nil {\n        log.Printf(\"marshal error: %v\", err)\n        return\n    }\n\n    var out bytes.Buffer\n    json.Indent(&out, b, \"\", \"\\t\")\n    out.WriteTo(os.Stdout)\n    //Output:\n    //{\n    //\t\"I1\": 0,\n    //\t\"F1\": 0,\n    //\t\"S1\": \"\",\n    //\t\"B1\": false,\n    //\t\"Slice1\": [],\n    //\t\"Map1\": {},\n    //\t\"O1\": null,\n    //\t\"O3\": 0,\n    //\t\"O4\": 0,\n    //\t\"O5\": \"\",\n    //\t\"O6\": false,\n    //\t\"O7\": [],\n    //\t\"O8\": {},\n    //\t\"P1\": null,\n    //\t\"P2\": 0\n    //}%\n}\n```\n\n*点击[这里](https://play.golang.org/p/6y_m27r8EO)执行上面的程序*\n\n关于`empty value`的定义，这里面隐藏了一些坑。下面通过一个例子来说明。\n\n假设我们有一个社交类App，通过Restful API形式从服务端获取当前登录用户基本信息及粉丝数量。如果服务端对Response中`User`对象的定义如下：\n\n```go\ntype User struct {\n    ID        int `json:\"id\"`                  // 用户id\n    // 其它field\n    FansCount int `json:\"fansCount,omitempty\"` // 粉丝数\n}\n```\n\n如果正在使用App时一个还没有粉丝的用户，访问Restful API的得到Response如下：\n\n```json\n{\n    \"id\": 1000386,\n    ...\n}\n```\n\n这时候你会发现Response的User对象中没有`fansCount`，因为`fansCount`是个`int`类型且值为0，序列化的时候会被忽略。语义上，`User`对象中没有`fansCount`应该理解为**粉丝数量未知**，而不是**没有粉丝**。\n\n如果我们希望做到能够区分**粉丝数未知**和**没有粉丝**两种情况，需要修改`User`的定义：\n\n```go\ntype User struct {\n    ID        int  `json:\"id\"`                  // 用户id\n    // 其它field\n    FansCount *int `json:\"fansCount,omitempty\"` // 粉丝数\n}\n```\n\n将`FansCount`修改为指针类型，如果为`nil`，表示粉丝数未知；如果为整数（包括0），表示粉丝数。\n\n这么修改语义上没有漏洞了，但是代码中要给`FansCount`赋值的时候却要多一句废话。必须先将从数据源查询出粉丝数赋给一个变量，然后再将变量的指针传给`FansCount`。代码读起来实在是啰嗦：\n\n```go\n// FansCount是int类型时候\nuser := dataAccess.GetUserInfo(userId)\nuser.FansCount = dataAccess.GetFansCount(userId)\n\n// FansCount是*int类型的时候\nuser := dataAccess.GetUserInfo(userId)\nfansCount := dataAccess.GetFansCount(userId)\nuser.FansCount = &fansCount\n```\n\n## 2号坑：JSON反序列化成interface{}对Number的处理\n\n[JSON的规范](http://json.org/)中，对于数字类型，并不区分是整型还是浮点型。\n\n![](https://www.json.org/img/value.png)\n\n对于如下JSON文本:\n\n```json\n{\n    \"name\": \"ethancai\",\n    \"fansCount\": 9223372036854775807\n}\n```\n\n如果反序列化的时候指定明确的结构体和变量类型\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype User struct {\n    Name      string\n    FansCount int64\n}\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n    var user User  // 类型为User\n    err := json.Unmarshal([]byte(jsonStream), &user)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n\n    fmt.Printf(\"%+v \\n\", user)\n}\n// Output:\n//  {Name:ethancai FansCount:9223372036854775807}\n```\n\n*点击[这里](https://play.golang.org/p/203egccrea)执行上面的程序*\n\n如果反序列化不指定结构体类型或者变量类型，则JSON中的数字类型，默认被反序列化成`float64`类型：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n    var user interface{}  // 不指定反序列化的类型\n    err := json.Unmarshal([]byte(jsonStream), &user)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n    m := user.(map[string]interface{})\n\n    fansCount := m[\"fansCount\"]\n\n    fmt.Printf(\"%+v \\n\", reflect.TypeOf(fansCount).Name())\n    fmt.Printf(\"%+v \\n\", fansCount.(float64))\n}\n\n// Output:\n// \tfloat64\n//  \t9.223372036854776e+18\n```\n\n*点击[这里](https://play.golang.org/p/l4GzgA4WDA)执行上面的程序*\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype User struct {\n    Name      string\n    FansCount interface{}  // 不指定FansCount变量的类型\n}\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n    var user User\n    err := json.Unmarshal([]byte(jsonStream), &user)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n\n    fmt.Printf(\"%+v \\n\", user)\n}\n\n// Output:\n// \t{Name:ethancai FansCount:9.223372036854776e+18}\n```\n\n*点击[这里](https://play.golang.org/p/SoD6SOGuCM)执行上面的程序*\n\n从上面的程序可以发现，如果`fansCount`精度比较高，反序列化成`float64`类型的数值时存在丢失精度的问题。\n\n如何解决这个问题，先看下面程序：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"reflect\"\n    \"strings\"\n)\n\nfunc main() {\n    const jsonStream = `\n        {\"name\":\"ethancai\", \"fansCount\": 9223372036854775807}\n    `\n\n    decoder := json.NewDecoder(strings.NewReader(jsonStream))\n    decoder.UseNumber()    // UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.\n\n    var user interface{}\n    if err := decoder.Decode(&user); err != nil {\n        fmt.Println(\"error:\", err)\n            return\n        }\n\n    m := user.(map[string]interface{})\n    fansCount := m[\"fansCount\"]\n    fmt.Printf(\"%+v \\n\", reflect.TypeOf(fansCount).PkgPath() + \".\" + reflect.TypeOf(fansCount).Name())\n\n     v, err := fansCount.(json.Number).Int64()\n    if err != nil {\n        fmt.Println(\"error:\", err)\n            return\n    }\n    fmt.Printf(\"%+v \\n\", v)\n}\n\n// Output:\n// \tencoding/json.Number\n// \t9223372036854775807\n```\n*点击[这里](https://play.golang.org/p/KYrFshVMFD)执行上面的程序*\n\n上面的程序，使用了`func (*Decoder) UseNumber`方法告诉反序列化JSON的数字类型的时候，不要直接转换成`float64`，而是转换成`json.Number`类型。`json.Number`内部实现机制是什么，我们来看看源码：\n\n```go\n// A Number represents a JSON number literal.\ntype Number string\n\n// String returns the literal text of the number.\nfunc (n Number) String() string { return string(n) }\n\n// Float64 returns the number as a float64.\nfunc (n Number) Float64() (float64, error) {\n    return strconv.ParseFloat(string(n), 64)\n}\n\n// Int64 returns the number as an int64.\nfunc (n Number) Int64() (int64, error) {\n    return strconv.ParseInt(string(n), 10, 64)\n}\n```\n\n`json.Number`本质是字符串，反序列化的时候将JSON的数值先转成`json.Number`，其实是一种延迟处理的手段，待后续逻辑需要时候，再把`json.Number`转成`float64`或者`int64`。\n\n对比其它语言，Golang对JSON反序列化处理真是易用性太差（“蛋疼”）。\n\nJavaScript中所有的数值都是双精度浮点数（参考[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates)），反序列化JSON的时候不用考虑数值类型匹配问题。这里多说两句，JSON的全名JavaScript Object Notation（从名字上就能看出和JavaScript的关系非常紧密），发明人是Douglas Crockford，如果你自称熟悉JavaScript而不知道[Douglas Crockford](http://www.infoq.com/cn/news/2010/02/qconbeijing2010-douglas)是谁，就像是自称是苹果粉丝却不知道乔布斯是谁。\n\nC#语言的第三方JSON处理library [Json.NET](http://www.newtonsoft.com/json)反序列化JSON对数值的处理也比Golang要优雅的多：\n\n```c#\nusing System;\nusing Newtonsoft.Json;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string json = @\"{\n  'Name': 'Ethan',\n  'FansCount': 121211,\n  'Price': 99.99\n}\";\n\n        Product m = JsonConvert.DeserializeObject<Product>(json);\n\n        Console.WriteLine(m.FansCount);\n        Console.WriteLine(m.FansCount.GetType().FullName);\n\n        Console.WriteLine(m.Price);\n        Console.WriteLine(m.Price.GetType().FullName);\n\n    }\n}\n\npublic class Product\n{\n    public string Name\n    {\n        get;\n        set;\n    }\n\n    public object FansCount\n    {\n        get;\n        set;\n    }\n\n    public object Price\n    {\n        get;\n        set;\n    }\n}\n\n// Output:\n//      121211\n//      System.Int64\n//      99.99\n//      System.Double\n```\n\n*点击[这里](https://dotnetfiddle.net/IrlMae)执行上面的程序*\n\n`Json.NET`在反序列化的时候自动识别数值是浮点型还是整型，这一点对开发者非常友好。\n\n## 3号坑：选择什么格式表示日期\n\nJSON的规范中并没有日期类型，不同语言的library对日期序列化的处理也不完全一致：\n\nGo语言：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc main() {\n    type Product struct {\n        Name      string\n        CreatedAt time.Time\n    }\n    pdt := Product{\n        Name:      \"Reds\",\n        CreatedAt: time.Now(),\n    }\n    b, err := json.Marshal(pdt)\n    if err != nil {\n        fmt.Println(\"error:\", err)\n    }\n    os.Stdout.Write(b)\n}\n// Output\n//      {\"Name\":\"Reds\",\"CreatedAt\":\"2016-06-27T07:40:54.69292134+08:00\"}\n```\n\nJavaScript语言：\n\n```sh\n➜  ~ node\n> var jo = { name: \"ethan\", createdAt: Date.now() };\nundefined\n> JSON.stringify(jo)\n'{\"name\":\"ethan\",\"createdAt\":1466984665633}'\n```\n\nC#语言：\n\n```c#\nusing System;\nusing Newtonsoft.Json;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Product product = new Product();\n        product.Name = \"Apple\";\n        product.CreatedAt = DateTime.Now;\n\n        string json = JsonConvert.SerializeObject(product,\n                            Newtonsoft.Json.Formatting.Indented,\n                            new JsonSerializerSettings {\n                                NullValueHandling = NullValueHandling.Ignore\n                            });\n        Console.WriteLine(json);\n    }\n}\n\npublic class Product\n{\n    public string Name\n    {\n        get;\n        set;\n    }\n\n    public DateTime CreatedAt\n    {\n        get;\n        set;\n    }\n}\n// Output:\n//      {\n//        \"Name\": \"Apple\",\n//        \"CreatedAt\": \"2016-06-26T23:46:57.3244307+00:00\"\n//      }\n```\n\nGo的`encoding/json` package、C#的Json.NET默认把日期类型序列化成[ISO 8601标准](http://www.w3.org/TR/NOTE-datetime)的格式，JavaScript默认把`Date`序列化从1970年1月1日0点0分0秒的毫秒数。但JavaScript的[`dateObj.toISOString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)能够将日期类型转成ISO格式的字符串，[`Date.parse(dateString)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse)方法能够将ISO格式的日期字符串转成日期。\n\n个人认为ISO格式的日期字符串可读性更好，但序列化和反序列化时的性能应该比整数更低。这一点从Go语言中`time.Time`的定义看出来。\n\n```go\ntype Time struct {\n    // sec gives the number of seconds elapsed since\n    // January 1, year 1 00:00:00 UTC.\n    sec int64\n\n    // nsec specifies a non-negative nanosecond\n    // offset within the second named by Seconds.\n    // It must be in the range [0, 999999999].\n    nsec int32\n\n    // loc specifies the Location that should be used to\n    // determine the minute, hour, month, day, and year\n    // that correspond to this Time.\n    // Only the zero Time has a nil Location.\n    // In that case it is interpreted to mean UTC.\n    loc *Location\n}\n```\n\n具体选择哪种形式在JSON中表示日期，有如下几点需要注意：\n\n- 选择标准格式。曾记得.NET Framework官方序列化JSON的方法中，会把日期转成如`\"\\/Date(1343660352227+0530)\\/\"`的专有格式，这样的专有格式对跨语言的访问特别不友好。\n- 如果你倾向性能，可以使用整数。如果你倾向可读性，可以使用ISO字符串。\n- 如果使用整数表示日期，而你的应用又是需要支持跨时区的，注意一定要是从`1970-1-1 00:00:00 UTC`开始计算的毫秒数，而不是当前时区的`1970-1-1 00:00:00`。\n\n\n# 参考\n\n文章：\n\n- [package encoding/json in Go](http://docs.studygolang.com/pkg/encoding/json/)\n- [http://docs.studygolang.com/src/encoding/json/example_test.go](http://docs.studygolang.com/src/encoding/json/example_test.go)\n- [The Go Blog: JSON and Go](https://blog.golang.org/json-and-go)\n- [Go by example: JSON](https://gobyexample.com/json)\n- [JSON decoding in Go](http://attilaolah.eu/2013/11/29/json-decoding-in-go/)\n- [go and json](https://eager.io/blog/go-and-json/)\n- [Decode JSON Documents In Go](https://www.goinggo.net/2014/01/decode-json-documents-in-go.html)\n- [ffjson: faster JSON serialization for Golang](https://journal.paul.querna.org/articles/2014/03/31/ffjson-faster-json-in-go/)\n- [Serialization in Go](http://www.slideshare.net/albertstrasheim/serialization-in-go)\n\n第三方类库：\n\n- [ffjson](https://github.com/pquerna/ffjson): faster JSON serialization for Go\n- [go-simplejson](https://github.com/bitly/go-simplejson): a Go package to interact with arbitrary JSON\n- [Jason](https://github.com/antonholmquist/jason): Easy-to-use JSON Library for Go\n- [easyjson](https://github.com/mailru/easyjson)\n- [gabs](https://github.com/Jeffail/gabs)\n- [jsonparser](https://github.com/buger/jsonparser)\n\n工具：\n\n- [JSON-to-Go](https://mholt.github.io/json-to-go/): instantly converts JSON into a Go type definition\n","slug":"bad-parts-about-json-serialization-in-Golang","published":1,"updated":"2025-04-27T17:04:49.541Z","comments":1,"layout":"post","photos":[],"_id":"cm9zwlzc40003fdjh7bagfwwo","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>一个人不会两次掉进同一个坑里，但是如果他（她）忘记了坑的位置，那就不一定了。</p>\n<p>这篇文章记录了最近使用Golang处理JSON遇到的一些坑。</p>\n<h1 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h1><h2 id=\"1号坑：omitempty的行为\"><a href=\"#1号坑：omitempty的行为\" class=\"headerlink\" title=\"1号坑：omitempty的行为\"></a>1号坑：<code>omitempty</code>的行为</h2><p>C#中最常用的JSON序列化类库<code>Newtonsoft.Json</code>中，把一个类的实例序列化成JSON，如果我们不想让某个属性输出到JSON中，可以通过<code>property annotation</code>或者<code>ShouldSerialize method</code>等方法，告知序列化程序。如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过ShouldSerialize method指示不要序列化ObsoleteSetting属性</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Fizz ObsoleteSetting &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">ShouldSerializeObsoleteSetting</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过JsonIgnore的annotation指示不需要序列化ObsoleteSetting属性</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">JsonIgnore</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Fizz ObsoleteSetting &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Bang ReplacementSetting &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于<code>Newtonsoft.Json</code>的Conditional Property Serialization的更多内容参考：</p>\n<ul>\n<li><a href=\"http://www.newtonsoft.com/json/help/html/ConditionalProperties.htm\">Conditional Property Serialization</a></li>\n<li><a href=\"http://stackoverflow.com/questions/11564091/making-a-property-deserialize-but-not-serialize-with-json-net\">Making a property deserialize but not serialize with json.net</a></li>\n</ul>\n<p>开始使用Golang的时候，以为<code>omitempty</code>的行为和C#中一样用来控制是否序列化字段，结果使用的时候碰了一头钉子。回头阅读<a href=\"http://docs.studygolang.com/pkg/encoding/json/#Marshal\">encoding&#x2F;json package的官方文档</a>，找到对<code>omitempty</code>行为的描述：</p>\n<blockquote>\n<p>Struct values encode as JSON objects. Each exported struct field becomes a member of the object unless</p>\n<ul>\n<li>the field’s tag is “-“, or</li>\n<li>the field is empty and its tag specifies the “omitempty” option.</li>\n</ul>\n<p>The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero. The object’s default key string is the struct field name but can be specified in the struct field’s tag value. The “json” key in the struct field’s tag value is the key name, followed by an optional comma and options. Examples:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Field is ignored by this package.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;-&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Field appears in JSON as key &quot;myName&quot;.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;myName&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Field appears in JSON as key &quot;myName&quot; and</span></span><br><span class=\"line\"><span class=\"comment\">// the field is omitted from the object if its value is empty,</span></span><br><span class=\"line\"><span class=\"comment\">// as defined above.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;myName,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Field appears in JSON as key &quot;Field&quot; (the default), but</span></span><br><span class=\"line\"><span class=\"comment\">// the field is skipped if empty.</span></span><br><span class=\"line\"><span class=\"comment\">// Note the leading comma.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br></pre></td></tr></table></figure></blockquote>\n<p>Golang中，如果指定一个<code>field</code>序列化成JSON的变量名字为<code>-</code>，则序列化的时候自动忽略这个<code>field</code>。这种用法，才是和上面<code>JsonIgnore</code>的用法的作用是一样的。</p>\n<p>而<code>omitempty</code>的作用是当一个<code>field</code>的值是<code>empty</code>的时候，序列化JSON时候忽略这个<code>field</code>（<code>Newtonsoft.Json</code>的类似用法参考<a href=\"http://stackoverflow.com/questions/6507889/how-to-ignore-a-property-in-class-if-null-using-json-net\">这里</a>和<a href=\"https://dotnetfiddle.net/VXqRnm\">例子</a>）。这里需要注意的是关于<code>emtpty</code>的定义：</p>\n<blockquote>\n<p>The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero.</p>\n</blockquote>\n<p>通过下面的例子，来加深对<code>empty values</code>的了解：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    I1 <span class=\"type\">int</span></span><br><span class=\"line\">    I2 <span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    F1 <span class=\"type\">float64</span></span><br><span class=\"line\">    F2 <span class=\"type\">float64</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    S1 <span class=\"type\">string</span></span><br><span class=\"line\">    S2 <span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    B1 <span class=\"type\">bool</span></span><br><span class=\"line\">    B2 <span class=\"type\">bool</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Slice1 []<span class=\"type\">int</span></span><br><span class=\"line\">    Slice2 []<span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    Slice3 []<span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map1 <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span></span><br><span class=\"line\">    Map2 <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    Map3 <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    O1 <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    O2 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O3 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O4 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O5 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O6 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O7 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O8 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    P1 *<span class=\"type\">int</span></span><br><span class=\"line\">    P2 *<span class=\"type\">int</span>               <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P3 *<span class=\"type\">int</span>               <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P4 *<span class=\"type\">float64</span>           <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P5 *<span class=\"type\">string</span>            <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P6 *<span class=\"type\">bool</span>              <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P7 *[]<span class=\"type\">int</span>             <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P8 *<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    p3 := <span class=\"number\">0</span></span><br><span class=\"line\">    p4 := <span class=\"type\">float64</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    p5 := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    p6 := <span class=\"literal\">false</span></span><br><span class=\"line\">    p7 := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    p8 := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s1 := S1&#123;</span><br><span class=\"line\">        I1: <span class=\"number\">0</span>,</span><br><span class=\"line\">        I2: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        F1: <span class=\"number\">0</span>,</span><br><span class=\"line\">        F2: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        S1: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">        S2: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        B1: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        B2: <span class=\"literal\">false</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        Slice1: []<span class=\"type\">int</span>&#123;&#125;,</span><br><span class=\"line\">        Slice2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        Slice3: []<span class=\"type\">int</span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        Map1: <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;,</span><br><span class=\"line\">        Map2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        Map3: <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        O1: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        O2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        O3: <span class=\"type\">int</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        O4: <span class=\"type\">float64</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        O5: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">        O6: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        O7: []<span class=\"type\">int</span>&#123;&#125;,</span><br><span class=\"line\">        O8: <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        P1: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        P2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        P3: &amp;p3,</span><br><span class=\"line\">        P4: &amp;p4,</span><br><span class=\"line\">        P5: &amp;p5,</span><br><span class=\"line\">        P6: &amp;p6,</span><br><span class=\"line\">        P7: &amp;p7,</span><br><span class=\"line\">        P8: &amp;p8,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    b, err := json.Marshal(s1)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Printf(<span class=\"string\">&quot;marshal error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> out bytes.Buffer</span><br><span class=\"line\">    json.Indent(&amp;out, b, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">    out.WriteTo(os.Stdout)</span><br><span class=\"line\">    <span class=\"comment\">//Output:</span></span><br><span class=\"line\">    <span class=\"comment\">//&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;I1&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;F1&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;S1&quot;: &quot;&quot;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;B1&quot;: false,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;Slice1&quot;: [],</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;Map1&quot;: &#123;&#125;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O1&quot;: null,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O3&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O4&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O5&quot;: &quot;&quot;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O6&quot;: false,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O7&quot;: [],</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O8&quot;: &#123;&#125;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;P1&quot;: null,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;P2&quot;: 0</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;%</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/6y_m27r8EO\">这里</a>执行上面的程序</em></p>\n<p>关于<code>empty value</code>的定义，这里面隐藏了一些坑。下面通过一个例子来说明。</p>\n<p>假设我们有一个社交类App，通过Restful API形式从服务端获取当前登录用户基本信息及粉丝数量。如果服务端对Response中<code>User</code>对象的定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        <span class=\"type\">int</span> <span class=\"string\">`json:&quot;id&quot;`</span>                  <span class=\"comment\">// 用户id</span></span><br><span class=\"line\">    <span class=\"comment\">// 其它field</span></span><br><span class=\"line\">    FansCount <span class=\"type\">int</span> <span class=\"string\">`json:&quot;fansCount,omitempty&quot;`</span> <span class=\"comment\">// 粉丝数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果正在使用App时一个还没有粉丝的用户，访问Restful API的得到Response如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1000386</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候你会发现Response的User对象中没有<code>fansCount</code>，因为<code>fansCount</code>是个<code>int</code>类型且值为0，序列化的时候会被忽略。语义上，<code>User</code>对象中没有<code>fansCount</code>应该理解为<strong>粉丝数量未知</strong>，而不是<strong>没有粉丝</strong>。</p>\n<p>如果我们希望做到能够区分<strong>粉丝数未知</strong>和<strong>没有粉丝</strong>两种情况，需要修改<code>User</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        <span class=\"type\">int</span>  <span class=\"string\">`json:&quot;id&quot;`</span>                  <span class=\"comment\">// 用户id</span></span><br><span class=\"line\">    <span class=\"comment\">// 其它field</span></span><br><span class=\"line\">    FansCount *<span class=\"type\">int</span> <span class=\"string\">`json:&quot;fansCount,omitempty&quot;`</span> <span class=\"comment\">// 粉丝数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将<code>FansCount</code>修改为指针类型，如果为<code>nil</code>，表示粉丝数未知；如果为整数（包括0），表示粉丝数。</p>\n<p>这么修改语义上没有漏洞了，但是代码中要给<code>FansCount</code>赋值的时候却要多一句废话。必须先将从数据源查询出粉丝数赋给一个变量，然后再将变量的指针传给<code>FansCount</code>。代码读起来实在是啰嗦：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FansCount是int类型时候</span></span><br><span class=\"line\">user := dataAccess.GetUserInfo(userId)</span><br><span class=\"line\">user.FansCount = dataAccess.GetFansCount(userId)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FansCount是*int类型的时候</span></span><br><span class=\"line\">user := dataAccess.GetUserInfo(userId)</span><br><span class=\"line\">fansCount := dataAccess.GetFansCount(userId)</span><br><span class=\"line\">user.FansCount = &amp;fansCount</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2号坑：JSON反序列化成interface-对Number的处理\"><a href=\"#2号坑：JSON反序列化成interface-对Number的处理\" class=\"headerlink\" title=\"2号坑：JSON反序列化成interface{}对Number的处理\"></a>2号坑：JSON反序列化成interface{}对Number的处理</h2><p><a href=\"http://json.org/\">JSON的规范</a>中，对于数字类型，并不区分是整型还是浮点型。</p>\n<p><img src=\"https://www.json.org/img/value.png\"></p>\n<p>对于如下JSON文本:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ethancai&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;fansCount&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">9223372036854775807</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果反序列化的时候指定明确的结构体和变量类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name      <span class=\"type\">string</span></span><br><span class=\"line\">    FansCount <span class=\"type\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user User  <span class=\"comment\">// 类型为User</span></span><br><span class=\"line\">    err := json.Unmarshal([]<span class=\"type\">byte</span>(jsonStream), &amp;user)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, user)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">//  &#123;Name:ethancai FansCount:9223372036854775807&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/203egccrea\">这里</a>执行上面的程序</em></p>\n<p>如果反序列化不指定结构体类型或者变量类型，则JSON中的数字类型，默认被反序列化成<code>float64</code>类型：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// 不指定反序列化的类型</span></span><br><span class=\"line\">    err := json.Unmarshal([]<span class=\"type\">byte</span>(jsonStream), &amp;user)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m := user.(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    fansCount := m[<span class=\"string\">&quot;fansCount&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, reflect.TypeOf(fansCount).Name())</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, fansCount.(<span class=\"type\">float64</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// \tfloat64</span></span><br><span class=\"line\"><span class=\"comment\">//  \t9.223372036854776e+18</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/l4GzgA4WDA\">这里</a>执行上面的程序</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name      <span class=\"type\">string</span></span><br><span class=\"line\">    FansCount <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// 不指定FansCount变量的类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user User</span><br><span class=\"line\">    err := json.Unmarshal([]<span class=\"type\">byte</span>(jsonStream), &amp;user)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, user)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#123;Name:ethancai FansCount:9.223372036854776e+18&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/SoD6SOGuCM\">这里</a>执行上面的程序</em></p>\n<p>从上面的程序可以发现，如果<code>fansCount</code>精度比较高，反序列化成<code>float64</code>类型的数值时存在丢失精度的问题。</p>\n<p>如何解决这个问题，先看下面程序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\"></span><br><span class=\"line\">    decoder := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class=\"line\">    decoder.UseNumber()    <span class=\"comment\">// UseNumber causes the Decoder to unmarshal a number into an interface&#123;&#125; as a Number instead of as a float64.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := decoder.Decode(&amp;user); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m := user.(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\">    fansCount := m[<span class=\"string\">&quot;fansCount&quot;</span>]</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, reflect.TypeOf(fansCount).PkgPath() + <span class=\"string\">&quot;.&quot;</span> + reflect.TypeOf(fansCount).Name())</span><br><span class=\"line\"></span><br><span class=\"line\">     v, err := fansCount.(json.Number).Int64()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// \tencoding/json.Number</span></span><br><span class=\"line\"><span class=\"comment\">// \t9223372036854775807</span></span><br></pre></td></tr></table></figure>\n<p><em>点击<a href=\"https://play.golang.org/p/KYrFshVMFD\">这里</a>执行上面的程序</em></p>\n<p>上面的程序，使用了<code>func (*Decoder) UseNumber</code>方法告诉反序列化JSON的数字类型的时候，不要直接转换成<code>float64</code>，而是转换成<code>json.Number</code>类型。<code>json.Number</code>内部实现机制是什么，我们来看看源码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Number represents a JSON number literal.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Number <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String returns the literal text of the number.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n Number)</span></span> String() <span class=\"type\">string</span> &#123; <span class=\"keyword\">return</span> <span class=\"type\">string</span>(n) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Float64 returns the number as a float64.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n Number)</span></span> Float64() (<span class=\"type\">float64</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strconv.ParseFloat(<span class=\"type\">string</span>(n), <span class=\"number\">64</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Int64 returns the number as an int64.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n Number)</span></span> Int64() (<span class=\"type\">int64</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strconv.ParseInt(<span class=\"type\">string</span>(n), <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>json.Number</code>本质是字符串，反序列化的时候将JSON的数值先转成<code>json.Number</code>，其实是一种延迟处理的手段，待后续逻辑需要时候，再把<code>json.Number</code>转成<code>float64</code>或者<code>int64</code>。</p>\n<p>对比其它语言，Golang对JSON反序列化处理真是易用性太差（“蛋疼”）。</p>\n<p>JavaScript中所有的数值都是双精度浮点数（参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates\">这里</a>），反序列化JSON的时候不用考虑数值类型匹配问题。这里多说两句，JSON的全名JavaScript Object Notation（从名字上就能看出和JavaScript的关系非常紧密），发明人是Douglas Crockford，如果你自称熟悉JavaScript而不知道<a href=\"http://www.infoq.com/cn/news/2010/02/qconbeijing2010-douglas\">Douglas Crockford</a>是谁，就像是自称是苹果粉丝却不知道乔布斯是谁。</p>\n<p>C#语言的第三方JSON处理library <a href=\"http://www.newtonsoft.com/json\">Json.NET</a>反序列化JSON对数值的处理也比Golang要优雅的多：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Newtonsoft.Json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> json = <span class=\"string\">@&quot;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;Name&#x27;: &#x27;Ethan&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;FansCount&#x27;: 121211,</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;Price&#x27;: 99.99</span></span><br><span class=\"line\"><span class=\"string\">&#125;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Product m = JsonConvert.DeserializeObject&lt;Product&gt;(json);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(m.FansCount);</span><br><span class=\"line\">        Console.WriteLine(m.FansCount.GetType().FullName);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(m.Price);</span><br><span class=\"line\">        Console.WriteLine(m.Price.GetType().FullName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Product</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> Name</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">object</span> FansCount</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">object</span> Price</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">//      121211</span></span><br><span class=\"line\"><span class=\"comment\">//      System.Int64</span></span><br><span class=\"line\"><span class=\"comment\">//      99.99</span></span><br><span class=\"line\"><span class=\"comment\">//      System.Double</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://dotnetfiddle.net/IrlMae\">这里</a>执行上面的程序</em></p>\n<p><code>Json.NET</code>在反序列化的时候自动识别数值是浮点型还是整型，这一点对开发者非常友好。</p>\n<h2 id=\"3号坑：选择什么格式表示日期\"><a href=\"#3号坑：选择什么格式表示日期\" class=\"headerlink\" title=\"3号坑：选择什么格式表示日期\"></a>3号坑：选择什么格式表示日期</h2><p>JSON的规范中并没有日期类型，不同语言的library对日期序列化的处理也不完全一致：</p>\n<p>Go语言：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> Product <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        Name      <span class=\"type\">string</span></span><br><span class=\"line\">        CreatedAt time.Time</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pdt := Product&#123;</span><br><span class=\"line\">        Name:      <span class=\"string\">&quot;Reds&quot;</span>,</span><br><span class=\"line\">        CreatedAt: time.Now(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b, err := json.Marshal(pdt)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    os.Stdout.Write(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output</span></span><br><span class=\"line\"><span class=\"comment\">//      &#123;&quot;Name&quot;:&quot;Reds&quot;,&quot;CreatedAt&quot;:&quot;2016-06-27T07:40:54.69292134+08:00&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>JavaScript语言：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ node</span><br><span class=\"line\">&gt; var jo = &#123; name: <span class=\"string\">&quot;ethan&quot;</span>, createdAt: Date.now() &#125;;</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; JSON.stringify(jo)</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;ethan&quot;,&quot;createdAt&quot;:1466984665633&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>C#语言：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Newtonsoft.Json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Product product = <span class=\"keyword\">new</span> Product();</span><br><span class=\"line\">        product.Name = <span class=\"string\">&quot;Apple&quot;</span>;</span><br><span class=\"line\">        product.CreatedAt = DateTime.Now;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">string</span> json = JsonConvert.SerializeObject(product,</span><br><span class=\"line\">                            Newtonsoft.Json.Formatting.Indented,</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> JsonSerializerSettings &#123;</span><br><span class=\"line\">                                NullValueHandling = NullValueHandling.Ignore</span><br><span class=\"line\">                            &#125;);</span><br><span class=\"line\">        Console.WriteLine(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Product</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> Name</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DateTime CreatedAt</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">//      &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        &quot;Name&quot;: &quot;Apple&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//        &quot;CreatedAt&quot;: &quot;2016-06-26T23:46:57.3244307+00:00&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//      &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>Go的<code>encoding/json</code> package、C#的Json.NET默认把日期类型序列化成<a href=\"http://www.w3.org/TR/NOTE-datetime\">ISO 8601标准</a>的格式，JavaScript默认把<code>Date</code>序列化从1970年1月1日0点0分0秒的毫秒数。但JavaScript的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\"><code>dateObj.toISOString()</code></a>能够将日期类型转成ISO格式的字符串，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse\"><code>Date.parse(dateString)</code></a>方法能够将ISO格式的日期字符串转成日期。</p>\n<p>个人认为ISO格式的日期字符串可读性更好，但序列化和反序列化时的性能应该比整数更低。这一点从Go语言中<code>time.Time</code>的定义看出来。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Time <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// sec gives the number of seconds elapsed since</span></span><br><span class=\"line\">    <span class=\"comment\">// January 1, year 1 00:00:00 UTC.</span></span><br><span class=\"line\">    sec <span class=\"type\">int64</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nsec specifies a non-negative nanosecond</span></span><br><span class=\"line\">    <span class=\"comment\">// offset within the second named by Seconds.</span></span><br><span class=\"line\">    <span class=\"comment\">// It must be in the range [0, 999999999].</span></span><br><span class=\"line\">    nsec <span class=\"type\">int32</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// loc specifies the Location that should be used to</span></span><br><span class=\"line\">    <span class=\"comment\">// determine the minute, hour, month, day, and year</span></span><br><span class=\"line\">    <span class=\"comment\">// that correspond to this Time.</span></span><br><span class=\"line\">    <span class=\"comment\">// Only the zero Time has a nil Location.</span></span><br><span class=\"line\">    <span class=\"comment\">// In that case it is interpreted to mean UTC.</span></span><br><span class=\"line\">    loc *Location</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体选择哪种形式在JSON中表示日期，有如下几点需要注意：</p>\n<ul>\n<li>选择标准格式。曾记得.NET Framework官方序列化JSON的方法中，会把日期转成如<code>&quot;\\/Date(1343660352227+0530)\\/&quot;</code>的专有格式，这样的专有格式对跨语言的访问特别不友好。</li>\n<li>如果你倾向性能，可以使用整数。如果你倾向可读性，可以使用ISO字符串。</li>\n<li>如果使用整数表示日期，而你的应用又是需要支持跨时区的，注意一定要是从<code>1970-1-1 00:00:00 UTC</code>开始计算的毫秒数，而不是当前时区的<code>1970-1-1 00:00:00</code>。</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>文章：</p>\n<ul>\n<li><a href=\"http://docs.studygolang.com/pkg/encoding/json/\">package encoding&#x2F;json in Go</a></li>\n<li><a href=\"http://docs.studygolang.com/src/encoding/json/example_test.go\">http://docs.studygolang.com/src/encoding/json/example_test.go</a></li>\n<li><a href=\"https://blog.golang.org/json-and-go\">The Go Blog: JSON and Go</a></li>\n<li><a href=\"https://gobyexample.com/json\">Go by example: JSON</a></li>\n<li><a href=\"http://attilaolah.eu/2013/11/29/json-decoding-in-go/\">JSON decoding in Go</a></li>\n<li><a href=\"https://eager.io/blog/go-and-json/\">go and json</a></li>\n<li><a href=\"https://www.goinggo.net/2014/01/decode-json-documents-in-go.html\">Decode JSON Documents In Go</a></li>\n<li><a href=\"https://journal.paul.querna.org/articles/2014/03/31/ffjson-faster-json-in-go/\">ffjson: faster JSON serialization for Golang</a></li>\n<li><a href=\"http://www.slideshare.net/albertstrasheim/serialization-in-go\">Serialization in Go</a></li>\n</ul>\n<p>第三方类库：</p>\n<ul>\n<li><a href=\"https://github.com/pquerna/ffjson\">ffjson</a>: faster JSON serialization for Go</li>\n<li><a href=\"https://github.com/bitly/go-simplejson\">go-simplejson</a>: a Go package to interact with arbitrary JSON</li>\n<li><a href=\"https://github.com/antonholmquist/jason\">Jason</a>: Easy-to-use JSON Library for Go</li>\n<li><a href=\"https://github.com/mailru/easyjson\">easyjson</a></li>\n<li><a href=\"https://github.com/Jeffail/gabs\">gabs</a></li>\n<li><a href=\"https://github.com/buger/jsonparser\">jsonparser</a></li>\n</ul>\n<p>工具：</p>\n<ul>\n<li><a href=\"https://mholt.github.io/json-to-go/\">JSON-to-Go</a>: instantly converts JSON into a Go type definition</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>一个人不会两次掉进同一个坑里，但是如果他（她）忘记了坑的位置，那就不一定了。</p>\n<p>这篇文章记录了最近使用Golang处理JSON遇到的一些坑。</p>\n<h1 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h1><h2 id=\"1号坑：omitempty的行为\"><a href=\"#1号坑：omitempty的行为\" class=\"headerlink\" title=\"1号坑：omitempty的行为\"></a>1号坑：<code>omitempty</code>的行为</h2><p>C#中最常用的JSON序列化类库<code>Newtonsoft.Json</code>中，把一个类的实例序列化成JSON，如果我们不想让某个属性输出到JSON中，可以通过<code>property annotation</code>或者<code>ShouldSerialize method</code>等方法，告知序列化程序。如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过ShouldSerialize method指示不要序列化ObsoleteSetting属性</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Fizz ObsoleteSetting &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">ShouldSerializeObsoleteSetting</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过JsonIgnore的annotation指示不需要序列化ObsoleteSetting属性</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">JsonIgnore</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Fizz ObsoleteSetting &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Bang ReplacementSetting &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于<code>Newtonsoft.Json</code>的Conditional Property Serialization的更多内容参考：</p>\n<ul>\n<li><a href=\"http://www.newtonsoft.com/json/help/html/ConditionalProperties.htm\">Conditional Property Serialization</a></li>\n<li><a href=\"http://stackoverflow.com/questions/11564091/making-a-property-deserialize-but-not-serialize-with-json-net\">Making a property deserialize but not serialize with json.net</a></li>\n</ul>\n<p>开始使用Golang的时候，以为<code>omitempty</code>的行为和C#中一样用来控制是否序列化字段，结果使用的时候碰了一头钉子。回头阅读<a href=\"http://docs.studygolang.com/pkg/encoding/json/#Marshal\">encoding&#x2F;json package的官方文档</a>，找到对<code>omitempty</code>行为的描述：</p>\n<blockquote>\n<p>Struct values encode as JSON objects. Each exported struct field becomes a member of the object unless</p>\n<ul>\n<li>the field’s tag is “-“, or</li>\n<li>the field is empty and its tag specifies the “omitempty” option.</li>\n</ul>\n<p>The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero. The object’s default key string is the struct field name but can be specified in the struct field’s tag value. The “json” key in the struct field’s tag value is the key name, followed by an optional comma and options. Examples:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Field is ignored by this package.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;-&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Field appears in JSON as key &quot;myName&quot;.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;myName&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Field appears in JSON as key &quot;myName&quot; and</span></span><br><span class=\"line\"><span class=\"comment\">// the field is omitted from the object if its value is empty,</span></span><br><span class=\"line\"><span class=\"comment\">// as defined above.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;myName,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Field appears in JSON as key &quot;Field&quot; (the default), but</span></span><br><span class=\"line\"><span class=\"comment\">// the field is skipped if empty.</span></span><br><span class=\"line\"><span class=\"comment\">// Note the leading comma.</span></span><br><span class=\"line\">Field <span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br></pre></td></tr></table></figure></blockquote>\n<p>Golang中，如果指定一个<code>field</code>序列化成JSON的变量名字为<code>-</code>，则序列化的时候自动忽略这个<code>field</code>。这种用法，才是和上面<code>JsonIgnore</code>的用法的作用是一样的。</p>\n<p>而<code>omitempty</code>的作用是当一个<code>field</code>的值是<code>empty</code>的时候，序列化JSON时候忽略这个<code>field</code>（<code>Newtonsoft.Json</code>的类似用法参考<a href=\"http://stackoverflow.com/questions/6507889/how-to-ignore-a-property-in-class-if-null-using-json-net\">这里</a>和<a href=\"https://dotnetfiddle.net/VXqRnm\">例子</a>）。这里需要注意的是关于<code>emtpty</code>的定义：</p>\n<blockquote>\n<p>The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero.</p>\n</blockquote>\n<p>通过下面的例子，来加深对<code>empty values</code>的了解：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    I1 <span class=\"type\">int</span></span><br><span class=\"line\">    I2 <span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    F1 <span class=\"type\">float64</span></span><br><span class=\"line\">    F2 <span class=\"type\">float64</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    S1 <span class=\"type\">string</span></span><br><span class=\"line\">    S2 <span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    B1 <span class=\"type\">bool</span></span><br><span class=\"line\">    B2 <span class=\"type\">bool</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Slice1 []<span class=\"type\">int</span></span><br><span class=\"line\">    Slice2 []<span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    Slice3 []<span class=\"type\">int</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map1 <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span></span><br><span class=\"line\">    Map2 <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    Map3 <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    O1 <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    O2 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O3 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O4 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O5 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O6 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O7 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    O8 <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    P1 *<span class=\"type\">int</span></span><br><span class=\"line\">    P2 *<span class=\"type\">int</span>               <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P3 *<span class=\"type\">int</span>               <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P4 *<span class=\"type\">float64</span>           <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P5 *<span class=\"type\">string</span>            <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P6 *<span class=\"type\">bool</span>              <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P7 *[]<span class=\"type\">int</span>             <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">    P8 *<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"string\">`json:&quot;,omitempty&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    p3 := <span class=\"number\">0</span></span><br><span class=\"line\">    p4 := <span class=\"type\">float64</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    p5 := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    p6 := <span class=\"literal\">false</span></span><br><span class=\"line\">    p7 := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    p8 := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s1 := S1&#123;</span><br><span class=\"line\">        I1: <span class=\"number\">0</span>,</span><br><span class=\"line\">        I2: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        F1: <span class=\"number\">0</span>,</span><br><span class=\"line\">        F2: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        S1: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">        S2: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        B1: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        B2: <span class=\"literal\">false</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        Slice1: []<span class=\"type\">int</span>&#123;&#125;,</span><br><span class=\"line\">        Slice2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        Slice3: []<span class=\"type\">int</span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        Map1: <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;,</span><br><span class=\"line\">        Map2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        Map3: <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        O1: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        O2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        O3: <span class=\"type\">int</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        O4: <span class=\"type\">float64</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        O5: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">        O6: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        O7: []<span class=\"type\">int</span>&#123;&#125;,</span><br><span class=\"line\">        O8: <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        P1: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        P2: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        P3: &amp;p3,</span><br><span class=\"line\">        P4: &amp;p4,</span><br><span class=\"line\">        P5: &amp;p5,</span><br><span class=\"line\">        P6: &amp;p6,</span><br><span class=\"line\">        P7: &amp;p7,</span><br><span class=\"line\">        P8: &amp;p8,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    b, err := json.Marshal(s1)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Printf(<span class=\"string\">&quot;marshal error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> out bytes.Buffer</span><br><span class=\"line\">    json.Indent(&amp;out, b, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;\\t&quot;</span>)</span><br><span class=\"line\">    out.WriteTo(os.Stdout)</span><br><span class=\"line\">    <span class=\"comment\">//Output:</span></span><br><span class=\"line\">    <span class=\"comment\">//&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;I1&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;F1&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;S1&quot;: &quot;&quot;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;B1&quot;: false,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;Slice1&quot;: [],</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;Map1&quot;: &#123;&#125;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O1&quot;: null,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O3&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O4&quot;: 0,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O5&quot;: &quot;&quot;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O6&quot;: false,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O7&quot;: [],</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;O8&quot;: &#123;&#125;,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;P1&quot;: null,</span></span><br><span class=\"line\">    <span class=\"comment\">//\t&quot;P2&quot;: 0</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;%</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/6y_m27r8EO\">这里</a>执行上面的程序</em></p>\n<p>关于<code>empty value</code>的定义，这里面隐藏了一些坑。下面通过一个例子来说明。</p>\n<p>假设我们有一个社交类App，通过Restful API形式从服务端获取当前登录用户基本信息及粉丝数量。如果服务端对Response中<code>User</code>对象的定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        <span class=\"type\">int</span> <span class=\"string\">`json:&quot;id&quot;`</span>                  <span class=\"comment\">// 用户id</span></span><br><span class=\"line\">    <span class=\"comment\">// 其它field</span></span><br><span class=\"line\">    FansCount <span class=\"type\">int</span> <span class=\"string\">`json:&quot;fansCount,omitempty&quot;`</span> <span class=\"comment\">// 粉丝数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果正在使用App时一个还没有粉丝的用户，访问Restful API的得到Response如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1000386</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候你会发现Response的User对象中没有<code>fansCount</code>，因为<code>fansCount</code>是个<code>int</code>类型且值为0，序列化的时候会被忽略。语义上，<code>User</code>对象中没有<code>fansCount</code>应该理解为<strong>粉丝数量未知</strong>，而不是<strong>没有粉丝</strong>。</p>\n<p>如果我们希望做到能够区分<strong>粉丝数未知</strong>和<strong>没有粉丝</strong>两种情况，需要修改<code>User</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        <span class=\"type\">int</span>  <span class=\"string\">`json:&quot;id&quot;`</span>                  <span class=\"comment\">// 用户id</span></span><br><span class=\"line\">    <span class=\"comment\">// 其它field</span></span><br><span class=\"line\">    FansCount *<span class=\"type\">int</span> <span class=\"string\">`json:&quot;fansCount,omitempty&quot;`</span> <span class=\"comment\">// 粉丝数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将<code>FansCount</code>修改为指针类型，如果为<code>nil</code>，表示粉丝数未知；如果为整数（包括0），表示粉丝数。</p>\n<p>这么修改语义上没有漏洞了，但是代码中要给<code>FansCount</code>赋值的时候却要多一句废话。必须先将从数据源查询出粉丝数赋给一个变量，然后再将变量的指针传给<code>FansCount</code>。代码读起来实在是啰嗦：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FansCount是int类型时候</span></span><br><span class=\"line\">user := dataAccess.GetUserInfo(userId)</span><br><span class=\"line\">user.FansCount = dataAccess.GetFansCount(userId)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FansCount是*int类型的时候</span></span><br><span class=\"line\">user := dataAccess.GetUserInfo(userId)</span><br><span class=\"line\">fansCount := dataAccess.GetFansCount(userId)</span><br><span class=\"line\">user.FansCount = &amp;fansCount</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2号坑：JSON反序列化成interface-对Number的处理\"><a href=\"#2号坑：JSON反序列化成interface-对Number的处理\" class=\"headerlink\" title=\"2号坑：JSON反序列化成interface{}对Number的处理\"></a>2号坑：JSON反序列化成interface{}对Number的处理</h2><p><a href=\"http://json.org/\">JSON的规范</a>中，对于数字类型，并不区分是整型还是浮点型。</p>\n<p><img src=\"https://www.json.org/img/value.png\"></p>\n<p>对于如下JSON文本:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ethancai&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;fansCount&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">9223372036854775807</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果反序列化的时候指定明确的结构体和变量类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name      <span class=\"type\">string</span></span><br><span class=\"line\">    FansCount <span class=\"type\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user User  <span class=\"comment\">// 类型为User</span></span><br><span class=\"line\">    err := json.Unmarshal([]<span class=\"type\">byte</span>(jsonStream), &amp;user)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, user)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">//  &#123;Name:ethancai FansCount:9223372036854775807&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/203egccrea\">这里</a>执行上面的程序</em></p>\n<p>如果反序列化不指定结构体类型或者变量类型，则JSON中的数字类型，默认被反序列化成<code>float64</code>类型：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// 不指定反序列化的类型</span></span><br><span class=\"line\">    err := json.Unmarshal([]<span class=\"type\">byte</span>(jsonStream), &amp;user)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m := user.(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    fansCount := m[<span class=\"string\">&quot;fansCount&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, reflect.TypeOf(fansCount).Name())</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, fansCount.(<span class=\"type\">float64</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// \tfloat64</span></span><br><span class=\"line\"><span class=\"comment\">//  \t9.223372036854776e+18</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/l4GzgA4WDA\">这里</a>执行上面的程序</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name      <span class=\"type\">string</span></span><br><span class=\"line\">    FansCount <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// 不指定FansCount变量的类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user User</span><br><span class=\"line\">    err := json.Unmarshal([]<span class=\"type\">byte</span>(jsonStream), &amp;user)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, user)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#123;Name:ethancai FansCount:9.223372036854776e+18&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://play.golang.org/p/SoD6SOGuCM\">这里</a>执行上面的程序</em></p>\n<p>从上面的程序可以发现，如果<code>fansCount</code>精度比较高，反序列化成<code>float64</code>类型的数值时存在丢失精度的问题。</p>\n<p>如何解决这个问题，先看下面程序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> jsonStream = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &#123;&quot;name&quot;:&quot;ethancai&quot;, &quot;fansCount&quot;: 9223372036854775807&#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\"></span><br><span class=\"line\">    decoder := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class=\"line\">    decoder.UseNumber()    <span class=\"comment\">// UseNumber causes the Decoder to unmarshal a number into an interface&#123;&#125; as a Number instead of as a float64.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> user <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := decoder.Decode(&amp;user); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m := user.(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\">    fansCount := m[<span class=\"string\">&quot;fansCount&quot;</span>]</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, reflect.TypeOf(fansCount).PkgPath() + <span class=\"string\">&quot;.&quot;</span> + reflect.TypeOf(fansCount).Name())</span><br><span class=\"line\"></span><br><span class=\"line\">     v, err := fansCount.(json.Number).Int64()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%+v \\n&quot;</span>, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// \tencoding/json.Number</span></span><br><span class=\"line\"><span class=\"comment\">// \t9223372036854775807</span></span><br></pre></td></tr></table></figure>\n<p><em>点击<a href=\"https://play.golang.org/p/KYrFshVMFD\">这里</a>执行上面的程序</em></p>\n<p>上面的程序，使用了<code>func (*Decoder) UseNumber</code>方法告诉反序列化JSON的数字类型的时候，不要直接转换成<code>float64</code>，而是转换成<code>json.Number</code>类型。<code>json.Number</code>内部实现机制是什么，我们来看看源码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Number represents a JSON number literal.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Number <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String returns the literal text of the number.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n Number)</span></span> String() <span class=\"type\">string</span> &#123; <span class=\"keyword\">return</span> <span class=\"type\">string</span>(n) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Float64 returns the number as a float64.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n Number)</span></span> Float64() (<span class=\"type\">float64</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strconv.ParseFloat(<span class=\"type\">string</span>(n), <span class=\"number\">64</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Int64 returns the number as an int64.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n Number)</span></span> Int64() (<span class=\"type\">int64</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strconv.ParseInt(<span class=\"type\">string</span>(n), <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>json.Number</code>本质是字符串，反序列化的时候将JSON的数值先转成<code>json.Number</code>，其实是一种延迟处理的手段，待后续逻辑需要时候，再把<code>json.Number</code>转成<code>float64</code>或者<code>int64</code>。</p>\n<p>对比其它语言，Golang对JSON反序列化处理真是易用性太差（“蛋疼”）。</p>\n<p>JavaScript中所有的数值都是双精度浮点数（参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates\">这里</a>），反序列化JSON的时候不用考虑数值类型匹配问题。这里多说两句，JSON的全名JavaScript Object Notation（从名字上就能看出和JavaScript的关系非常紧密），发明人是Douglas Crockford，如果你自称熟悉JavaScript而不知道<a href=\"http://www.infoq.com/cn/news/2010/02/qconbeijing2010-douglas\">Douglas Crockford</a>是谁，就像是自称是苹果粉丝却不知道乔布斯是谁。</p>\n<p>C#语言的第三方JSON处理library <a href=\"http://www.newtonsoft.com/json\">Json.NET</a>反序列化JSON对数值的处理也比Golang要优雅的多：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Newtonsoft.Json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> json = <span class=\"string\">@&quot;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;Name&#x27;: &#x27;Ethan&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;FansCount&#x27;: 121211,</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;Price&#x27;: 99.99</span></span><br><span class=\"line\"><span class=\"string\">&#125;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Product m = JsonConvert.DeserializeObject&lt;Product&gt;(json);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(m.FansCount);</span><br><span class=\"line\">        Console.WriteLine(m.FansCount.GetType().FullName);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(m.Price);</span><br><span class=\"line\">        Console.WriteLine(m.Price.GetType().FullName);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Product</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> Name</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">object</span> FansCount</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">object</span> Price</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">//      121211</span></span><br><span class=\"line\"><span class=\"comment\">//      System.Int64</span></span><br><span class=\"line\"><span class=\"comment\">//      99.99</span></span><br><span class=\"line\"><span class=\"comment\">//      System.Double</span></span><br></pre></td></tr></table></figure>\n\n<p><em>点击<a href=\"https://dotnetfiddle.net/IrlMae\">这里</a>执行上面的程序</em></p>\n<p><code>Json.NET</code>在反序列化的时候自动识别数值是浮点型还是整型，这一点对开发者非常友好。</p>\n<h2 id=\"3号坑：选择什么格式表示日期\"><a href=\"#3号坑：选择什么格式表示日期\" class=\"headerlink\" title=\"3号坑：选择什么格式表示日期\"></a>3号坑：选择什么格式表示日期</h2><p>JSON的规范中并没有日期类型，不同语言的library对日期序列化的处理也不完全一致：</p>\n<p>Go语言：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> Product <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        Name      <span class=\"type\">string</span></span><br><span class=\"line\">        CreatedAt time.Time</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pdt := Product&#123;</span><br><span class=\"line\">        Name:      <span class=\"string\">&quot;Reds&quot;</span>,</span><br><span class=\"line\">        CreatedAt: time.Now(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b, err := json.Marshal(pdt)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    os.Stdout.Write(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output</span></span><br><span class=\"line\"><span class=\"comment\">//      &#123;&quot;Name&quot;:&quot;Reds&quot;,&quot;CreatedAt&quot;:&quot;2016-06-27T07:40:54.69292134+08:00&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>JavaScript语言：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ node</span><br><span class=\"line\">&gt; var jo = &#123; name: <span class=\"string\">&quot;ethan&quot;</span>, createdAt: Date.now() &#125;;</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; JSON.stringify(jo)</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;ethan&quot;,&quot;createdAt&quot;:1466984665633&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>C#语言：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Newtonsoft.Json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Product product = <span class=\"keyword\">new</span> Product();</span><br><span class=\"line\">        product.Name = <span class=\"string\">&quot;Apple&quot;</span>;</span><br><span class=\"line\">        product.CreatedAt = DateTime.Now;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">string</span> json = JsonConvert.SerializeObject(product,</span><br><span class=\"line\">                            Newtonsoft.Json.Formatting.Indented,</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> JsonSerializerSettings &#123;</span><br><span class=\"line\">                                NullValueHandling = NullValueHandling.Ignore</span><br><span class=\"line\">                            &#125;);</span><br><span class=\"line\">        Console.WriteLine(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Product</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> Name</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DateTime CreatedAt</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">//      &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        &quot;Name&quot;: &quot;Apple&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//        &quot;CreatedAt&quot;: &quot;2016-06-26T23:46:57.3244307+00:00&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//      &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>Go的<code>encoding/json</code> package、C#的Json.NET默认把日期类型序列化成<a href=\"http://www.w3.org/TR/NOTE-datetime\">ISO 8601标准</a>的格式，JavaScript默认把<code>Date</code>序列化从1970年1月1日0点0分0秒的毫秒数。但JavaScript的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\"><code>dateObj.toISOString()</code></a>能够将日期类型转成ISO格式的字符串，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse\"><code>Date.parse(dateString)</code></a>方法能够将ISO格式的日期字符串转成日期。</p>\n<p>个人认为ISO格式的日期字符串可读性更好，但序列化和反序列化时的性能应该比整数更低。这一点从Go语言中<code>time.Time</code>的定义看出来。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Time <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// sec gives the number of seconds elapsed since</span></span><br><span class=\"line\">    <span class=\"comment\">// January 1, year 1 00:00:00 UTC.</span></span><br><span class=\"line\">    sec <span class=\"type\">int64</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nsec specifies a non-negative nanosecond</span></span><br><span class=\"line\">    <span class=\"comment\">// offset within the second named by Seconds.</span></span><br><span class=\"line\">    <span class=\"comment\">// It must be in the range [0, 999999999].</span></span><br><span class=\"line\">    nsec <span class=\"type\">int32</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// loc specifies the Location that should be used to</span></span><br><span class=\"line\">    <span class=\"comment\">// determine the minute, hour, month, day, and year</span></span><br><span class=\"line\">    <span class=\"comment\">// that correspond to this Time.</span></span><br><span class=\"line\">    <span class=\"comment\">// Only the zero Time has a nil Location.</span></span><br><span class=\"line\">    <span class=\"comment\">// In that case it is interpreted to mean UTC.</span></span><br><span class=\"line\">    loc *Location</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体选择哪种形式在JSON中表示日期，有如下几点需要注意：</p>\n<ul>\n<li>选择标准格式。曾记得.NET Framework官方序列化JSON的方法中，会把日期转成如<code>&quot;\\/Date(1343660352227+0530)\\/&quot;</code>的专有格式，这样的专有格式对跨语言的访问特别不友好。</li>\n<li>如果你倾向性能，可以使用整数。如果你倾向可读性，可以使用ISO字符串。</li>\n<li>如果使用整数表示日期，而你的应用又是需要支持跨时区的，注意一定要是从<code>1970-1-1 00:00:00 UTC</code>开始计算的毫秒数，而不是当前时区的<code>1970-1-1 00:00:00</code>。</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>文章：</p>\n<ul>\n<li><a href=\"http://docs.studygolang.com/pkg/encoding/json/\">package encoding&#x2F;json in Go</a></li>\n<li><a href=\"http://docs.studygolang.com/src/encoding/json/example_test.go\">http://docs.studygolang.com/src/encoding/json/example_test.go</a></li>\n<li><a href=\"https://blog.golang.org/json-and-go\">The Go Blog: JSON and Go</a></li>\n<li><a href=\"https://gobyexample.com/json\">Go by example: JSON</a></li>\n<li><a href=\"http://attilaolah.eu/2013/11/29/json-decoding-in-go/\">JSON decoding in Go</a></li>\n<li><a href=\"https://eager.io/blog/go-and-json/\">go and json</a></li>\n<li><a href=\"https://www.goinggo.net/2014/01/decode-json-documents-in-go.html\">Decode JSON Documents In Go</a></li>\n<li><a href=\"https://journal.paul.querna.org/articles/2014/03/31/ffjson-faster-json-in-go/\">ffjson: faster JSON serialization for Golang</a></li>\n<li><a href=\"http://www.slideshare.net/albertstrasheim/serialization-in-go\">Serialization in Go</a></li>\n</ul>\n<p>第三方类库：</p>\n<ul>\n<li><a href=\"https://github.com/pquerna/ffjson\">ffjson</a>: faster JSON serialization for Go</li>\n<li><a href=\"https://github.com/bitly/go-simplejson\">go-simplejson</a>: a Go package to interact with arbitrary JSON</li>\n<li><a href=\"https://github.com/antonholmquist/jason\">Jason</a>: Easy-to-use JSON Library for Go</li>\n<li><a href=\"https://github.com/mailru/easyjson\">easyjson</a></li>\n<li><a href=\"https://github.com/Jeffail/gabs\">gabs</a></li>\n<li><a href=\"https://github.com/buger/jsonparser\">jsonparser</a></li>\n</ul>\n<p>工具：</p>\n<ul>\n<li><a href=\"https://mholt.github.io/json-to-go/\">JSON-to-Go</a>: instantly converts JSON into a Go type definition</li>\n</ul>\n"},{"title":"记一次结对开发Golang组件的过程","date":"2016-04-19T18:09:39.000Z","_content":"\n\n# 目录\n\n<!-- TOC depthFrom:1 depthTo:2 withLinks:0 updateOnSave:1 orderedList:0 -->\n\n- 前言\n- `dlog`的用途\n- 对`dlog`的一些非功能性需求\n- 碰到问题及解决方案\n    - 何时使用`panic`，何时使用`return error`\n    - 如何实现一个`logger`只能接收对应类型的`data log`\n    - 如何实现批量发送`data log`\n    - 如何实现对`Logger.Log`方法的调用超时机制\n    - 如何在`logger`没有收到新`msg`情况下，保证`buf`中的数据依然会定期发送给AWS Kinesis\n    - 如何向程序外部暴露运行指标\n    - 如何在单元测试中实现`Setup`和`TearDown`\n    - 如何实现`kinesisMock`\n    - 如何模拟AWS Kinesis响应慢或者不可用\n    - 提交到代码库中的测试代码是否可以保留`log.Print`\n- 踩过的一些坑\n- 未来可以优化的地方\n- 参考\n\n<!-- /TOC -->\n\n# 前言\n\n本文记录了前段时间我和[王益](https://segmentfault.com/a/1190000002416822)使用Go语言合作开发一个log组件[dlog](https://github.com/topicai/dlog)的过程中学到的一些知识。在整个合作开发的过程中，王益严谨认真的态度，对开发质量的严格要求，给我留下了极其深刻的印象。能够和王益这样的顶级工程师切磋技艺，对我学习Go语言帮助非常大。也谨以此文表达对王益的感谢。\n\n> 注：本文假设读者已经对Go语法已经有基本了解。\n\n# `dlog`的用途\n\n首先引用项目**readme文档**的第一段文字介绍一下`dlog`的用途：\n\n> dlog is a Go package for distributed structure logging using Amazon AWS Kinesis/Firehose.\n\n更多介绍和设计请阅读[readme文档](https://github.com/topicai/dlog/blob/develop/README.md)\n\n`dlog`主要是用来记录程序的`data log`的这样一个Golang package，那什么是`data log`？这里先简要解释一下。一般程序运行过程中主要产生两类日志：\n\n- `status log`：主要用于帮助调试、定位程序Bug、或者找到性能瓶颈，比如方法调用日志、错误日志、方法执行时间日志等\n- `data log`：主要用于记录用户行为，收集的`data log`用于后期的个性化搜索、智能推荐等，比如搜索行为、点击行为等\n\n\n# 对`dlog`的一些非功能性需求\n\n- 每一种类型的`data log`对应一种`logger`，一个`logger`只能记录对应类型的`data log`\n- `dlog`内部发生的错误，不能影响调用的程序代码的执行\n    - 应考虑到AWS Kinesis服务响应慢或者不可用的场景（暂未实现）\n- 程序代码中通过调用`dlog`的方法记录`data log`，`dlog`的方法不能阻塞调用的程序代码的执行（这一点`dlog`暂时未满足要求，需要后期改进）\n- AWS Kinesis提供两个API接收数据，一个是[PutRecord](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html), 另一个是[PutRecords](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecords.html)，为了减少对Kinesis的调用次数，采用后者批量发送`data log`\n    - `PutRecords`对一次调用的`record`数量限制是`500`，每个`record`大小必须小于等于1MB，整个`request`的大小必须小于等于5MB\n    - 每一个Kinesis Stream能够承受的最大TPS和写数据量，与这个stream拥有的shard的数量有关。一个shard支持最大TPS是`1000 records per second`， 写数据量是`1MB per second`\n- 通过单元测试保证功能正确性\n\n\n# 碰到问题及解决方案\n\n## 何时使用`panic`，何时使用`return error`\n\n先看看`panic`和`return error`的执行机制。\n\n### `panic`的执行机制\n\n`panic`会中断当前`goroutine`的执行，如果不对`panic`的错误进行`recover`，那么整个进程都会崩溃。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nfunc main() {\n    go func() {\n        log.Panic(\"some error before work2\")\n        fmt.Println(\"do some work2\")\n    }()\n\n    time.Sleep(time.Second)\n    fmt.Println(\"do some work1\")\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/off1y9tBax)_\n\n可以通过`recover`捕捉当前`goroutine`中`panic`的错误并进行错误处理，整个进程的正常运行不受影响。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nfunc main() {\n    go func() {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"error: %v\", err)\n            }\n        }()\n        log.Panic(\"some error before work2\")\n        fmt.Println(\"do some work2\")\n    }()\n\n    time.Sleep(time.Second)\n    fmt.Println(\"do some work1\")\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/RLWyb813Uw)_\n\n我们可以发现Go语言中的`panic`、`recover`机制，和Java、.NET中的`throw`、`try...catch`机制非常类似。\n\n### `return error`的执行机制\n\n`return error`是利用Go语言函数的多值返回的特性，通过函数的其中一个返回值（一般是第一个或者最后一个），向`caller`返回函数执行过程中产生的异常，其它值返回执行结果。\n\n这种方式的问题，主要在于：如果函数调用层次比较多，每一层函数都通过`return error`方式返回错误，都需要处理被调用函数的`return error`，增加代码复杂度。对于无法恢复的错误也没有必要一层一层往上抛，直接`panic/recover`更加简洁。\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"log\"\n)\n\ntype R struct {\n}\n\nfunc f1() (error, *R) {\n    return errors.New(\"an error\"), nil\n}\n\nfunc f2() (error, *R) {\n    err, r := f1()\n    if err != nil {\n        return err, nil\n    }\n\n    return nil, r\n}\n\nfunc f3() (error, *R) {\n    err, r := f2()\n    if err != nil {\n        return err, nil\n    }\n\n    return nil, r\n}\n\nfunc main() {\n    err, _ := f3()\n    if err != nil {\n        log.Print(err)\n    }\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/GhE5JpzZvn)_\n\n### `dlog`错误处理原则\n\n使用`panic`还是`return error`的方式处理错误，要区分不同的场景。重要是不论使用`panic`还是`return error`，都需要符合架构上更高层面错误处理需求。\n\n`dlog`是一个日志记录`package`，暴露给其它程序调用的方法如下：\n\n- `func NewLogger(example interface{}, opts *Options) (*Logger, error)`\n- `func (l *Logger) Log(msg interface{}) error`\n\n这两个方法的使用场景并不一样，错误处理原则也不完全一致：\n\n- `NewLogger`方法一般是在程序初始化的时候调用，用于创建记录程序运行过程中产生的data log的记录器。通过`NewLogger`创建一个`logger`的时候，如果传入参数不正确，使用`panic`方式，在上层调用程序不处理错误情况下会导致程序崩溃，所以使用`return error`方式向`caller`报告错误。大多数Golang package也是按此原则处理。\n- 上层程序调用`logger.Log`时，如果`Log`方法内部发生的错误，不能影响调用的代码的执行，所以这里绝对不能用`panic`方式抛出错误。日志记录是辅助功能，如果日志记录行为失败，导致业务逻辑代码执行不下去，估计负责业务逻辑开发的工程师会和你拼命。\n    - `logger.Log`可以使用`return error`方式返回`msg`校验类的错误\n    - `logger.Log`发送日志采用的是异步批量方式向AWS Kinesis发送数据，向AWS Kinesis发送数据相关的错误无法通过`panic`或者`return error`方式直接报告给调用程序。最好的方式是允许调用程序向`logger`注册发送失败处理的`handler`，出现发送失败错误时执行`handler`逻辑。（暂未实现）\n\n## 如何实现一个`logger`只能接收对应类型的`data log`\n\n要实现一个`logger`只能接收对应类型的`data log`，主要思路如下：\n\n- `Logger`的定义中通过属性`msgType reflect.Type`记住能够接受的消息类型\n- 通过`NewLogger`方法创建`logger`的时候，指定`logger`可以接受的消息类型\n- `Log`方法中首先校验`msg`的类型是否是创建`logger`时指定的类型\n\n以下是相关代码：\n\n```go\n// msgType保存Logger能够接受的消息类型\ntype Logger struct {\n    ...\n    msgType    reflect.Type\n    ...\n}\n\n// 获得msg的reflect.Type\nfunc msgType(msg interface{}) (reflect.Type, error) {\n    t := reflect.TypeOf(msg)\n\n    if t.Kind() == reflect.Ptr {\n        t = t.Elem()\n    }\n\n    if t.Kind() != reflect.Struct {\n        return nil, fmt.Errorf(\"dlog message must be either *struct or struct\")\n    }\n\n    return t, nil\n}\n\nfunc NewLogger(example interface{}, opts *Options) (*Logger, error) {\n    t, e := msgType(example)\n    if e != nil {\n        return nil, e\n    }\n\n    ...\n\n    l := &Logger{\n        ...\n        msgType:    t,\n        ...\n    }\n\n    ...\n    return l, nil\n}\n\nfunc (l *Logger) Log(msg interface{}) error {\n    if t, e := msgType(msg); e != nil {\n        return e\n    } else if !t.AssignableTo(l.msgType) {\n        return fmt.Errorf(\"parameter (%+v) not assignable to %v\", msg, l.msgType)\n    }\n\n    ...\n}\n```\n\n`Log`方法中为什么要用`AssignableTo`，而不是直接判断两个类型相等。其实都可以，在`msg`是`struct`情况下，`AssignableTo`返回`True`意味着两个类型相等。参考下面的例子：\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"reflect\"\n)\n\nfunc main() {\n    type Fn func(int) int\n    id := func(x int) int {\n        return x\n    }\n    var zeroFn Fn\n    log.Println(reflect.TypeOf(id).AssignableTo(reflect.TypeOf(zeroFn)))\n\n    type MyInt int\n    mi := 1\n    log.Println(reflect.TypeOf(2).AssignableTo(reflect.TypeOf(mi)))\n\n    type S1 struct {\n        name string\n    }\n    type S2 S1\n\n    s1 := S1{\n        name: \"ethan\",\n    }\n    s2 := S2{\n        name: \"ethan\",\n    }\n    // s2 = s1\t// if uncomment this line, will report \"cannot use s1 (type S1) as type S2 in assignment\" when compile\n    log.Println(reflect.TypeOf(s1).AssignableTo(reflect.TypeOf(s2)))\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/eDmzxW-ayk)_\n\n## 如何实现批量发送`data log`\n\n要实现批量发送，首先我们可以想到应该要有个`buffer`用来收集一定数量的的`message`，等待`buffer`中的数据积累到一定程度后，一次性发送给AWS Kinesis。设计`buffer`结构不难，难点在于如何解决多线程(goroutine)并发读写`buffer`的问题，主要的解决方案有两种：\n\n- 基于锁机制实现对`buffer`访问控制\n- 基于`channel`实现对`buffer`的访问控制\n\n前者对于有Java、.NET等语言的并发编程经验的工程师来说，非常熟悉。而后者则体现了CSP(Communicating Sequential Processes)并发编程模型的优势。\n\n{% asset_img channel.png CSP Model %}\n\n`dlog`的`Log`方法把收到的`msg`写到名字叫`buffer`的`channel`中，另外一个单独的`goroutine`在`channel`的另一头收集编码后的日志信息，然后保存到`buf := make([][]byte, 0)`中。当`buf`中的数据量要达到一次向AWS Kinesis发送的最大量时，调用`flush`方法向AWS Kinesis发送数据。由于只有一个`goroutine`对`buf`进行访问，所以不需要通过锁机制控制对`buf`的读写。\n\n<!--\ndigraph G {\n    fontname=\"Microsoft YaHei\";\n    fontsize=10;\n    rankdir = LR;\n\n    \"buffer channel\" [shape=box];\n\n    \"Logger.Log goroutine 1\" -> \"buffer channel\";\n    \"Logger.Log goroutine 2\" -> \"buffer channel\";\n    \"Logger.Log goroutine 3\" -> \"buffer channel\";\n    \"buffer channel\" -> \"sync goroutine\";\n    \"sync goroutine\" -> \"AWS Kinesis Stream\";\n}\n-->\n\n<!-- ![Thread Model](http://g.gravizo.com/g?digraph%20G%20%7B%0A%20%20%20%20fontname%3D%22Microsoft%20YaHei%22%3B%0A%20%20%20%20fontsize%3D10%3B%0A%20%20%20%20rankdir%20%3D%20LR%3B%0A%0A%20%20%20%20%22buffer%20channel%22%20%5Bshape%3Dbox%5D%3B%0A%0A%20%20%20%20%22Logger.Log%20goroutine%201%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%202%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%203%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22buffer%20channel%22%20-%3E%20%22sync%20goroutine%22%3B%0A%20%20%20%20%22sync%20goroutine%22%20-%3E%20%22AWS%20Kinesis%20Stream%22%3B%0A%20%7D) -->\n\n{% asset_img use_channel.png 使用Channel %}\n\n具体代码实现：\n\n```go\nfunc NewLogger(example interface{}, opts *Options) (*Logger, error) {\n    ...\n\n    go l.sync()    // 启动sync goroutine\n    return l, nil\n}\n\nfunc (l *Logger) Log(msg interface{}) error {\n    ...\n\n    en := encode(msg)       // 对msg进行编码\n    ...\n        select {\n        case l.buffer <- en:    // 向buffer channel写入编码后的msg\n        ...\n        }\n    ...\n    return nil\n}\n\nfunc (l *Logger) sync() {\n    ...\n\n    buf := make([][]byte, 0) // 用于收集从buffer channel读取的日志数据\n    bufSize := 0\n\n    for {\n        select {\n        case msg := <-l.buffer:\n            if bufSize+len(msg)+partitionKeySize >= maxBatchSize {  // 如果buf的大小接近一次批量发送的最大数据量\n                l.flush(&buf, &bufSize)                             // 向AWS Kinesis批量发送数据\n            }\n\n            buf = append(buf, msg)                                  // 将从buffer channel读取日志数据保存到buf中\n            bufSize += len(msg) + partitionKeySize\n\n        ...\n    }\n}\n```\n\n## 如何实现对`Logger.Log`方法的调用超时机制\n\n如果一个IO操作耗时较长，并且调用比较频繁的情况下，不仅会阻塞`caller`的执行，还会消耗大量系统资源。我们通常会使用超时机制，避免程序长时间等待或者对系统资源大量占用。\n\n`Logger.Log`方法利用Go语言`channel`非常简洁的实现了超时机制：\n\n```go\nfunc (l *Logger) Log(msg interface{}) error {\n    ...\n\n    var timeout <-chan time.Time\n    if l.WriteTimeout > 0 {\n        timeout = time.After(l.WriteTimeout)    // 初始化时长为l.WriteTimeout的计时器\n    }\n\n    ...\n        select {\n        case l.buffer <- en:\n        case <-timeout: // 如果上一行代码一直阻塞，timeout计时器时间到点后会触发执行当前case下的代码\n            return fmt.Errorf(\"dlog writes %+v timeout after %v\", msg, l.WriteTimeout)\n        }\n    ...\n    return nil\n}\n```\n\n对比Java、.NET语言中超时机制的实现方法，Go语言的实现简洁的令人发指：\n\n- C#\n    - [Implementing .Net method timeout](http://weblogs.asp.net/israelio/159985)\n    - [How to implement Task Async for a timer in C#?](http://stackoverflow.com/questions/18646650/how-to-implement-task-async-for-a-timer-in-c)\n    - [Implementing a timeout in c#](http://stackoverflow.com/questions/10143980/implementing-a-timeout-in-c-sharp)\n- Java\n    - [How to implement timeout using threads](http://www.coderanch.com/t/232213/threads/java/implement-timeout-threads)\n    - [How to timeout a thread](http://stackoverflow.com/questions/2275443/how-to-timeout-a-thread)\n\n## 如何在`logger`没有收到新`msg`情况下，保证`buf`中的数据依然会定期发送给AWS Kinesis\n\n`dlog`在`Logger.sync()`方法中通过一个定时器，定期将`buf`中数据发送给AWS Kinesis。\n\n```go\nfunc (l *Logger) sync() {\n    if l.SyncPeriod <= 0 {\n        l.SyncPeriod = time.Second\n    }\n    ticker := time.NewTicker(l.SyncPeriod)  // l.SyncPeriod是定期发送的数据的时间间隔，ticker定时触发器\n\n    buf := make([][]byte, 0)\n    bufSize := 0\n\n    for {  // 无限循环保证sync goroutine一直工作\n        select {\n        case msg := <-l.buffer:\n            ...\n\n        case <-ticker.C: // ticker.C的类型是<-chan Time，每隔l.SyncPeriod时间会触发执行当前case的代码\n            if bufSize > 0 {\n                l.flush(&buf, &bufSize)\n            }\n        }\n    }\n}\n```\n\n通过`ticker`，`dlog`保证了即使没有收到新的`msg`的时候，保存在`buf`中的数据最长`l.SyncPeriod`时间后也会发送给AWS Kinesis。\n\n互联网产品的生产环境的上线，通常的做法是，将现有服务分组，然后交替切流量、升级。如果没有类似的机制，那么在服务程序断掉流量，没有收到新的访问时候，保存在内存中的数据就不会发送出去，升级时就可能导致数据丢失。\n\n## 如何向程序外部暴露运行指标\n\nGo语言的官方Package `expvar`提供一种标准化的接口，允许程序暴露公开访问的变量。`expvar`通过HTTP地址`/debug/vars`提供访问入口，并以JSON格式展示这些变量。下面是关于`expvar`常见用法的一个例子：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"expvar\"\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\n// Stats is used to collect runtime metrics\ntype Stats struct {\n    sync.Mutex\n    TotalHit  int\n    ErrorNums int\n}\n\nfunc (s *Stats) IncreaseTotalHit(i int) {\n    s.Lock()\n    defer s.Unlock()\n\n    s.TotalHit += i\n}\n\nfunc (s *Stats) IncreaseErrorNums(i int) {\n    s.Lock()\n    defer s.Unlock()\n\n    s.ErrorNums += i\n}\n\nfunc (s *Stats) String() string {\n    s.Lock()\n    defer s.Unlock()\n\n    b, err := json.Marshal(*s)\n    if err != nil {\n        return \"{}\"\n    } else {\n        return string(b)\n    }\n}\n\nvar (\n    stats *Stats\n    hits  *expvar.Map\n)\n\nfunc init() {\n\n    expvar.Publish(\"now\", expvar.Func(func() interface{} {\n        return time.Now().Format(\"\\\"2006-01-02 15:04:05\\\"\")\n    }))\n\n    stats = &Stats{}\n    expvar.Publish(\"stats\", stats)\n\n    hits = expvar.NewMap(\"hits\").Init()\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n    p := r.URL.Path[1:]\n    hits.Add(p, 1)\n    stats.IncreaseTotalHit(1)\n    fmt.Fprintf(w, \"Hey! I love %s! hits: %v\\n\", p, hits.Get(p))\n}\n\nfunc errHandler(w http.ResponseWriter, r *http.Request) {\n    stats.IncreaseErrorNums(1)\n    fmt.Fprintf(w, \"Error Nums: %v\\n\", stats.ErrorNums)\n}\n\nfunc main() {\n    http.HandleFunc(\"/err\", errHandler)\n    http.HandleFunc(\"/\", homeHandler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n按照如下步骤测试运行效果：\n\n- `go run expvarexample.go`运行例子代码\n- 在浏览器中访问`http://localhost:8080/ethan`\n- 在浏览器中访问`http://localhost:8080/err`\n- 在浏览器中访问`http://localhost:8080/debug/vars`，得到如下结果：\n```json\n{\n    \"cmdline\": [\"/var/folders/jf/65ft181j33j_d75ktgv67bsc0000gn/T/go-build467453980/command-line-arguments/_obj/exe/expvarsample\"],\n    \"hits\": {\n        \"ethan\": 1,\n        \"favicon.ico\": 2\n    },\n    \"memstats\": { ... },\n    \"now\": \"\\\"2016-04-19 20:17:40\\\"\",\n    \"stats\": {\n        \"TotalHit\":3,\n        \"ErrorNums\":1\n    }\n}\n```\n\n[expvarmon](https://github.com/divan/expvarmon)是一个帮助查看`expvar`暴露运行指标的工具，用法如下：\n\n- 安装：`go get github.com/divan/expvarmon`\n- 运行：`expvarmon -ports=\"8080\" -vars=\"hits.ethan,stats.TotalHit,stats.ErrorNums,now\"`\n- 效果如下：\n{% asset_img expvarmon_screen.png expvarmon screen %}\n\n`dlog`使用`expvar`向程序外部（比如监控程序）暴露运行指标，目前`dlog`中定义的运行指标包括：\n\n- `writtenRecords`: 成功写到AWS Kinesis的`msg`数量\n- `writtenBatches`: 成功调用AWS Kinesis批量写数据API的次数\n- `failedRecords`: 写到AWS Kinesis失败的`msg`数量\n- `tooBigMesssages`: 编码后体积过大(加上partitionKeySize大于1MB)的`msg`数量\n\n未来还需要根据运维的需求对运行指标进行调整，当前的用法也有一些问题，后期需要重构。\n\n## 如何在单元测试中实现`Setup`和`TearDown`\n\nGo语言提供一种**轻量级**的单元测试框架（无需第三方工具或者程序包）。通过使用`go test`命令和`testing` package，可以非常快速的实现单元测试。先借用官方文档中的[例子](http://docs.studygolang.com/doc/code.html#Testing)回顾一下Go单元测试框架的用法：\n\n```go\n//$GOPATH/src/github.com/user/stringutil/reverse_test.go\npackage stringutil\n\nimport \"testing\"\n\nfunc TestReverse(t *testing.T) {\n    cases := []struct {\n        in, want string\n    }{\n        {\"Hello, world\", \"dlrow ,olleH\"},\n        {\"Hello, 世界\", \"界世 ,olleH\"},\n        {\"\", \"\"},\n    }\n    for _, c := range cases {\n        got := Reverse(c.in)\n        if got != c.want {\n            t.Errorf(\"Reverse(%q) == %q, want %q\", c.in, got, c.want)\n        }\n    }\n}\n```\n\n运行测试只需要简单的输入命令：\n\n```go\n$ go test github.com/user/stringutil\nok  \tgithub.com/user/stringutil 0.165s\n```\n\n很多情况下，要执行单元测试，我们需要依赖一些外部资源，比如已完成初始化数据的数据库、公有云上的一些IaaS服务等。这些依赖资源，我们希望在单元测试执行前，能够自动的被初始化；单元测试完成后，能够自动的被清理。[testify/suite](https://github.com/stretchr/testify/suite) package就提供这样的支持。通过[testify/suite](https://github.com/stretchr/testify/suite)，你可以构建一个测试集`struct`，建立测试集的`setup`(初始化)/`teardown`(清理)方法，和最终实现测试用例逻辑的方法。而运行测试，仍然只需要一句简单的`go test`。\n\n以下是使用[testify/suite](https://github.com/stretchr/testify/suite)实现测试集的常见模式：\n\n```go\npackage suite\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\ntype SuiteTester struct {\n    // Include our basic suite logic.\n    Suite\n\n    // Other properties\n    propertyN string\n}\n\n// The SetupSuite method will be run by testify once, at the very\n// start of the testing suite, before any tests are run.\nfunc (suite *SuiteTester) SetupSuite() {\n    // ...\n}\n\n// The TearDownSuite method will be run by testify once, at the very\n// end of the testing suite, after all tests have been run.\nfunc (suite *SuiteTester) TearDownSuite() {\n    // ...\n}\n\n// The SetupTest method will be run before every test in the suite.\nfunc (suite *SuiteTester) SetupTest() {\n    // ...\n}\n\n// The TearDownTest method will be run after every test in the suite.\nfunc (suite *SuiteTester) TearDownTest() {\n    // ...\n}\n\n// a test method\nfunc (suite *SuiteTester) TestOne() {\n    // ...\n}\n\n// another test method\nfunc (suite *SuiteTester) TestTwo() {\n    // ...\n}\n\n// TestRunSuite will be run by the 'go test' command, so within it, we\n// can run our suite using the Run(*testing.T, TestingSuite) function.\nfunc TestRunSuite(t *testing.T) {\n    suiteTester := new(SuiteTester)\n    Run(t, suiteTester)\n}\n```\n\n`dlog`中为了测试`Logger.Log`方法能否正常工作，按照上面的模式编写了相应的测试代码：\n\n```go\npackage dlog\n\n//...\n\ntype WriteLogSuiteTester struct {\n    suite.Suite\n\n    options     *Options\n    seachLogger *Logger\n    clickLogger *Logger\n    streamNames []string // save the created AWS Kinesis Streams, which will be removed in TearDownSuite()\n}\n\n// The SetupSuite method will be run by testify once, at the very\n// start of the testing suite, before any tests are run.\nfunc (s *WriteLogSuiteTester) SetupSuite() {\n\n    //...\n\n    // create stream 1\n    err = s.seachLogger.kinesis.CreateStream(s.seachLogger.streamName, testingShardCount)\n    s.Nil(err)\n\n    // create stream 2\n    err = s.clickLogger.kinesis.CreateStream(s.clickLogger.streamName, testingShardCount)\n    s.Nil(err)\n\n    s.streamNames = []string{s.seachLogger.streamName, s.clickLogger.streamName}\n\n    for { // waiting created stream's status to be active\n        time.Sleep(1 * time.Second)\n        resp1, err1 := s.seachLogger.kinesis.DescribeStream(s.seachLogger.streamName)\n        s.Nil(err1)\n\n        resp2, err2 := s.seachLogger.kinesis.DescribeStream(s.clickLogger.streamName)\n        s.Nil(err2)\n\n        status1 := strings.ToLower(string(resp1.StreamStatus))\n        status2 := strings.ToLower(string(resp2.StreamStatus))\n        if status1 == \"active\" && status2 == \"active\" {\n            break\n        }\n    }\n}\n\n// The TearDownSuite method will be run by testify once, at the very\n// end of the testing suite, after all tests have been run.\nfunc (s *WriteLogSuiteTester) TearDownSuite() {\n    if s.streamNames == nil || len(s.streamNames) == 0 {\n        return\n    }\n\n    for _, streamName := range s.streamNames {\n        err := s.seachLogger.kinesis.DeleteStream(streamName)\n        s.Nil(err)\n    }\n}\n\nfunc (s *WriteLogSuiteTester) TestWriteLog() {\n    defer func() { // Recover if panicking to make sure TearDownSuite will be executed\n        if r := recover(); r != nil {\n            s.Fail(fmt.Sprint(r))\n        }\n    }()\n\n    //...\n}\n\nfunc TestRunWriteLogSuite(t *testing.T) {\n    suiteTester := new(WriteLogSuiteTester)\n    suite.Run(t, suiteTester)\n}\n```\n\n注：\n\n- 很多场景下，测试程序自动创建依赖的资源需要运维部门的授权，所以实现前有必要先和运维部门沟通。\n- 云环境下，出于安全上的考虑，需要对创建、删除测试资源的账户管理严格管理\n    - 账户信息不能写在可以公开访问的测试代码、配置文件中\n    - 只给账户分配必要资源的最小权限\n    - 为账户能够创建的资源设定配额\n\n## 如何实现`kinesisMock`\n\n上一节我们提到在测试执行前初始化依赖资源，现实场景中，并不是任何情况下都能够获得依赖的测试资源，或者测试资源也会出现不可用的情况。通过Mock技术，可以减少测试代码对其它资源（或模块）的依赖。\n\n`dlog`的测试代码中，首先定义了一个`KinesisInterface`:\n\n```go\ntype KinesisInterface interface {\n    PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error)\n    CreateStream(name string, shardCount int) error\n    DescribeStream(name string) (resp *kinesis.StreamDescription, err error)\n    DeleteStream(name string) error\n}\n```\n\n`KinesisInterface`包含了`dlog`用到的[github.com/AdRoll/goamz/kinesis/kinesis](https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go)的所有方法。因为Go语言`interface`实现**非侵入式**的特点，[github.com/AdRoll/goamz/kinesis/kinesis](https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go)自动实现了`KinesisInterface`，我们再定义一个`kinesisMock`实现`KinesisInterface`：\n\n```go\ntype kinesisMock struct {\n    // Mapping from steam name to batches of batches\n    storage map[string][][]kinesis.PutRecordsRequestEntry\n\n    // simulate lantency that sync to Kinesis\n    putRecordLatency time.Duration\n\n    // created streams' names\n    streamNames []string\n\n    // lock to solve concurrent call\n    lock sync.RWMutex\n}\n\nfunc newKinesisMock(putRecordsLatency time.Duration) *kinesisMock {\n    return &kinesisMock{\n        storage:          make(map[string][][]kinesis.PutRecordsRequestEntry),\n        putRecordLatency: putRecordsLatency,\n        streamNames:      make([]string, 0),\n    }\n}\n\nfunc (mock *kinesisMock) PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error) {\n    // ...\n}\n\nfunc (mock *kinesisMock) CreateStream(name string, shardCount int) error {\n    // ...\n}\n\nfunc (mock *kinesisMock) DescribeStream(name string) (resp *kinesis.StreamDescription, err error) {\n    // ...\n}\n\nfunc (mock *kinesisMock) DeleteStream(name string) error {\n    // ...\n}\n```\n\n然后，把业务代码中所有类型`kinesis`的变量，替换成`KinesisInterface`类型。\n\n```go\ntype Logger struct {\n    //...\n    kinesis    KinesisInterface\n    //...\n}\n```\n\n测试代码中，在构造`Logger`时传入`kinesisMock`，而不是真实的`kinesis`，这样就做到了“狸猫换太子”。\n\n```go\nfunc TestLoggingToMockKinesis(t *testing.T) {\n    assert := assert.New(t)\n\n    l, e := NewLogger(&impression{}, &Options{\n        // ...\n        UseMockKinesis: true,\n        MockKinesis:    newKinesisMock(0),\n    })\n\n    // ...\n}\n```\n\n## 如何模拟AWS Kinesis响应慢或者不可用\n\n`kinesisMock`完全是我们“虚构”出来的一个`kinesis`，在它的基础上，我们完全可以模拟响应慢或者不可用的情况。\n\n上一节中，不知道大家注意到没有，`kinesisMock`有个属性叫`putRecordLatency`，用来模拟调用`PutRecords`方法的延迟时间。\n\n```go\ntype kinesisMock struct {\n    // ...\n\n    // simulate lantency that sync to Kinesis\n    putRecordLatency time.Duration\n\n    // ...\n}\n\nfunc (mock *kinesisMock) PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error) {\n    //...\n\n    time.Sleep(mock.putRecordLatency) // 模拟延迟\n\n    //...\n}\n```\n\n模拟不可用的`kinesis`则重新定义了一个`brokenKinesisMock`：\n\n```go\ntype brokenKinesisMock struct {\n    *kinesisMock\n}\n\nfunc newBrokenKinesisMock() *brokenKinesisMock {\n    return &brokenKinesisMock{\n        kinesisMock: newKinesisMock(0),\n    }\n}\n\nfunc (mock *brokenKinesisMock) PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error) {\n    return nil, fmt.Errorf(\"Kinesis is broken\")\n}\n```\n\n`kinesisMock`是`brokenKinesisMock`的嵌入`struct`，`brokenKinesisMock`会自动拥有`kinesisMock`的所有公开方法，这样也就实现了`KinesisInterface`。\n\n## 提交到代码库中的测试代码是否可以保留`log.Print`\n\n结论是“不可以”，原因总结如下：\n\n- 测试代码中的`log.Print`，一般用于调试代码，或者在`stdout`打印出一些信息帮助判断测试失败原因。不论哪种目的，这样的代码目的都仅仅是为了辅助开发，而不应该出现在最终交付的产品代码中。\n- `go test`命令会在控制台输出失败的测试方法，如果加上`-v`标志会打印出所有测试方法的执行结果，`log.Print`会影响执行结果的展示效果。团队合作开发，如果每个人都在测试代码中加上自己的`log.Print`，那么控制台打印出来的测试结果就没法看了。\n\n\n# 踩过的一些坑\n\n- [AWS Kinesis API - CreateStream](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_CreateStream.html)是异步创建Stream，而且耗时10+秒，才能完成一个Stream的创建。开始以为是同步创建，结果执行测试逻辑的时候总是出错。\n- [github.com/AdRoll/goamz/aws/regions.go](https://github.com/AdRoll/goamz/blob/master/aws/regions.go)中缺少中国区AWS Kinesis的URL地址，调用中国区AWS Kinesis会出错。\n- Travis CI会Kill掉执行时间超过1分钟的CI过程，而不是如它文档中介绍的“10分钟”\n\n\n# 未来可以优化的地方\n\n- 发送失败的错误事件机制\n- 实现Kinesis服务不可用或者响应慢的场景下`dlog`的容错处理\n\n\n# 参考\n\n- [Effective Go](http://docs.studygolang.com/doc/effective_go.html)\n- [Amazon Kinesis Documentation](https://aws.amazon.com/cn/documentation/kinesis/)\n- [Advanced Go Concurrency Patterns](http://blog.golang.org/advanced-go-concurrency-patterns)\n- [hystrix-go](https://github.com/afex/hystrix-go)\n\n\n# 招聘消息\n\n我所在的[奥阁门科技有限公司](http://www.augmn.com)正在招聘后端、运维工程师，想加入的朋友、或者有朋友可以推荐的都可以联系我(ethancai@qq.com)。\n\n{% asset_img 2016-04-21_07-12-24.png 办公环境1 %}\n\n{% asset_img 2016-04-21_07-12-40.png 办公环境2 %}\n\n**后端工程师 / Backend Engineer**\n\n职责\n\n- 研讨和设计产品功能特性；\n- 设计研发系统后端的一个或多个独立服务（micro-service）模块；\n- 设计研发业务运营管理系统；\n- Code Review。\n\n要求\n\n- 有良好的编程习惯和代码风格；\n- 精通至少一种后台开发语言，包括但不限于Go、Node.js、C++、Python；\n- 对RESTful、RPC等架构有深刻理解和运用经验；\n- 有丰富的web service、web app开发经验；使用过著名的开源应用框架，并完整阅读过源代码；\n- 对Mysql、Redis、MongoDB或同类数据存储技术有丰富的使用经验；\n- 有提交代码到著名开源库或创建过开源项目者优先；\n- 能熟练查阅英文技术文档；\n- 有开放、坦诚的沟通心态，乐于分享；\n- 5年以上工作经验，3年以上后台系统开发经验。\n\n\n**高级系统运维工程师 / Senior Ops Engineer**\n\n职责\n\n- 负责日常业务系统基础实施（AWS）、网络及各子系统的管理维护。\n- 负责设计并部署相关应用平台，并提出平台的实施、运行报告。\n- 负责配合开发搭建测试平台，协助开发设计、推行、实施和持续改进。\n- 负责相关故障、疑难问题排查处理，编制汇总故障、问题，定期提交汇总报告。\n- 负责网络监控和应急反应，以确保网络系统有7*24小时的持续运作能力。\n- 负责日常系统维护，及监控，提供IT方面的服务和支持，保证系统的稳定。\n\n要求\n\n- 深入理解Linux/Unix操作系统并能熟练使用，了解Linux系统内核，有相关操作系统调优经验优先；\n- 熟悉计算机网络基础知识，了解TCP/IP、HTTP等网络协议；\n- 熟悉系统服务的管理和维护，例如：Nginx、DNS服务器、NTP服务等；\n- 熟悉一种或者多种脚本语言，例如：Shell、Python、Perl 、Ruby等；\n- 熟练掌握Linux管理相关命令行工具，例如：grep、awk、sed、tmux、vim等；\n- 对数据库系统（MySQL）运维管理有一定的了解；\n- 熟悉常见分布式系统系统架构部署管理，熟悉基础设施管理、并具有较强的故障排查和解决问题的能力；\n- 具有 2 年以上中大型互联网系统或亚马逊AWS管理经验者优先；\n- 有DevOps经验者优先；\n- 学习能力和沟通能力较强，具有良好的团队协作精神；\n- 工作中需要胆大心细，具备探索创新精神；\n- 具有良好的文档编写能力；\n- 具有一定的英文技术文档阅读能力。\n","source":"_posts/2016-04-20-experiences-about-develop-dlog.md","raw":"---\ntitle: 记一次结对开发Golang组件的过程\ncategories:\n  - 编程开发\ntags:\n  - golang\ndate: 2016-04-20 02:09:39\n---\n\n\n# 目录\n\n<!-- TOC depthFrom:1 depthTo:2 withLinks:0 updateOnSave:1 orderedList:0 -->\n\n- 前言\n- `dlog`的用途\n- 对`dlog`的一些非功能性需求\n- 碰到问题及解决方案\n    - 何时使用`panic`，何时使用`return error`\n    - 如何实现一个`logger`只能接收对应类型的`data log`\n    - 如何实现批量发送`data log`\n    - 如何实现对`Logger.Log`方法的调用超时机制\n    - 如何在`logger`没有收到新`msg`情况下，保证`buf`中的数据依然会定期发送给AWS Kinesis\n    - 如何向程序外部暴露运行指标\n    - 如何在单元测试中实现`Setup`和`TearDown`\n    - 如何实现`kinesisMock`\n    - 如何模拟AWS Kinesis响应慢或者不可用\n    - 提交到代码库中的测试代码是否可以保留`log.Print`\n- 踩过的一些坑\n- 未来可以优化的地方\n- 参考\n\n<!-- /TOC -->\n\n# 前言\n\n本文记录了前段时间我和[王益](https://segmentfault.com/a/1190000002416822)使用Go语言合作开发一个log组件[dlog](https://github.com/topicai/dlog)的过程中学到的一些知识。在整个合作开发的过程中，王益严谨认真的态度，对开发质量的严格要求，给我留下了极其深刻的印象。能够和王益这样的顶级工程师切磋技艺，对我学习Go语言帮助非常大。也谨以此文表达对王益的感谢。\n\n> 注：本文假设读者已经对Go语法已经有基本了解。\n\n# `dlog`的用途\n\n首先引用项目**readme文档**的第一段文字介绍一下`dlog`的用途：\n\n> dlog is a Go package for distributed structure logging using Amazon AWS Kinesis/Firehose.\n\n更多介绍和设计请阅读[readme文档](https://github.com/topicai/dlog/blob/develop/README.md)\n\n`dlog`主要是用来记录程序的`data log`的这样一个Golang package，那什么是`data log`？这里先简要解释一下。一般程序运行过程中主要产生两类日志：\n\n- `status log`：主要用于帮助调试、定位程序Bug、或者找到性能瓶颈，比如方法调用日志、错误日志、方法执行时间日志等\n- `data log`：主要用于记录用户行为，收集的`data log`用于后期的个性化搜索、智能推荐等，比如搜索行为、点击行为等\n\n\n# 对`dlog`的一些非功能性需求\n\n- 每一种类型的`data log`对应一种`logger`，一个`logger`只能记录对应类型的`data log`\n- `dlog`内部发生的错误，不能影响调用的程序代码的执行\n    - 应考虑到AWS Kinesis服务响应慢或者不可用的场景（暂未实现）\n- 程序代码中通过调用`dlog`的方法记录`data log`，`dlog`的方法不能阻塞调用的程序代码的执行（这一点`dlog`暂时未满足要求，需要后期改进）\n- AWS Kinesis提供两个API接收数据，一个是[PutRecord](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html), 另一个是[PutRecords](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecords.html)，为了减少对Kinesis的调用次数，采用后者批量发送`data log`\n    - `PutRecords`对一次调用的`record`数量限制是`500`，每个`record`大小必须小于等于1MB，整个`request`的大小必须小于等于5MB\n    - 每一个Kinesis Stream能够承受的最大TPS和写数据量，与这个stream拥有的shard的数量有关。一个shard支持最大TPS是`1000 records per second`， 写数据量是`1MB per second`\n- 通过单元测试保证功能正确性\n\n\n# 碰到问题及解决方案\n\n## 何时使用`panic`，何时使用`return error`\n\n先看看`panic`和`return error`的执行机制。\n\n### `panic`的执行机制\n\n`panic`会中断当前`goroutine`的执行，如果不对`panic`的错误进行`recover`，那么整个进程都会崩溃。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nfunc main() {\n    go func() {\n        log.Panic(\"some error before work2\")\n        fmt.Println(\"do some work2\")\n    }()\n\n    time.Sleep(time.Second)\n    fmt.Println(\"do some work1\")\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/off1y9tBax)_\n\n可以通过`recover`捕捉当前`goroutine`中`panic`的错误并进行错误处理，整个进程的正常运行不受影响。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nfunc main() {\n    go func() {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"error: %v\", err)\n            }\n        }()\n        log.Panic(\"some error before work2\")\n        fmt.Println(\"do some work2\")\n    }()\n\n    time.Sleep(time.Second)\n    fmt.Println(\"do some work1\")\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/RLWyb813Uw)_\n\n我们可以发现Go语言中的`panic`、`recover`机制，和Java、.NET中的`throw`、`try...catch`机制非常类似。\n\n### `return error`的执行机制\n\n`return error`是利用Go语言函数的多值返回的特性，通过函数的其中一个返回值（一般是第一个或者最后一个），向`caller`返回函数执行过程中产生的异常，其它值返回执行结果。\n\n这种方式的问题，主要在于：如果函数调用层次比较多，每一层函数都通过`return error`方式返回错误，都需要处理被调用函数的`return error`，增加代码复杂度。对于无法恢复的错误也没有必要一层一层往上抛，直接`panic/recover`更加简洁。\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"log\"\n)\n\ntype R struct {\n}\n\nfunc f1() (error, *R) {\n    return errors.New(\"an error\"), nil\n}\n\nfunc f2() (error, *R) {\n    err, r := f1()\n    if err != nil {\n        return err, nil\n    }\n\n    return nil, r\n}\n\nfunc f3() (error, *R) {\n    err, r := f2()\n    if err != nil {\n        return err, nil\n    }\n\n    return nil, r\n}\n\nfunc main() {\n    err, _ := f3()\n    if err != nil {\n        log.Print(err)\n    }\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/GhE5JpzZvn)_\n\n### `dlog`错误处理原则\n\n使用`panic`还是`return error`的方式处理错误，要区分不同的场景。重要是不论使用`panic`还是`return error`，都需要符合架构上更高层面错误处理需求。\n\n`dlog`是一个日志记录`package`，暴露给其它程序调用的方法如下：\n\n- `func NewLogger(example interface{}, opts *Options) (*Logger, error)`\n- `func (l *Logger) Log(msg interface{}) error`\n\n这两个方法的使用场景并不一样，错误处理原则也不完全一致：\n\n- `NewLogger`方法一般是在程序初始化的时候调用，用于创建记录程序运行过程中产生的data log的记录器。通过`NewLogger`创建一个`logger`的时候，如果传入参数不正确，使用`panic`方式，在上层调用程序不处理错误情况下会导致程序崩溃，所以使用`return error`方式向`caller`报告错误。大多数Golang package也是按此原则处理。\n- 上层程序调用`logger.Log`时，如果`Log`方法内部发生的错误，不能影响调用的代码的执行，所以这里绝对不能用`panic`方式抛出错误。日志记录是辅助功能，如果日志记录行为失败，导致业务逻辑代码执行不下去，估计负责业务逻辑开发的工程师会和你拼命。\n    - `logger.Log`可以使用`return error`方式返回`msg`校验类的错误\n    - `logger.Log`发送日志采用的是异步批量方式向AWS Kinesis发送数据，向AWS Kinesis发送数据相关的错误无法通过`panic`或者`return error`方式直接报告给调用程序。最好的方式是允许调用程序向`logger`注册发送失败处理的`handler`，出现发送失败错误时执行`handler`逻辑。（暂未实现）\n\n## 如何实现一个`logger`只能接收对应类型的`data log`\n\n要实现一个`logger`只能接收对应类型的`data log`，主要思路如下：\n\n- `Logger`的定义中通过属性`msgType reflect.Type`记住能够接受的消息类型\n- 通过`NewLogger`方法创建`logger`的时候，指定`logger`可以接受的消息类型\n- `Log`方法中首先校验`msg`的类型是否是创建`logger`时指定的类型\n\n以下是相关代码：\n\n```go\n// msgType保存Logger能够接受的消息类型\ntype Logger struct {\n    ...\n    msgType    reflect.Type\n    ...\n}\n\n// 获得msg的reflect.Type\nfunc msgType(msg interface{}) (reflect.Type, error) {\n    t := reflect.TypeOf(msg)\n\n    if t.Kind() == reflect.Ptr {\n        t = t.Elem()\n    }\n\n    if t.Kind() != reflect.Struct {\n        return nil, fmt.Errorf(\"dlog message must be either *struct or struct\")\n    }\n\n    return t, nil\n}\n\nfunc NewLogger(example interface{}, opts *Options) (*Logger, error) {\n    t, e := msgType(example)\n    if e != nil {\n        return nil, e\n    }\n\n    ...\n\n    l := &Logger{\n        ...\n        msgType:    t,\n        ...\n    }\n\n    ...\n    return l, nil\n}\n\nfunc (l *Logger) Log(msg interface{}) error {\n    if t, e := msgType(msg); e != nil {\n        return e\n    } else if !t.AssignableTo(l.msgType) {\n        return fmt.Errorf(\"parameter (%+v) not assignable to %v\", msg, l.msgType)\n    }\n\n    ...\n}\n```\n\n`Log`方法中为什么要用`AssignableTo`，而不是直接判断两个类型相等。其实都可以，在`msg`是`struct`情况下，`AssignableTo`返回`True`意味着两个类型相等。参考下面的例子：\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"reflect\"\n)\n\nfunc main() {\n    type Fn func(int) int\n    id := func(x int) int {\n        return x\n    }\n    var zeroFn Fn\n    log.Println(reflect.TypeOf(id).AssignableTo(reflect.TypeOf(zeroFn)))\n\n    type MyInt int\n    mi := 1\n    log.Println(reflect.TypeOf(2).AssignableTo(reflect.TypeOf(mi)))\n\n    type S1 struct {\n        name string\n    }\n    type S2 S1\n\n    s1 := S1{\n        name: \"ethan\",\n    }\n    s2 := S2{\n        name: \"ethan\",\n    }\n    // s2 = s1\t// if uncomment this line, will report \"cannot use s1 (type S1) as type S2 in assignment\" when compile\n    log.Println(reflect.TypeOf(s1).AssignableTo(reflect.TypeOf(s2)))\n}\n```\n\n_执行上面代码请点击[这里](https://play.golang.org/p/eDmzxW-ayk)_\n\n## 如何实现批量发送`data log`\n\n要实现批量发送，首先我们可以想到应该要有个`buffer`用来收集一定数量的的`message`，等待`buffer`中的数据积累到一定程度后，一次性发送给AWS Kinesis。设计`buffer`结构不难，难点在于如何解决多线程(goroutine)并发读写`buffer`的问题，主要的解决方案有两种：\n\n- 基于锁机制实现对`buffer`访问控制\n- 基于`channel`实现对`buffer`的访问控制\n\n前者对于有Java、.NET等语言的并发编程经验的工程师来说，非常熟悉。而后者则体现了CSP(Communicating Sequential Processes)并发编程模型的优势。\n\n{% asset_img channel.png CSP Model %}\n\n`dlog`的`Log`方法把收到的`msg`写到名字叫`buffer`的`channel`中，另外一个单独的`goroutine`在`channel`的另一头收集编码后的日志信息，然后保存到`buf := make([][]byte, 0)`中。当`buf`中的数据量要达到一次向AWS Kinesis发送的最大量时，调用`flush`方法向AWS Kinesis发送数据。由于只有一个`goroutine`对`buf`进行访问，所以不需要通过锁机制控制对`buf`的读写。\n\n<!--\ndigraph G {\n    fontname=\"Microsoft YaHei\";\n    fontsize=10;\n    rankdir = LR;\n\n    \"buffer channel\" [shape=box];\n\n    \"Logger.Log goroutine 1\" -> \"buffer channel\";\n    \"Logger.Log goroutine 2\" -> \"buffer channel\";\n    \"Logger.Log goroutine 3\" -> \"buffer channel\";\n    \"buffer channel\" -> \"sync goroutine\";\n    \"sync goroutine\" -> \"AWS Kinesis Stream\";\n}\n-->\n\n<!-- ![Thread Model](http://g.gravizo.com/g?digraph%20G%20%7B%0A%20%20%20%20fontname%3D%22Microsoft%20YaHei%22%3B%0A%20%20%20%20fontsize%3D10%3B%0A%20%20%20%20rankdir%20%3D%20LR%3B%0A%0A%20%20%20%20%22buffer%20channel%22%20%5Bshape%3Dbox%5D%3B%0A%0A%20%20%20%20%22Logger.Log%20goroutine%201%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%202%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%203%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22buffer%20channel%22%20-%3E%20%22sync%20goroutine%22%3B%0A%20%20%20%20%22sync%20goroutine%22%20-%3E%20%22AWS%20Kinesis%20Stream%22%3B%0A%20%7D) -->\n\n{% asset_img use_channel.png 使用Channel %}\n\n具体代码实现：\n\n```go\nfunc NewLogger(example interface{}, opts *Options) (*Logger, error) {\n    ...\n\n    go l.sync()    // 启动sync goroutine\n    return l, nil\n}\n\nfunc (l *Logger) Log(msg interface{}) error {\n    ...\n\n    en := encode(msg)       // 对msg进行编码\n    ...\n        select {\n        case l.buffer <- en:    // 向buffer channel写入编码后的msg\n        ...\n        }\n    ...\n    return nil\n}\n\nfunc (l *Logger) sync() {\n    ...\n\n    buf := make([][]byte, 0) // 用于收集从buffer channel读取的日志数据\n    bufSize := 0\n\n    for {\n        select {\n        case msg := <-l.buffer:\n            if bufSize+len(msg)+partitionKeySize >= maxBatchSize {  // 如果buf的大小接近一次批量发送的最大数据量\n                l.flush(&buf, &bufSize)                             // 向AWS Kinesis批量发送数据\n            }\n\n            buf = append(buf, msg)                                  // 将从buffer channel读取日志数据保存到buf中\n            bufSize += len(msg) + partitionKeySize\n\n        ...\n    }\n}\n```\n\n## 如何实现对`Logger.Log`方法的调用超时机制\n\n如果一个IO操作耗时较长，并且调用比较频繁的情况下，不仅会阻塞`caller`的执行，还会消耗大量系统资源。我们通常会使用超时机制，避免程序长时间等待或者对系统资源大量占用。\n\n`Logger.Log`方法利用Go语言`channel`非常简洁的实现了超时机制：\n\n```go\nfunc (l *Logger) Log(msg interface{}) error {\n    ...\n\n    var timeout <-chan time.Time\n    if l.WriteTimeout > 0 {\n        timeout = time.After(l.WriteTimeout)    // 初始化时长为l.WriteTimeout的计时器\n    }\n\n    ...\n        select {\n        case l.buffer <- en:\n        case <-timeout: // 如果上一行代码一直阻塞，timeout计时器时间到点后会触发执行当前case下的代码\n            return fmt.Errorf(\"dlog writes %+v timeout after %v\", msg, l.WriteTimeout)\n        }\n    ...\n    return nil\n}\n```\n\n对比Java、.NET语言中超时机制的实现方法，Go语言的实现简洁的令人发指：\n\n- C#\n    - [Implementing .Net method timeout](http://weblogs.asp.net/israelio/159985)\n    - [How to implement Task Async for a timer in C#?](http://stackoverflow.com/questions/18646650/how-to-implement-task-async-for-a-timer-in-c)\n    - [Implementing a timeout in c#](http://stackoverflow.com/questions/10143980/implementing-a-timeout-in-c-sharp)\n- Java\n    - [How to implement timeout using threads](http://www.coderanch.com/t/232213/threads/java/implement-timeout-threads)\n    - [How to timeout a thread](http://stackoverflow.com/questions/2275443/how-to-timeout-a-thread)\n\n## 如何在`logger`没有收到新`msg`情况下，保证`buf`中的数据依然会定期发送给AWS Kinesis\n\n`dlog`在`Logger.sync()`方法中通过一个定时器，定期将`buf`中数据发送给AWS Kinesis。\n\n```go\nfunc (l *Logger) sync() {\n    if l.SyncPeriod <= 0 {\n        l.SyncPeriod = time.Second\n    }\n    ticker := time.NewTicker(l.SyncPeriod)  // l.SyncPeriod是定期发送的数据的时间间隔，ticker定时触发器\n\n    buf := make([][]byte, 0)\n    bufSize := 0\n\n    for {  // 无限循环保证sync goroutine一直工作\n        select {\n        case msg := <-l.buffer:\n            ...\n\n        case <-ticker.C: // ticker.C的类型是<-chan Time，每隔l.SyncPeriod时间会触发执行当前case的代码\n            if bufSize > 0 {\n                l.flush(&buf, &bufSize)\n            }\n        }\n    }\n}\n```\n\n通过`ticker`，`dlog`保证了即使没有收到新的`msg`的时候，保存在`buf`中的数据最长`l.SyncPeriod`时间后也会发送给AWS Kinesis。\n\n互联网产品的生产环境的上线，通常的做法是，将现有服务分组，然后交替切流量、升级。如果没有类似的机制，那么在服务程序断掉流量，没有收到新的访问时候，保存在内存中的数据就不会发送出去，升级时就可能导致数据丢失。\n\n## 如何向程序外部暴露运行指标\n\nGo语言的官方Package `expvar`提供一种标准化的接口，允许程序暴露公开访问的变量。`expvar`通过HTTP地址`/debug/vars`提供访问入口，并以JSON格式展示这些变量。下面是关于`expvar`常见用法的一个例子：\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"expvar\"\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\n// Stats is used to collect runtime metrics\ntype Stats struct {\n    sync.Mutex\n    TotalHit  int\n    ErrorNums int\n}\n\nfunc (s *Stats) IncreaseTotalHit(i int) {\n    s.Lock()\n    defer s.Unlock()\n\n    s.TotalHit += i\n}\n\nfunc (s *Stats) IncreaseErrorNums(i int) {\n    s.Lock()\n    defer s.Unlock()\n\n    s.ErrorNums += i\n}\n\nfunc (s *Stats) String() string {\n    s.Lock()\n    defer s.Unlock()\n\n    b, err := json.Marshal(*s)\n    if err != nil {\n        return \"{}\"\n    } else {\n        return string(b)\n    }\n}\n\nvar (\n    stats *Stats\n    hits  *expvar.Map\n)\n\nfunc init() {\n\n    expvar.Publish(\"now\", expvar.Func(func() interface{} {\n        return time.Now().Format(\"\\\"2006-01-02 15:04:05\\\"\")\n    }))\n\n    stats = &Stats{}\n    expvar.Publish(\"stats\", stats)\n\n    hits = expvar.NewMap(\"hits\").Init()\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n    p := r.URL.Path[1:]\n    hits.Add(p, 1)\n    stats.IncreaseTotalHit(1)\n    fmt.Fprintf(w, \"Hey! I love %s! hits: %v\\n\", p, hits.Get(p))\n}\n\nfunc errHandler(w http.ResponseWriter, r *http.Request) {\n    stats.IncreaseErrorNums(1)\n    fmt.Fprintf(w, \"Error Nums: %v\\n\", stats.ErrorNums)\n}\n\nfunc main() {\n    http.HandleFunc(\"/err\", errHandler)\n    http.HandleFunc(\"/\", homeHandler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n按照如下步骤测试运行效果：\n\n- `go run expvarexample.go`运行例子代码\n- 在浏览器中访问`http://localhost:8080/ethan`\n- 在浏览器中访问`http://localhost:8080/err`\n- 在浏览器中访问`http://localhost:8080/debug/vars`，得到如下结果：\n```json\n{\n    \"cmdline\": [\"/var/folders/jf/65ft181j33j_d75ktgv67bsc0000gn/T/go-build467453980/command-line-arguments/_obj/exe/expvarsample\"],\n    \"hits\": {\n        \"ethan\": 1,\n        \"favicon.ico\": 2\n    },\n    \"memstats\": { ... },\n    \"now\": \"\\\"2016-04-19 20:17:40\\\"\",\n    \"stats\": {\n        \"TotalHit\":3,\n        \"ErrorNums\":1\n    }\n}\n```\n\n[expvarmon](https://github.com/divan/expvarmon)是一个帮助查看`expvar`暴露运行指标的工具，用法如下：\n\n- 安装：`go get github.com/divan/expvarmon`\n- 运行：`expvarmon -ports=\"8080\" -vars=\"hits.ethan,stats.TotalHit,stats.ErrorNums,now\"`\n- 效果如下：\n{% asset_img expvarmon_screen.png expvarmon screen %}\n\n`dlog`使用`expvar`向程序外部（比如监控程序）暴露运行指标，目前`dlog`中定义的运行指标包括：\n\n- `writtenRecords`: 成功写到AWS Kinesis的`msg`数量\n- `writtenBatches`: 成功调用AWS Kinesis批量写数据API的次数\n- `failedRecords`: 写到AWS Kinesis失败的`msg`数量\n- `tooBigMesssages`: 编码后体积过大(加上partitionKeySize大于1MB)的`msg`数量\n\n未来还需要根据运维的需求对运行指标进行调整，当前的用法也有一些问题，后期需要重构。\n\n## 如何在单元测试中实现`Setup`和`TearDown`\n\nGo语言提供一种**轻量级**的单元测试框架（无需第三方工具或者程序包）。通过使用`go test`命令和`testing` package，可以非常快速的实现单元测试。先借用官方文档中的[例子](http://docs.studygolang.com/doc/code.html#Testing)回顾一下Go单元测试框架的用法：\n\n```go\n//$GOPATH/src/github.com/user/stringutil/reverse_test.go\npackage stringutil\n\nimport \"testing\"\n\nfunc TestReverse(t *testing.T) {\n    cases := []struct {\n        in, want string\n    }{\n        {\"Hello, world\", \"dlrow ,olleH\"},\n        {\"Hello, 世界\", \"界世 ,olleH\"},\n        {\"\", \"\"},\n    }\n    for _, c := range cases {\n        got := Reverse(c.in)\n        if got != c.want {\n            t.Errorf(\"Reverse(%q) == %q, want %q\", c.in, got, c.want)\n        }\n    }\n}\n```\n\n运行测试只需要简单的输入命令：\n\n```go\n$ go test github.com/user/stringutil\nok  \tgithub.com/user/stringutil 0.165s\n```\n\n很多情况下，要执行单元测试，我们需要依赖一些外部资源，比如已完成初始化数据的数据库、公有云上的一些IaaS服务等。这些依赖资源，我们希望在单元测试执行前，能够自动的被初始化；单元测试完成后，能够自动的被清理。[testify/suite](https://github.com/stretchr/testify/suite) package就提供这样的支持。通过[testify/suite](https://github.com/stretchr/testify/suite)，你可以构建一个测试集`struct`，建立测试集的`setup`(初始化)/`teardown`(清理)方法，和最终实现测试用例逻辑的方法。而运行测试，仍然只需要一句简单的`go test`。\n\n以下是使用[testify/suite](https://github.com/stretchr/testify/suite)实现测试集的常见模式：\n\n```go\npackage suite\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\ntype SuiteTester struct {\n    // Include our basic suite logic.\n    Suite\n\n    // Other properties\n    propertyN string\n}\n\n// The SetupSuite method will be run by testify once, at the very\n// start of the testing suite, before any tests are run.\nfunc (suite *SuiteTester) SetupSuite() {\n    // ...\n}\n\n// The TearDownSuite method will be run by testify once, at the very\n// end of the testing suite, after all tests have been run.\nfunc (suite *SuiteTester) TearDownSuite() {\n    // ...\n}\n\n// The SetupTest method will be run before every test in the suite.\nfunc (suite *SuiteTester) SetupTest() {\n    // ...\n}\n\n// The TearDownTest method will be run after every test in the suite.\nfunc (suite *SuiteTester) TearDownTest() {\n    // ...\n}\n\n// a test method\nfunc (suite *SuiteTester) TestOne() {\n    // ...\n}\n\n// another test method\nfunc (suite *SuiteTester) TestTwo() {\n    // ...\n}\n\n// TestRunSuite will be run by the 'go test' command, so within it, we\n// can run our suite using the Run(*testing.T, TestingSuite) function.\nfunc TestRunSuite(t *testing.T) {\n    suiteTester := new(SuiteTester)\n    Run(t, suiteTester)\n}\n```\n\n`dlog`中为了测试`Logger.Log`方法能否正常工作，按照上面的模式编写了相应的测试代码：\n\n```go\npackage dlog\n\n//...\n\ntype WriteLogSuiteTester struct {\n    suite.Suite\n\n    options     *Options\n    seachLogger *Logger\n    clickLogger *Logger\n    streamNames []string // save the created AWS Kinesis Streams, which will be removed in TearDownSuite()\n}\n\n// The SetupSuite method will be run by testify once, at the very\n// start of the testing suite, before any tests are run.\nfunc (s *WriteLogSuiteTester) SetupSuite() {\n\n    //...\n\n    // create stream 1\n    err = s.seachLogger.kinesis.CreateStream(s.seachLogger.streamName, testingShardCount)\n    s.Nil(err)\n\n    // create stream 2\n    err = s.clickLogger.kinesis.CreateStream(s.clickLogger.streamName, testingShardCount)\n    s.Nil(err)\n\n    s.streamNames = []string{s.seachLogger.streamName, s.clickLogger.streamName}\n\n    for { // waiting created stream's status to be active\n        time.Sleep(1 * time.Second)\n        resp1, err1 := s.seachLogger.kinesis.DescribeStream(s.seachLogger.streamName)\n        s.Nil(err1)\n\n        resp2, err2 := s.seachLogger.kinesis.DescribeStream(s.clickLogger.streamName)\n        s.Nil(err2)\n\n        status1 := strings.ToLower(string(resp1.StreamStatus))\n        status2 := strings.ToLower(string(resp2.StreamStatus))\n        if status1 == \"active\" && status2 == \"active\" {\n            break\n        }\n    }\n}\n\n// The TearDownSuite method will be run by testify once, at the very\n// end of the testing suite, after all tests have been run.\nfunc (s *WriteLogSuiteTester) TearDownSuite() {\n    if s.streamNames == nil || len(s.streamNames) == 0 {\n        return\n    }\n\n    for _, streamName := range s.streamNames {\n        err := s.seachLogger.kinesis.DeleteStream(streamName)\n        s.Nil(err)\n    }\n}\n\nfunc (s *WriteLogSuiteTester) TestWriteLog() {\n    defer func() { // Recover if panicking to make sure TearDownSuite will be executed\n        if r := recover(); r != nil {\n            s.Fail(fmt.Sprint(r))\n        }\n    }()\n\n    //...\n}\n\nfunc TestRunWriteLogSuite(t *testing.T) {\n    suiteTester := new(WriteLogSuiteTester)\n    suite.Run(t, suiteTester)\n}\n```\n\n注：\n\n- 很多场景下，测试程序自动创建依赖的资源需要运维部门的授权，所以实现前有必要先和运维部门沟通。\n- 云环境下，出于安全上的考虑，需要对创建、删除测试资源的账户管理严格管理\n    - 账户信息不能写在可以公开访问的测试代码、配置文件中\n    - 只给账户分配必要资源的最小权限\n    - 为账户能够创建的资源设定配额\n\n## 如何实现`kinesisMock`\n\n上一节我们提到在测试执行前初始化依赖资源，现实场景中，并不是任何情况下都能够获得依赖的测试资源，或者测试资源也会出现不可用的情况。通过Mock技术，可以减少测试代码对其它资源（或模块）的依赖。\n\n`dlog`的测试代码中，首先定义了一个`KinesisInterface`:\n\n```go\ntype KinesisInterface interface {\n    PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error)\n    CreateStream(name string, shardCount int) error\n    DescribeStream(name string) (resp *kinesis.StreamDescription, err error)\n    DeleteStream(name string) error\n}\n```\n\n`KinesisInterface`包含了`dlog`用到的[github.com/AdRoll/goamz/kinesis/kinesis](https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go)的所有方法。因为Go语言`interface`实现**非侵入式**的特点，[github.com/AdRoll/goamz/kinesis/kinesis](https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go)自动实现了`KinesisInterface`，我们再定义一个`kinesisMock`实现`KinesisInterface`：\n\n```go\ntype kinesisMock struct {\n    // Mapping from steam name to batches of batches\n    storage map[string][][]kinesis.PutRecordsRequestEntry\n\n    // simulate lantency that sync to Kinesis\n    putRecordLatency time.Duration\n\n    // created streams' names\n    streamNames []string\n\n    // lock to solve concurrent call\n    lock sync.RWMutex\n}\n\nfunc newKinesisMock(putRecordsLatency time.Duration) *kinesisMock {\n    return &kinesisMock{\n        storage:          make(map[string][][]kinesis.PutRecordsRequestEntry),\n        putRecordLatency: putRecordsLatency,\n        streamNames:      make([]string, 0),\n    }\n}\n\nfunc (mock *kinesisMock) PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error) {\n    // ...\n}\n\nfunc (mock *kinesisMock) CreateStream(name string, shardCount int) error {\n    // ...\n}\n\nfunc (mock *kinesisMock) DescribeStream(name string) (resp *kinesis.StreamDescription, err error) {\n    // ...\n}\n\nfunc (mock *kinesisMock) DeleteStream(name string) error {\n    // ...\n}\n```\n\n然后，把业务代码中所有类型`kinesis`的变量，替换成`KinesisInterface`类型。\n\n```go\ntype Logger struct {\n    //...\n    kinesis    KinesisInterface\n    //...\n}\n```\n\n测试代码中，在构造`Logger`时传入`kinesisMock`，而不是真实的`kinesis`，这样就做到了“狸猫换太子”。\n\n```go\nfunc TestLoggingToMockKinesis(t *testing.T) {\n    assert := assert.New(t)\n\n    l, e := NewLogger(&impression{}, &Options{\n        // ...\n        UseMockKinesis: true,\n        MockKinesis:    newKinesisMock(0),\n    })\n\n    // ...\n}\n```\n\n## 如何模拟AWS Kinesis响应慢或者不可用\n\n`kinesisMock`完全是我们“虚构”出来的一个`kinesis`，在它的基础上，我们完全可以模拟响应慢或者不可用的情况。\n\n上一节中，不知道大家注意到没有，`kinesisMock`有个属性叫`putRecordLatency`，用来模拟调用`PutRecords`方法的延迟时间。\n\n```go\ntype kinesisMock struct {\n    // ...\n\n    // simulate lantency that sync to Kinesis\n    putRecordLatency time.Duration\n\n    // ...\n}\n\nfunc (mock *kinesisMock) PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error) {\n    //...\n\n    time.Sleep(mock.putRecordLatency) // 模拟延迟\n\n    //...\n}\n```\n\n模拟不可用的`kinesis`则重新定义了一个`brokenKinesisMock`：\n\n```go\ntype brokenKinesisMock struct {\n    *kinesisMock\n}\n\nfunc newBrokenKinesisMock() *brokenKinesisMock {\n    return &brokenKinesisMock{\n        kinesisMock: newKinesisMock(0),\n    }\n}\n\nfunc (mock *brokenKinesisMock) PutRecords(streamName string, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err error) {\n    return nil, fmt.Errorf(\"Kinesis is broken\")\n}\n```\n\n`kinesisMock`是`brokenKinesisMock`的嵌入`struct`，`brokenKinesisMock`会自动拥有`kinesisMock`的所有公开方法，这样也就实现了`KinesisInterface`。\n\n## 提交到代码库中的测试代码是否可以保留`log.Print`\n\n结论是“不可以”，原因总结如下：\n\n- 测试代码中的`log.Print`，一般用于调试代码，或者在`stdout`打印出一些信息帮助判断测试失败原因。不论哪种目的，这样的代码目的都仅仅是为了辅助开发，而不应该出现在最终交付的产品代码中。\n- `go test`命令会在控制台输出失败的测试方法，如果加上`-v`标志会打印出所有测试方法的执行结果，`log.Print`会影响执行结果的展示效果。团队合作开发，如果每个人都在测试代码中加上自己的`log.Print`，那么控制台打印出来的测试结果就没法看了。\n\n\n# 踩过的一些坑\n\n- [AWS Kinesis API - CreateStream](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_CreateStream.html)是异步创建Stream，而且耗时10+秒，才能完成一个Stream的创建。开始以为是同步创建，结果执行测试逻辑的时候总是出错。\n- [github.com/AdRoll/goamz/aws/regions.go](https://github.com/AdRoll/goamz/blob/master/aws/regions.go)中缺少中国区AWS Kinesis的URL地址，调用中国区AWS Kinesis会出错。\n- Travis CI会Kill掉执行时间超过1分钟的CI过程，而不是如它文档中介绍的“10分钟”\n\n\n# 未来可以优化的地方\n\n- 发送失败的错误事件机制\n- 实现Kinesis服务不可用或者响应慢的场景下`dlog`的容错处理\n\n\n# 参考\n\n- [Effective Go](http://docs.studygolang.com/doc/effective_go.html)\n- [Amazon Kinesis Documentation](https://aws.amazon.com/cn/documentation/kinesis/)\n- [Advanced Go Concurrency Patterns](http://blog.golang.org/advanced-go-concurrency-patterns)\n- [hystrix-go](https://github.com/afex/hystrix-go)\n\n\n# 招聘消息\n\n我所在的[奥阁门科技有限公司](http://www.augmn.com)正在招聘后端、运维工程师，想加入的朋友、或者有朋友可以推荐的都可以联系我(ethancai@qq.com)。\n\n{% asset_img 2016-04-21_07-12-24.png 办公环境1 %}\n\n{% asset_img 2016-04-21_07-12-40.png 办公环境2 %}\n\n**后端工程师 / Backend Engineer**\n\n职责\n\n- 研讨和设计产品功能特性；\n- 设计研发系统后端的一个或多个独立服务（micro-service）模块；\n- 设计研发业务运营管理系统；\n- Code Review。\n\n要求\n\n- 有良好的编程习惯和代码风格；\n- 精通至少一种后台开发语言，包括但不限于Go、Node.js、C++、Python；\n- 对RESTful、RPC等架构有深刻理解和运用经验；\n- 有丰富的web service、web app开发经验；使用过著名的开源应用框架，并完整阅读过源代码；\n- 对Mysql、Redis、MongoDB或同类数据存储技术有丰富的使用经验；\n- 有提交代码到著名开源库或创建过开源项目者优先；\n- 能熟练查阅英文技术文档；\n- 有开放、坦诚的沟通心态，乐于分享；\n- 5年以上工作经验，3年以上后台系统开发经验。\n\n\n**高级系统运维工程师 / Senior Ops Engineer**\n\n职责\n\n- 负责日常业务系统基础实施（AWS）、网络及各子系统的管理维护。\n- 负责设计并部署相关应用平台，并提出平台的实施、运行报告。\n- 负责配合开发搭建测试平台，协助开发设计、推行、实施和持续改进。\n- 负责相关故障、疑难问题排查处理，编制汇总故障、问题，定期提交汇总报告。\n- 负责网络监控和应急反应，以确保网络系统有7*24小时的持续运作能力。\n- 负责日常系统维护，及监控，提供IT方面的服务和支持，保证系统的稳定。\n\n要求\n\n- 深入理解Linux/Unix操作系统并能熟练使用，了解Linux系统内核，有相关操作系统调优经验优先；\n- 熟悉计算机网络基础知识，了解TCP/IP、HTTP等网络协议；\n- 熟悉系统服务的管理和维护，例如：Nginx、DNS服务器、NTP服务等；\n- 熟悉一种或者多种脚本语言，例如：Shell、Python、Perl 、Ruby等；\n- 熟练掌握Linux管理相关命令行工具，例如：grep、awk、sed、tmux、vim等；\n- 对数据库系统（MySQL）运维管理有一定的了解；\n- 熟悉常见分布式系统系统架构部署管理，熟悉基础设施管理、并具有较强的故障排查和解决问题的能力；\n- 具有 2 年以上中大型互联网系统或亚马逊AWS管理经验者优先；\n- 有DevOps经验者优先；\n- 学习能力和沟通能力较强，具有良好的团队协作精神；\n- 工作中需要胆大心细，具备探索创新精神；\n- 具有良好的文档编写能力；\n- 具有一定的英文技术文档阅读能力。\n","slug":"experiences-about-develop-dlog","published":1,"updated":"2025-04-27T17:04:49.536Z","comments":1,"layout":"post","photos":[],"_id":"cm9zwlzc60007fdjh02midzgz","content":"<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC depthFrom:1 depthTo:2 withLinks:0 updateOnSave:1 orderedList:0 -->\n\n<ul>\n<li>前言</li>\n<li><code>dlog</code>的用途</li>\n<li>对<code>dlog</code>的一些非功能性需求</li>\n<li>碰到问题及解决方案<ul>\n<li>何时使用<code>panic</code>，何时使用<code>return error</code></li>\n<li>如何实现一个<code>logger</code>只能接收对应类型的<code>data log</code></li>\n<li>如何实现批量发送<code>data log</code></li>\n<li>如何实现对<code>Logger.Log</code>方法的调用超时机制</li>\n<li>如何在<code>logger</code>没有收到新<code>msg</code>情况下，保证<code>buf</code>中的数据依然会定期发送给AWS Kinesis</li>\n<li>如何向程序外部暴露运行指标</li>\n<li>如何在单元测试中实现<code>Setup</code>和<code>TearDown</code></li>\n<li>如何实现<code>kinesisMock</code></li>\n<li>如何模拟AWS Kinesis响应慢或者不可用</li>\n<li>提交到代码库中的测试代码是否可以保留<code>log.Print</code></li>\n</ul>\n</li>\n<li>踩过的一些坑</li>\n<li>未来可以优化的地方</li>\n<li>参考</li>\n</ul>\n<!-- /TOC -->\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本文记录了前段时间我和<a href=\"https://segmentfault.com/a/1190000002416822\">王益</a>使用Go语言合作开发一个log组件<a href=\"https://github.com/topicai/dlog\">dlog</a>的过程中学到的一些知识。在整个合作开发的过程中，王益严谨认真的态度，对开发质量的严格要求，给我留下了极其深刻的印象。能够和王益这样的顶级工程师切磋技艺，对我学习Go语言帮助非常大。也谨以此文表达对王益的感谢。</p>\n<blockquote>\n<p>注：本文假设读者已经对Go语法已经有基本了解。</p>\n</blockquote>\n<h1 id=\"dlog的用途\"><a href=\"#dlog的用途\" class=\"headerlink\" title=\"dlog的用途\"></a><code>dlog</code>的用途</h1><p>首先引用项目<strong>readme文档</strong>的第一段文字介绍一下<code>dlog</code>的用途：</p>\n<blockquote>\n<p>dlog is a Go package for distributed structure logging using Amazon AWS Kinesis&#x2F;Firehose.</p>\n</blockquote>\n<p>更多介绍和设计请阅读<a href=\"https://github.com/topicai/dlog/blob/develop/README.md\">readme文档</a></p>\n<p><code>dlog</code>主要是用来记录程序的<code>data log</code>的这样一个Golang package，那什么是<code>data log</code>？这里先简要解释一下。一般程序运行过程中主要产生两类日志：</p>\n<ul>\n<li><code>status log</code>：主要用于帮助调试、定位程序Bug、或者找到性能瓶颈，比如方法调用日志、错误日志、方法执行时间日志等</li>\n<li><code>data log</code>：主要用于记录用户行为，收集的<code>data log</code>用于后期的个性化搜索、智能推荐等，比如搜索行为、点击行为等</li>\n</ul>\n<h1 id=\"对dlog的一些非功能性需求\"><a href=\"#对dlog的一些非功能性需求\" class=\"headerlink\" title=\"对dlog的一些非功能性需求\"></a>对<code>dlog</code>的一些非功能性需求</h1><ul>\n<li>每一种类型的<code>data log</code>对应一种<code>logger</code>，一个<code>logger</code>只能记录对应类型的<code>data log</code></li>\n<li><code>dlog</code>内部发生的错误，不能影响调用的程序代码的执行<ul>\n<li>应考虑到AWS Kinesis服务响应慢或者不可用的场景（暂未实现）</li>\n</ul>\n</li>\n<li>程序代码中通过调用<code>dlog</code>的方法记录<code>data log</code>，<code>dlog</code>的方法不能阻塞调用的程序代码的执行（这一点<code>dlog</code>暂时未满足要求，需要后期改进）</li>\n<li>AWS Kinesis提供两个API接收数据，一个是<a href=\"http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html\">PutRecord</a>, 另一个是<a href=\"http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecords.html\">PutRecords</a>，为了减少对Kinesis的调用次数，采用后者批量发送<code>data log</code><ul>\n<li><code>PutRecords</code>对一次调用的<code>record</code>数量限制是<code>500</code>，每个<code>record</code>大小必须小于等于1MB，整个<code>request</code>的大小必须小于等于5MB</li>\n<li>每一个Kinesis Stream能够承受的最大TPS和写数据量，与这个stream拥有的shard的数量有关。一个shard支持最大TPS是<code>1000 records per second</code>， 写数据量是<code>1MB per second</code></li>\n</ul>\n</li>\n<li>通过单元测试保证功能正确性</li>\n</ul>\n<h1 id=\"碰到问题及解决方案\"><a href=\"#碰到问题及解决方案\" class=\"headerlink\" title=\"碰到问题及解决方案\"></a>碰到问题及解决方案</h1><h2 id=\"何时使用panic，何时使用return-error\"><a href=\"#何时使用panic，何时使用return-error\" class=\"headerlink\" title=\"何时使用panic，何时使用return error\"></a>何时使用<code>panic</code>，何时使用<code>return error</code></h2><p>先看看<code>panic</code>和<code>return error</code>的执行机制。</p>\n<h3 id=\"panic的执行机制\"><a href=\"#panic的执行机制\" class=\"headerlink\" title=\"panic的执行机制\"></a><code>panic</code>的执行机制</h3><p><code>panic</code>会中断当前<code>goroutine</code>的执行，如果不对<code>panic</code>的错误进行<code>recover</code>，那么整个进程都会崩溃。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        log.Panic(<span class=\"string\">&quot;some error before work2&quot;</span>)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;do some work2&quot;</span>)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;do some work1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/off1y9tBax\">这里</a></em></p>\n<p>可以通过<code>recover</code>捕捉当前<code>goroutine</code>中<code>panic</code>的错误并进行错误处理，整个进程的正常运行不受影响。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                log.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        log.Panic(<span class=\"string\">&quot;some error before work2&quot;</span>)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;do some work2&quot;</span>)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;do some work1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/RLWyb813Uw\">这里</a></em></p>\n<p>我们可以发现Go语言中的<code>panic</code>、<code>recover</code>机制，和Java、.NET中的<code>throw</code>、<code>try...catch</code>机制非常类似。</p>\n<h3 id=\"return-error的执行机制\"><a href=\"#return-error的执行机制\" class=\"headerlink\" title=\"return error的执行机制\"></a><code>return error</code>的执行机制</h3><p><code>return error</code>是利用Go语言函数的多值返回的特性，通过函数的其中一个返回值（一般是第一个或者最后一个），向<code>caller</code>返回函数执行过程中产生的异常，其它值返回执行结果。</p>\n<p>这种方式的问题，主要在于：如果函数调用层次比较多，每一层函数都通过<code>return error</code>方式返回错误，都需要处理被调用函数的<code>return error</code>，增加代码复杂度。对于无法恢复的错误也没有必要一层一层往上抛，直接<code>panic/recover</code>更加简洁。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> R <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> (<span class=\"type\">error</span>, *R) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;an error&quot;</span>), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> (<span class=\"type\">error</span>, *R) &#123;</span><br><span class=\"line\">    err, r := f1()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> (<span class=\"type\">error</span>, *R) &#123;</span><br><span class=\"line\">    err, r := f2()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    err, _ := f3()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Print(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/GhE5JpzZvn\">这里</a></em></p>\n<h3 id=\"dlog错误处理原则\"><a href=\"#dlog错误处理原则\" class=\"headerlink\" title=\"dlog错误处理原则\"></a><code>dlog</code>错误处理原则</h3><p>使用<code>panic</code>还是<code>return error</code>的方式处理错误，要区分不同的场景。重要是不论使用<code>panic</code>还是<code>return error</code>，都需要符合架构上更高层面错误处理需求。</p>\n<p><code>dlog</code>是一个日志记录<code>package</code>，暴露给其它程序调用的方法如下：</p>\n<ul>\n<li><code>func NewLogger(example interface&#123;&#125;, opts *Options) (*Logger, error)</code></li>\n<li><code>func (l *Logger) Log(msg interface&#123;&#125;) error</code></li>\n</ul>\n<p>这两个方法的使用场景并不一样，错误处理原则也不完全一致：</p>\n<ul>\n<li><code>NewLogger</code>方法一般是在程序初始化的时候调用，用于创建记录程序运行过程中产生的data log的记录器。通过<code>NewLogger</code>创建一个<code>logger</code>的时候，如果传入参数不正确，使用<code>panic</code>方式，在上层调用程序不处理错误情况下会导致程序崩溃，所以使用<code>return error</code>方式向<code>caller</code>报告错误。大多数Golang package也是按此原则处理。</li>\n<li>上层程序调用<code>logger.Log</code>时，如果<code>Log</code>方法内部发生的错误，不能影响调用的代码的执行，所以这里绝对不能用<code>panic</code>方式抛出错误。日志记录是辅助功能，如果日志记录行为失败，导致业务逻辑代码执行不下去，估计负责业务逻辑开发的工程师会和你拼命。<ul>\n<li><code>logger.Log</code>可以使用<code>return error</code>方式返回<code>msg</code>校验类的错误</li>\n<li><code>logger.Log</code>发送日志采用的是异步批量方式向AWS Kinesis发送数据，向AWS Kinesis发送数据相关的错误无法通过<code>panic</code>或者<code>return error</code>方式直接报告给调用程序。最好的方式是允许调用程序向<code>logger</code>注册发送失败处理的<code>handler</code>，出现发送失败错误时执行<code>handler</code>逻辑。（暂未实现）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何实现一个logger只能接收对应类型的data-log\"><a href=\"#如何实现一个logger只能接收对应类型的data-log\" class=\"headerlink\" title=\"如何实现一个logger只能接收对应类型的data log\"></a>如何实现一个<code>logger</code>只能接收对应类型的<code>data log</code></h2><p>要实现一个<code>logger</code>只能接收对应类型的<code>data log</code>，主要思路如下：</p>\n<ul>\n<li><code>Logger</code>的定义中通过属性<code>msgType reflect.Type</code>记住能够接受的消息类型</li>\n<li>通过<code>NewLogger</code>方法创建<code>logger</code>的时候，指定<code>logger</code>可以接受的消息类型</li>\n<li><code>Log</code>方法中首先校验<code>msg</code>的类型是否是创建<code>logger</code>时指定的类型</li>\n</ul>\n<p>以下是相关代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msgType保存Logger能够接受的消息类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    msgType    reflect.Type</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获得msg的reflect.Type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">msgType</span><span class=\"params\">(msg <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> (reflect.Type, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    t := reflect.TypeOf(msg)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">        t = t.Elem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Kind() != reflect.Struct &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;dlog message must be either *struct or struct&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> t, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLogger</span><span class=\"params\">(example <span class=\"keyword\">interface</span>&#123;&#125;, opts *Options)</span></span> (*Logger, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    t, e := msgType(example)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, e</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    l := &amp;Logger&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        msgType:    t,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Log(msg <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t, e := msgType(msg); e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> !t.AssignableTo(l.msgType) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;parameter (%+v) not assignable to %v&quot;</span>, msg, l.msgType)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Log</code>方法中为什么要用<code>AssignableTo</code>，而不是直接判断两个类型相等。其实都可以，在<code>msg</code>是<code>struct</code>情况下，<code>AssignableTo</code>返回<code>True</code>意味着两个类型相等。参考下面的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> Fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span></span><br><span class=\"line\">    id := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> zeroFn Fn</span><br><span class=\"line\">    log.Println(reflect.TypeOf(id).AssignableTo(reflect.TypeOf(zeroFn)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">type</span> MyInt <span class=\"type\">int</span></span><br><span class=\"line\">    mi := <span class=\"number\">1</span></span><br><span class=\"line\">    log.Println(reflect.TypeOf(<span class=\"number\">2</span>).AssignableTo(reflect.TypeOf(mi)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name <span class=\"type\">string</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> S2 S1</span><br><span class=\"line\"></span><br><span class=\"line\">    s1 := S1&#123;</span><br><span class=\"line\">        name: <span class=\"string\">&quot;ethan&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s2 := S2&#123;</span><br><span class=\"line\">        name: <span class=\"string\">&quot;ethan&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// s2 = s1\t// if uncomment this line, will report &quot;cannot use s1 (type S1) as type S2 in assignment&quot; when compile</span></span><br><span class=\"line\">    log.Println(reflect.TypeOf(s1).AssignableTo(reflect.TypeOf(s2)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/eDmzxW-ayk\">这里</a></em></p>\n<h2 id=\"如何实现批量发送data-log\"><a href=\"#如何实现批量发送data-log\" class=\"headerlink\" title=\"如何实现批量发送data log\"></a>如何实现批量发送<code>data log</code></h2><p>要实现批量发送，首先我们可以想到应该要有个<code>buffer</code>用来收集一定数量的的<code>message</code>，等待<code>buffer</code>中的数据积累到一定程度后，一次性发送给AWS Kinesis。设计<code>buffer</code>结构不难，难点在于如何解决多线程(goroutine)并发读写<code>buffer</code>的问题，主要的解决方案有两种：</p>\n<ul>\n<li>基于锁机制实现对<code>buffer</code>访问控制</li>\n<li>基于<code>channel</code>实现对<code>buffer</code>的访问控制</li>\n</ul>\n<p>前者对于有Java、.NET等语言的并发编程经验的工程师来说，非常熟悉。而后者则体现了CSP(Communicating Sequential Processes)并发编程模型的优势。</p>\n<img src=\"/2016/04/20/experiences-about-develop-dlog/channel.png\" class=\"\" title=\"CSP Model\">\n\n<p><code>dlog</code>的<code>Log</code>方法把收到的<code>msg</code>写到名字叫<code>buffer</code>的<code>channel</code>中，另外一个单独的<code>goroutine</code>在<code>channel</code>的另一头收集编码后的日志信息，然后保存到<code>buf := make([][]byte, 0)</code>中。当<code>buf</code>中的数据量要达到一次向AWS Kinesis发送的最大量时，调用<code>flush</code>方法向AWS Kinesis发送数据。由于只有一个<code>goroutine</code>对<code>buf</code>进行访问，所以不需要通过锁机制控制对<code>buf</code>的读写。</p>\n<!--\ndigraph G {\n    fontname=\"Microsoft YaHei\";\n    fontsize=10;\n    rankdir = LR;\n\n    \"buffer channel\" [shape=box];\n\n    \"Logger.Log goroutine 1\" -> \"buffer channel\";\n    \"Logger.Log goroutine 2\" -> \"buffer channel\";\n    \"Logger.Log goroutine 3\" -> \"buffer channel\";\n    \"buffer channel\" -> \"sync goroutine\";\n    \"sync goroutine\" -> \"AWS Kinesis Stream\";\n}\n-->\n\n<!-- ![Thread Model](http://g.gravizo.com/g?digraph%20G%20%7B%0A%20%20%20%20fontname%3D%22Microsoft%20YaHei%22%3B%0A%20%20%20%20fontsize%3D10%3B%0A%20%20%20%20rankdir%20%3D%20LR%3B%0A%0A%20%20%20%20%22buffer%20channel%22%20%5Bshape%3Dbox%5D%3B%0A%0A%20%20%20%20%22Logger.Log%20goroutine%201%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%202%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%203%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22buffer%20channel%22%20-%3E%20%22sync%20goroutine%22%3B%0A%20%20%20%20%22sync%20goroutine%22%20-%3E%20%22AWS%20Kinesis%20Stream%22%3B%0A%20%7D) -->\n\n<img src=\"/2016/04/20/experiences-about-develop-dlog/use_channel.png\" class=\"\" title=\"使用Channel\">\n\n<p>具体代码实现：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLogger</span><span class=\"params\">(example <span class=\"keyword\">interface</span>&#123;&#125;, opts *Options)</span></span> (*Logger, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">go</span> l.sync()    <span class=\"comment\">// 启动sync goroutine</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> l, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Log(msg <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    en := encode(msg)       <span class=\"comment\">// 对msg进行编码</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> l.buffer &lt;- en:    <span class=\"comment\">// 向buffer channel写入编码后的msg</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> sync() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    buf := <span class=\"built_in\">make</span>([][]<span class=\"type\">byte</span>, <span class=\"number\">0</span>) <span class=\"comment\">// 用于收集从buffer channel读取的日志数据</span></span><br><span class=\"line\">    bufSize := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> msg := &lt;-l.buffer:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> bufSize+<span class=\"built_in\">len</span>(msg)+partitionKeySize &gt;= maxBatchSize &#123;  <span class=\"comment\">// 如果buf的大小接近一次批量发送的最大数据量</span></span><br><span class=\"line\">                l.flush(&amp;buf, &amp;bufSize)                             <span class=\"comment\">// 向AWS Kinesis批量发送数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            buf = <span class=\"built_in\">append</span>(buf, msg)                                  <span class=\"comment\">// 将从buffer channel读取日志数据保存到buf中</span></span><br><span class=\"line\">            bufSize += <span class=\"built_in\">len</span>(msg) + partitionKeySize</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何实现对Logger-Log方法的调用超时机制\"><a href=\"#如何实现对Logger-Log方法的调用超时机制\" class=\"headerlink\" title=\"如何实现对Logger.Log方法的调用超时机制\"></a>如何实现对<code>Logger.Log</code>方法的调用超时机制</h2><p>如果一个IO操作耗时较长，并且调用比较频繁的情况下，不仅会阻塞<code>caller</code>的执行，还会消耗大量系统资源。我们通常会使用超时机制，避免程序长时间等待或者对系统资源大量占用。</p>\n<p><code>Logger.Log</code>方法利用Go语言<code>channel</code>非常简洁的实现了超时机制：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Log(msg <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout &lt;-<span class=\"keyword\">chan</span> time.Time</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l.WriteTimeout &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        timeout = time.After(l.WriteTimeout)    <span class=\"comment\">// 初始化时长为l.WriteTimeout的计时器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> l.buffer &lt;- en:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-timeout: <span class=\"comment\">// 如果上一行代码一直阻塞，timeout计时器时间到点后会触发执行当前case下的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;dlog writes %+v timeout after %v&quot;</span>, msg, l.WriteTimeout)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比Java、.NET语言中超时机制的实现方法，Go语言的实现简洁的令人发指：</p>\n<ul>\n<li>C#<ul>\n<li><a href=\"http://weblogs.asp.net/israelio/159985\">Implementing .Net method timeout</a></li>\n<li><a href=\"http://stackoverflow.com/questions/18646650/how-to-implement-task-async-for-a-timer-in-c\">How to implement Task Async for a timer in C#?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/10143980/implementing-a-timeout-in-c-sharp\">Implementing a timeout in c#</a></li>\n</ul>\n</li>\n<li>Java<ul>\n<li><a href=\"http://www.coderanch.com/t/232213/threads/java/implement-timeout-threads\">How to implement timeout using threads</a></li>\n<li><a href=\"http://stackoverflow.com/questions/2275443/how-to-timeout-a-thread\">How to timeout a thread</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何在logger没有收到新msg情况下，保证buf中的数据依然会定期发送给AWS-Kinesis\"><a href=\"#如何在logger没有收到新msg情况下，保证buf中的数据依然会定期发送给AWS-Kinesis\" class=\"headerlink\" title=\"如何在logger没有收到新msg情况下，保证buf中的数据依然会定期发送给AWS Kinesis\"></a>如何在<code>logger</code>没有收到新<code>msg</code>情况下，保证<code>buf</code>中的数据依然会定期发送给AWS Kinesis</h2><p><code>dlog</code>在<code>Logger.sync()</code>方法中通过一个定时器，定期将<code>buf</code>中数据发送给AWS Kinesis。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> sync() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l.SyncPeriod &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        l.SyncPeriod = time.Second</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ticker := time.NewTicker(l.SyncPeriod)  <span class=\"comment\">// l.SyncPeriod是定期发送的数据的时间间隔，ticker定时触发器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    buf := <span class=\"built_in\">make</span>([][]<span class=\"type\">byte</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    bufSize := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;  <span class=\"comment\">// 无限循环保证sync goroutine一直工作</span></span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> msg := &lt;-l.buffer:</span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-ticker.C: <span class=\"comment\">// ticker.C的类型是&lt;-chan Time，每隔l.SyncPeriod时间会触发执行当前case的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> bufSize &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                l.flush(&amp;buf, &amp;bufSize)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>ticker</code>，<code>dlog</code>保证了即使没有收到新的<code>msg</code>的时候，保存在<code>buf</code>中的数据最长<code>l.SyncPeriod</code>时间后也会发送给AWS Kinesis。</p>\n<p>互联网产品的生产环境的上线，通常的做法是，将现有服务分组，然后交替切流量、升级。如果没有类似的机制，那么在服务程序断掉流量，没有收到新的访问时候，保存在内存中的数据就不会发送出去，升级时就可能导致数据丢失。</p>\n<h2 id=\"如何向程序外部暴露运行指标\"><a href=\"#如何向程序外部暴露运行指标\" class=\"headerlink\" title=\"如何向程序外部暴露运行指标\"></a>如何向程序外部暴露运行指标</h2><p>Go语言的官方Package <code>expvar</code>提供一种标准化的接口，允许程序暴露公开访问的变量。<code>expvar</code>通过HTTP地址<code>/debug/vars</code>提供访问入口，并以JSON格式展示这些变量。下面是关于<code>expvar</code>常见用法的一个例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;expvar&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Stats is used to collect runtime metrics</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Stats <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    sync.Mutex</span><br><span class=\"line\">    TotalHit  <span class=\"type\">int</span></span><br><span class=\"line\">    ErrorNums <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stats)</span></span> IncreaseTotalHit(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    s.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.TotalHit += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stats)</span></span> IncreaseErrorNums(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    s.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.ErrorNums += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stats)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    s.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    b, err := json.Marshal(*s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&#123;&#125;&quot;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">string</span>(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    stats *Stats</span><br><span class=\"line\">    hits  *expvar.Map</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    expvar.Publish(<span class=\"string\">&quot;now&quot;</span>, expvar.Func(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time.Now().Format(<span class=\"string\">&quot;\\&quot;2006-01-02 15:04:05\\&quot;&quot;</span>)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">    stats = &amp;Stats&#123;&#125;</span><br><span class=\"line\">    expvar.Publish(<span class=\"string\">&quot;stats&quot;</span>, stats)</span><br><span class=\"line\"></span><br><span class=\"line\">    hits = expvar.NewMap(<span class=\"string\">&quot;hits&quot;</span>).Init()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">homeHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    p := r.URL.Path[<span class=\"number\">1</span>:]</span><br><span class=\"line\">    hits.Add(p, <span class=\"number\">1</span>)</span><br><span class=\"line\">    stats.IncreaseTotalHit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hey! I love %s! hits: %v\\n&quot;</span>, p, hits.Get(p))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">errHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    stats.IncreaseErrorNums(<span class=\"number\">1</span>)</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Error Nums: %v\\n&quot;</span>, stats.ErrorNums)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/err&quot;</span>, errHandler)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, homeHandler)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照如下步骤测试运行效果：</p>\n<ul>\n<li><code>go run expvarexample.go</code>运行例子代码</li>\n<li>在浏览器中访问<code>http://localhost:8080/ethan</code></li>\n<li>在浏览器中访问<code>http://localhost:8080/err</code></li>\n<li>在浏览器中访问<code>http://localhost:8080/debug/vars</code>，得到如下结果：</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cmdline&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;/var/folders/jf/65ft181j33j_d75ktgv67bsc0000gn/T/go-build467453980/command-line-arguments/_obj/exe/expvarsample&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hits&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;ethan&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;favicon.ico&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;memstats&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> ... <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;now&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;\\&quot;2016-04-19 20:17:40\\&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;stats&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;TotalHit&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;ErrorNums&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/divan/expvarmon\">expvarmon</a>是一个帮助查看<code>expvar</code>暴露运行指标的工具，用法如下：</p>\n<ul>\n<li>安装：<code>go get github.com/divan/expvarmon</code></li>\n<li>运行：<code>expvarmon -ports=&quot;8080&quot; -vars=&quot;hits.ethan,stats.TotalHit,stats.ErrorNums,now&quot;</code></li>\n<li>效果如下：</li>\n</ul>\n<img src=\"/2016/04/20/experiences-about-develop-dlog/expvarmon_screen.png\" class=\"\" title=\"expvarmon screen\">\n\n<p><code>dlog</code>使用<code>expvar</code>向程序外部（比如监控程序）暴露运行指标，目前<code>dlog</code>中定义的运行指标包括：</p>\n<ul>\n<li><code>writtenRecords</code>: 成功写到AWS Kinesis的<code>msg</code>数量</li>\n<li><code>writtenBatches</code>: 成功调用AWS Kinesis批量写数据API的次数</li>\n<li><code>failedRecords</code>: 写到AWS Kinesis失败的<code>msg</code>数量</li>\n<li><code>tooBigMesssages</code>: 编码后体积过大(加上partitionKeySize大于1MB)的<code>msg</code>数量</li>\n</ul>\n<p>未来还需要根据运维的需求对运行指标进行调整，当前的用法也有一些问题，后期需要重构。</p>\n<h2 id=\"如何在单元测试中实现Setup和TearDown\"><a href=\"#如何在单元测试中实现Setup和TearDown\" class=\"headerlink\" title=\"如何在单元测试中实现Setup和TearDown\"></a>如何在单元测试中实现<code>Setup</code>和<code>TearDown</code></h2><p>Go语言提供一种<strong>轻量级</strong>的单元测试框架（无需第三方工具或者程序包）。通过使用<code>go test</code>命令和<code>testing</code> package，可以非常快速的实现单元测试。先借用官方文档中的<a href=\"http://docs.studygolang.com/doc/code.html#Testing\">例子</a>回顾一下Go单元测试框架的用法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$GOPATH/src/github.com/user/stringutil/reverse_test.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> stringutil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestReverse</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    cases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        in, want <span class=\"type\">string</span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;Hello, world&quot;</span>, <span class=\"string\">&quot;dlrow ,olleH&quot;</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;Hello, 世界&quot;</span>, <span class=\"string\">&quot;界世 ,olleH&quot;</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, c := <span class=\"keyword\">range</span> cases &#123;</span><br><span class=\"line\">        got := Reverse(c.in)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> got != c.want &#123;</span><br><span class=\"line\">            t.Errorf(<span class=\"string\">&quot;Reverse(%q) == %q, want %q&quot;</span>, c.in, got, c.want)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行测试只需要简单的输入命令：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> test github.com/user/stringutil</span><br><span class=\"line\">ok  \tgithub.com/user/stringutil <span class=\"number\">0.165</span>s</span><br></pre></td></tr></table></figure>\n\n<p>很多情况下，要执行单元测试，我们需要依赖一些外部资源，比如已完成初始化数据的数据库、公有云上的一些IaaS服务等。这些依赖资源，我们希望在单元测试执行前，能够自动的被初始化；单元测试完成后，能够自动的被清理。<a href=\"https://github.com/stretchr/testify/suite\">testify&#x2F;suite</a> package就提供这样的支持。通过<a href=\"https://github.com/stretchr/testify/suite\">testify&#x2F;suite</a>，你可以构建一个测试集<code>struct</code>，建立测试集的<code>setup</code>(初始化)&#x2F;<code>teardown</code>(清理)方法，和最终实现测试用例逻辑的方法。而运行测试，仍然只需要一句简单的<code>go test</code>。</p>\n<p>以下是使用<a href=\"https://github.com/stretchr/testify/suite\">testify&#x2F;suite</a>实现测试集的常见模式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> suite</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SuiteTester <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Include our basic suite logic.</span></span><br><span class=\"line\">    Suite</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Other properties</span></span><br><span class=\"line\">    propertyN <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SetupSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// start of the testing suite, before any tests are run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> SetupSuite() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The TearDownSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// end of the testing suite, after all tests have been run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TearDownSuite() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SetupTest method will be run before every test in the suite.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> SetupTest() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The TearDownTest method will be run after every test in the suite.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TearDownTest() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a test method</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TestOne() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// another test method</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TestTwo() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TestRunSuite will be run by the &#x27;go test&#x27; command, so within it, we</span></span><br><span class=\"line\"><span class=\"comment\">// can run our suite using the Run(*testing.T, TestingSuite) function.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestRunSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    suiteTester := <span class=\"built_in\">new</span>(SuiteTester)</span><br><span class=\"line\">    Run(t, suiteTester)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dlog</code>中为了测试<code>Logger.Log</code>方法能否正常工作，按照上面的模式编写了相应的测试代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> dlog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> WriteLogSuiteTester <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    suite.Suite</span><br><span class=\"line\"></span><br><span class=\"line\">    options     *Options</span><br><span class=\"line\">    seachLogger *Logger</span><br><span class=\"line\">    clickLogger *Logger</span><br><span class=\"line\">    streamNames []<span class=\"type\">string</span> <span class=\"comment\">// save the created AWS Kinesis Streams, which will be removed in TearDownSuite()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SetupSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// start of the testing suite, before any tests are run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *WriteLogSuiteTester)</span></span> SetupSuite() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// create stream 1</span></span><br><span class=\"line\">    err = s.seachLogger.kinesis.CreateStream(s.seachLogger.streamName, testingShardCount)</span><br><span class=\"line\">    s.Nil(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// create stream 2</span></span><br><span class=\"line\">    err = s.clickLogger.kinesis.CreateStream(s.clickLogger.streamName, testingShardCount)</span><br><span class=\"line\">    s.Nil(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    s.streamNames = []<span class=\"type\">string</span>&#123;s.seachLogger.streamName, s.clickLogger.streamName&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"comment\">// waiting created stream&#x27;s status to be active</span></span><br><span class=\"line\">        time.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">        resp1, err1 := s.seachLogger.kinesis.DescribeStream(s.seachLogger.streamName)</span><br><span class=\"line\">        s.Nil(err1)</span><br><span class=\"line\"></span><br><span class=\"line\">        resp2, err2 := s.seachLogger.kinesis.DescribeStream(s.clickLogger.streamName)</span><br><span class=\"line\">        s.Nil(err2)</span><br><span class=\"line\"></span><br><span class=\"line\">        status1 := strings.ToLower(<span class=\"type\">string</span>(resp1.StreamStatus))</span><br><span class=\"line\">        status2 := strings.ToLower(<span class=\"type\">string</span>(resp2.StreamStatus))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> status1 == <span class=\"string\">&quot;active&quot;</span> &amp;&amp; status2 == <span class=\"string\">&quot;active&quot;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The TearDownSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// end of the testing suite, after all tests have been run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *WriteLogSuiteTester)</span></span> TearDownSuite() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.streamNames == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(s.streamNames) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, streamName := <span class=\"keyword\">range</span> s.streamNames &#123;</span><br><span class=\"line\">        err := s.seachLogger.kinesis.DeleteStream(streamName)</span><br><span class=\"line\">        s.Nil(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *WriteLogSuiteTester)</span></span> TestWriteLog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">// Recover if panicking to make sure TearDownSuite will be executed</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            s.Fail(fmt.Sprint(r))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestRunWriteLogSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    suiteTester := <span class=\"built_in\">new</span>(WriteLogSuiteTester)</span><br><span class=\"line\">    suite.Run(t, suiteTester)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注：</p>\n<ul>\n<li>很多场景下，测试程序自动创建依赖的资源需要运维部门的授权，所以实现前有必要先和运维部门沟通。</li>\n<li>云环境下，出于安全上的考虑，需要对创建、删除测试资源的账户管理严格管理<ul>\n<li>账户信息不能写在可以公开访问的测试代码、配置文件中</li>\n<li>只给账户分配必要资源的最小权限</li>\n<li>为账户能够创建的资源设定配额</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何实现kinesisMock\"><a href=\"#如何实现kinesisMock\" class=\"headerlink\" title=\"如何实现kinesisMock\"></a>如何实现<code>kinesisMock</code></h2><p>上一节我们提到在测试执行前初始化依赖资源，现实场景中，并不是任何情况下都能够获得依赖的测试资源，或者测试资源也会出现不可用的情况。通过Mock技术，可以减少测试代码对其它资源（或模块）的依赖。</p>\n<p><code>dlog</code>的测试代码中，首先定义了一个<code>KinesisInterface</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> KinesisInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>)</span><br><span class=\"line\">    CreateStream(name <span class=\"type\">string</span>, shardCount <span class=\"type\">int</span>) <span class=\"type\">error</span></span><br><span class=\"line\">    DescribeStream(name <span class=\"type\">string</span>) (resp *kinesis.StreamDescription, err <span class=\"type\">error</span>)</span><br><span class=\"line\">    DeleteStream(name <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KinesisInterface</code>包含了<code>dlog</code>用到的<a href=\"https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go\">github.com&#x2F;AdRoll&#x2F;goamz&#x2F;kinesis&#x2F;kinesis</a>的所有方法。因为Go语言<code>interface</code>实现<strong>非侵入式</strong>的特点，<a href=\"https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go\">github.com&#x2F;AdRoll&#x2F;goamz&#x2F;kinesis&#x2F;kinesis</a>自动实现了<code>KinesisInterface</code>，我们再定义一个<code>kinesisMock</code>实现<code>KinesisInterface</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> kinesisMock <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mapping from steam name to batches of batches</span></span><br><span class=\"line\">    storage <span class=\"keyword\">map</span>[<span class=\"type\">string</span>][][]kinesis.PutRecordsRequestEntry</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// simulate lantency that sync to Kinesis</span></span><br><span class=\"line\">    putRecordLatency time.Duration</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// created streams&#x27; names</span></span><br><span class=\"line\">    streamNames []<span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lock to solve concurrent call</span></span><br><span class=\"line\">    lock sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newKinesisMock</span><span class=\"params\">(putRecordsLatency time.Duration)</span></span> *kinesisMock &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;kinesisMock&#123;</span><br><span class=\"line\">        storage:          <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>][][]kinesis.PutRecordsRequestEntry),</span><br><span class=\"line\">        putRecordLatency: putRecordsLatency,</span><br><span class=\"line\">        streamNames:      <span class=\"built_in\">make</span>([]<span class=\"type\">string</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> CreateStream(name <span class=\"type\">string</span>, shardCount <span class=\"type\">int</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> DescribeStream(name <span class=\"type\">string</span>) (resp *kinesis.StreamDescription, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> DeleteStream(name <span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，把业务代码中所有类型<code>kinesis</code>的变量，替换成<code>KinesisInterface</code>类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    kinesis    KinesisInterface</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码中，在构造<code>Logger</code>时传入<code>kinesisMock</code>，而不是真实的<code>kinesis</code>，这样就做到了“狸猫换太子”。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestLoggingToMockKinesis</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    assert := assert.New(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    l, e := NewLogger(&amp;impression&#123;&#125;, &amp;Options&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        UseMockKinesis: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        MockKinesis:    newKinesisMock(<span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何模拟AWS-Kinesis响应慢或者不可用\"><a href=\"#如何模拟AWS-Kinesis响应慢或者不可用\" class=\"headerlink\" title=\"如何模拟AWS Kinesis响应慢或者不可用\"></a>如何模拟AWS Kinesis响应慢或者不可用</h2><p><code>kinesisMock</code>完全是我们“虚构”出来的一个<code>kinesis</code>，在它的基础上，我们完全可以模拟响应慢或者不可用的情况。</p>\n<p>上一节中，不知道大家注意到没有，<code>kinesisMock</code>有个属性叫<code>putRecordLatency</code>，用来模拟调用<code>PutRecords</code>方法的延迟时间。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> kinesisMock <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// simulate lantency that sync to Kinesis</span></span><br><span class=\"line\">    putRecordLatency time.Duration</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(mock.putRecordLatency) <span class=\"comment\">// 模拟延迟</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>模拟不可用的<code>kinesis</code>则重新定义了一个<code>brokenKinesisMock</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> brokenKinesisMock <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    *kinesisMock</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newBrokenKinesisMock</span><span class=\"params\">()</span></span> *brokenKinesisMock &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;brokenKinesisMock&#123;</span><br><span class=\"line\">        kinesisMock: newKinesisMock(<span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *brokenKinesisMock)</span></span> PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;Kinesis is broken&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>kinesisMock</code>是<code>brokenKinesisMock</code>的嵌入<code>struct</code>，<code>brokenKinesisMock</code>会自动拥有<code>kinesisMock</code>的所有公开方法，这样也就实现了<code>KinesisInterface</code>。</p>\n<h2 id=\"提交到代码库中的测试代码是否可以保留log-Print\"><a href=\"#提交到代码库中的测试代码是否可以保留log-Print\" class=\"headerlink\" title=\"提交到代码库中的测试代码是否可以保留log.Print\"></a>提交到代码库中的测试代码是否可以保留<code>log.Print</code></h2><p>结论是“不可以”，原因总结如下：</p>\n<ul>\n<li>测试代码中的<code>log.Print</code>，一般用于调试代码，或者在<code>stdout</code>打印出一些信息帮助判断测试失败原因。不论哪种目的，这样的代码目的都仅仅是为了辅助开发，而不应该出现在最终交付的产品代码中。</li>\n<li><code>go test</code>命令会在控制台输出失败的测试方法，如果加上<code>-v</code>标志会打印出所有测试方法的执行结果，<code>log.Print</code>会影响执行结果的展示效果。团队合作开发，如果每个人都在测试代码中加上自己的<code>log.Print</code>，那么控制台打印出来的测试结果就没法看了。</li>\n</ul>\n<h1 id=\"踩过的一些坑\"><a href=\"#踩过的一些坑\" class=\"headerlink\" title=\"踩过的一些坑\"></a>踩过的一些坑</h1><ul>\n<li><a href=\"http://docs.aws.amazon.com/kinesis/latest/APIReference/API_CreateStream.html\">AWS Kinesis API - CreateStream</a>是异步创建Stream，而且耗时10+秒，才能完成一个Stream的创建。开始以为是同步创建，结果执行测试逻辑的时候总是出错。</li>\n<li><a href=\"https://github.com/AdRoll/goamz/blob/master/aws/regions.go\">github.com&#x2F;AdRoll&#x2F;goamz&#x2F;aws&#x2F;regions.go</a>中缺少中国区AWS Kinesis的URL地址，调用中国区AWS Kinesis会出错。</li>\n<li>Travis CI会Kill掉执行时间超过1分钟的CI过程，而不是如它文档中介绍的“10分钟”</li>\n</ul>\n<h1 id=\"未来可以优化的地方\"><a href=\"#未来可以优化的地方\" class=\"headerlink\" title=\"未来可以优化的地方\"></a>未来可以优化的地方</h1><ul>\n<li>发送失败的错误事件机制</li>\n<li>实现Kinesis服务不可用或者响应慢的场景下<code>dlog</code>的容错处理</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://docs.studygolang.com/doc/effective_go.html\">Effective Go</a></li>\n<li><a href=\"https://aws.amazon.com/cn/documentation/kinesis/\">Amazon Kinesis Documentation</a></li>\n<li><a href=\"http://blog.golang.org/advanced-go-concurrency-patterns\">Advanced Go Concurrency Patterns</a></li>\n<li><a href=\"https://github.com/afex/hystrix-go\">hystrix-go</a></li>\n</ul>\n<h1 id=\"招聘消息\"><a href=\"#招聘消息\" class=\"headerlink\" title=\"招聘消息\"></a>招聘消息</h1><p>我所在的<a href=\"http://www.augmn.com/\">奥阁门科技有限公司</a>正在招聘后端、运维工程师，想加入的朋友、或者有朋友可以推荐的都可以联系我(<a href=\"mailto:&#x65;&#x74;&#104;&#x61;&#110;&#99;&#x61;&#105;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;\">ethancai@qq.com</a>)。</p>\n<img src=\"/2016/04/20/experiences-about-develop-dlog/2016-04-21_07-12-24.png\" class=\"\" title=\"办公环境1\">\n\n<img src=\"/2016/04/20/experiences-about-develop-dlog/2016-04-21_07-12-40.png\" class=\"\" title=\"办公环境2\">\n\n<p><strong>后端工程师 &#x2F; Backend Engineer</strong></p>\n<p>职责</p>\n<ul>\n<li>研讨和设计产品功能特性；</li>\n<li>设计研发系统后端的一个或多个独立服务（micro-service）模块；</li>\n<li>设计研发业务运营管理系统；</li>\n<li>Code Review。</li>\n</ul>\n<p>要求</p>\n<ul>\n<li>有良好的编程习惯和代码风格；</li>\n<li>精通至少一种后台开发语言，包括但不限于Go、Node.js、C++、Python；</li>\n<li>对RESTful、RPC等架构有深刻理解和运用经验；</li>\n<li>有丰富的web service、web app开发经验；使用过著名的开源应用框架，并完整阅读过源代码；</li>\n<li>对Mysql、Redis、MongoDB或同类数据存储技术有丰富的使用经验；</li>\n<li>有提交代码到著名开源库或创建过开源项目者优先；</li>\n<li>能熟练查阅英文技术文档；</li>\n<li>有开放、坦诚的沟通心态，乐于分享；</li>\n<li>5年以上工作经验，3年以上后台系统开发经验。</li>\n</ul>\n<p><strong>高级系统运维工程师 &#x2F; Senior Ops Engineer</strong></p>\n<p>职责</p>\n<ul>\n<li>负责日常业务系统基础实施（AWS）、网络及各子系统的管理维护。</li>\n<li>负责设计并部署相关应用平台，并提出平台的实施、运行报告。</li>\n<li>负责配合开发搭建测试平台，协助开发设计、推行、实施和持续改进。</li>\n<li>负责相关故障、疑难问题排查处理，编制汇总故障、问题，定期提交汇总报告。</li>\n<li>负责网络监控和应急反应，以确保网络系统有7*24小时的持续运作能力。</li>\n<li>负责日常系统维护，及监控，提供IT方面的服务和支持，保证系统的稳定。</li>\n</ul>\n<p>要求</p>\n<ul>\n<li>深入理解Linux&#x2F;Unix操作系统并能熟练使用，了解Linux系统内核，有相关操作系统调优经验优先；</li>\n<li>熟悉计算机网络基础知识，了解TCP&#x2F;IP、HTTP等网络协议；</li>\n<li>熟悉系统服务的管理和维护，例如：Nginx、DNS服务器、NTP服务等；</li>\n<li>熟悉一种或者多种脚本语言，例如：Shell、Python、Perl 、Ruby等；</li>\n<li>熟练掌握Linux管理相关命令行工具，例如：grep、awk、sed、tmux、vim等；</li>\n<li>对数据库系统（MySQL）运维管理有一定的了解；</li>\n<li>熟悉常见分布式系统系统架构部署管理，熟悉基础设施管理、并具有较强的故障排查和解决问题的能力；</li>\n<li>具有 2 年以上中大型互联网系统或亚马逊AWS管理经验者优先；</li>\n<li>有DevOps经验者优先；</li>\n<li>学习能力和沟通能力较强，具有良好的团队协作精神；</li>\n<li>工作中需要胆大心细，具备探索创新精神；</li>\n<li>具有良好的文档编写能力；</li>\n<li>具有一定的英文技术文档阅读能力。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC depthFrom:1 depthTo:2 withLinks:0 updateOnSave:1 orderedList:0 -->\n\n<ul>\n<li>前言</li>\n<li><code>dlog</code>的用途</li>\n<li>对<code>dlog</code>的一些非功能性需求</li>\n<li>碰到问题及解决方案<ul>\n<li>何时使用<code>panic</code>，何时使用<code>return error</code></li>\n<li>如何实现一个<code>logger</code>只能接收对应类型的<code>data log</code></li>\n<li>如何实现批量发送<code>data log</code></li>\n<li>如何实现对<code>Logger.Log</code>方法的调用超时机制</li>\n<li>如何在<code>logger</code>没有收到新<code>msg</code>情况下，保证<code>buf</code>中的数据依然会定期发送给AWS Kinesis</li>\n<li>如何向程序外部暴露运行指标</li>\n<li>如何在单元测试中实现<code>Setup</code>和<code>TearDown</code></li>\n<li>如何实现<code>kinesisMock</code></li>\n<li>如何模拟AWS Kinesis响应慢或者不可用</li>\n<li>提交到代码库中的测试代码是否可以保留<code>log.Print</code></li>\n</ul>\n</li>\n<li>踩过的一些坑</li>\n<li>未来可以优化的地方</li>\n<li>参考</li>\n</ul>\n<!-- /TOC -->\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本文记录了前段时间我和<a href=\"https://segmentfault.com/a/1190000002416822\">王益</a>使用Go语言合作开发一个log组件<a href=\"https://github.com/topicai/dlog\">dlog</a>的过程中学到的一些知识。在整个合作开发的过程中，王益严谨认真的态度，对开发质量的严格要求，给我留下了极其深刻的印象。能够和王益这样的顶级工程师切磋技艺，对我学习Go语言帮助非常大。也谨以此文表达对王益的感谢。</p>\n<blockquote>\n<p>注：本文假设读者已经对Go语法已经有基本了解。</p>\n</blockquote>\n<h1 id=\"dlog的用途\"><a href=\"#dlog的用途\" class=\"headerlink\" title=\"dlog的用途\"></a><code>dlog</code>的用途</h1><p>首先引用项目<strong>readme文档</strong>的第一段文字介绍一下<code>dlog</code>的用途：</p>\n<blockquote>\n<p>dlog is a Go package for distributed structure logging using Amazon AWS Kinesis&#x2F;Firehose.</p>\n</blockquote>\n<p>更多介绍和设计请阅读<a href=\"https://github.com/topicai/dlog/blob/develop/README.md\">readme文档</a></p>\n<p><code>dlog</code>主要是用来记录程序的<code>data log</code>的这样一个Golang package，那什么是<code>data log</code>？这里先简要解释一下。一般程序运行过程中主要产生两类日志：</p>\n<ul>\n<li><code>status log</code>：主要用于帮助调试、定位程序Bug、或者找到性能瓶颈，比如方法调用日志、错误日志、方法执行时间日志等</li>\n<li><code>data log</code>：主要用于记录用户行为，收集的<code>data log</code>用于后期的个性化搜索、智能推荐等，比如搜索行为、点击行为等</li>\n</ul>\n<h1 id=\"对dlog的一些非功能性需求\"><a href=\"#对dlog的一些非功能性需求\" class=\"headerlink\" title=\"对dlog的一些非功能性需求\"></a>对<code>dlog</code>的一些非功能性需求</h1><ul>\n<li>每一种类型的<code>data log</code>对应一种<code>logger</code>，一个<code>logger</code>只能记录对应类型的<code>data log</code></li>\n<li><code>dlog</code>内部发生的错误，不能影响调用的程序代码的执行<ul>\n<li>应考虑到AWS Kinesis服务响应慢或者不可用的场景（暂未实现）</li>\n</ul>\n</li>\n<li>程序代码中通过调用<code>dlog</code>的方法记录<code>data log</code>，<code>dlog</code>的方法不能阻塞调用的程序代码的执行（这一点<code>dlog</code>暂时未满足要求，需要后期改进）</li>\n<li>AWS Kinesis提供两个API接收数据，一个是<a href=\"http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html\">PutRecord</a>, 另一个是<a href=\"http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecords.html\">PutRecords</a>，为了减少对Kinesis的调用次数，采用后者批量发送<code>data log</code><ul>\n<li><code>PutRecords</code>对一次调用的<code>record</code>数量限制是<code>500</code>，每个<code>record</code>大小必须小于等于1MB，整个<code>request</code>的大小必须小于等于5MB</li>\n<li>每一个Kinesis Stream能够承受的最大TPS和写数据量，与这个stream拥有的shard的数量有关。一个shard支持最大TPS是<code>1000 records per second</code>， 写数据量是<code>1MB per second</code></li>\n</ul>\n</li>\n<li>通过单元测试保证功能正确性</li>\n</ul>\n<h1 id=\"碰到问题及解决方案\"><a href=\"#碰到问题及解决方案\" class=\"headerlink\" title=\"碰到问题及解决方案\"></a>碰到问题及解决方案</h1><h2 id=\"何时使用panic，何时使用return-error\"><a href=\"#何时使用panic，何时使用return-error\" class=\"headerlink\" title=\"何时使用panic，何时使用return error\"></a>何时使用<code>panic</code>，何时使用<code>return error</code></h2><p>先看看<code>panic</code>和<code>return error</code>的执行机制。</p>\n<h3 id=\"panic的执行机制\"><a href=\"#panic的执行机制\" class=\"headerlink\" title=\"panic的执行机制\"></a><code>panic</code>的执行机制</h3><p><code>panic</code>会中断当前<code>goroutine</code>的执行，如果不对<code>panic</code>的错误进行<code>recover</code>，那么整个进程都会崩溃。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        log.Panic(<span class=\"string\">&quot;some error before work2&quot;</span>)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;do some work2&quot;</span>)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;do some work1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/off1y9tBax\">这里</a></em></p>\n<p>可以通过<code>recover</code>捕捉当前<code>goroutine</code>中<code>panic</code>的错误并进行错误处理，整个进程的正常运行不受影响。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                log.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        log.Panic(<span class=\"string\">&quot;some error before work2&quot;</span>)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;do some work2&quot;</span>)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;do some work1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/RLWyb813Uw\">这里</a></em></p>\n<p>我们可以发现Go语言中的<code>panic</code>、<code>recover</code>机制，和Java、.NET中的<code>throw</code>、<code>try...catch</code>机制非常类似。</p>\n<h3 id=\"return-error的执行机制\"><a href=\"#return-error的执行机制\" class=\"headerlink\" title=\"return error的执行机制\"></a><code>return error</code>的执行机制</h3><p><code>return error</code>是利用Go语言函数的多值返回的特性，通过函数的其中一个返回值（一般是第一个或者最后一个），向<code>caller</code>返回函数执行过程中产生的异常，其它值返回执行结果。</p>\n<p>这种方式的问题，主要在于：如果函数调用层次比较多，每一层函数都通过<code>return error</code>方式返回错误，都需要处理被调用函数的<code>return error</code>，增加代码复杂度。对于无法恢复的错误也没有必要一层一层往上抛，直接<code>panic/recover</code>更加简洁。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> R <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> (<span class=\"type\">error</span>, *R) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;an error&quot;</span>), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> (<span class=\"type\">error</span>, *R) &#123;</span><br><span class=\"line\">    err, r := f1()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> (<span class=\"type\">error</span>, *R) &#123;</span><br><span class=\"line\">    err, r := f2()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    err, _ := f3()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Print(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/GhE5JpzZvn\">这里</a></em></p>\n<h3 id=\"dlog错误处理原则\"><a href=\"#dlog错误处理原则\" class=\"headerlink\" title=\"dlog错误处理原则\"></a><code>dlog</code>错误处理原则</h3><p>使用<code>panic</code>还是<code>return error</code>的方式处理错误，要区分不同的场景。重要是不论使用<code>panic</code>还是<code>return error</code>，都需要符合架构上更高层面错误处理需求。</p>\n<p><code>dlog</code>是一个日志记录<code>package</code>，暴露给其它程序调用的方法如下：</p>\n<ul>\n<li><code>func NewLogger(example interface&#123;&#125;, opts *Options) (*Logger, error)</code></li>\n<li><code>func (l *Logger) Log(msg interface&#123;&#125;) error</code></li>\n</ul>\n<p>这两个方法的使用场景并不一样，错误处理原则也不完全一致：</p>\n<ul>\n<li><code>NewLogger</code>方法一般是在程序初始化的时候调用，用于创建记录程序运行过程中产生的data log的记录器。通过<code>NewLogger</code>创建一个<code>logger</code>的时候，如果传入参数不正确，使用<code>panic</code>方式，在上层调用程序不处理错误情况下会导致程序崩溃，所以使用<code>return error</code>方式向<code>caller</code>报告错误。大多数Golang package也是按此原则处理。</li>\n<li>上层程序调用<code>logger.Log</code>时，如果<code>Log</code>方法内部发生的错误，不能影响调用的代码的执行，所以这里绝对不能用<code>panic</code>方式抛出错误。日志记录是辅助功能，如果日志记录行为失败，导致业务逻辑代码执行不下去，估计负责业务逻辑开发的工程师会和你拼命。<ul>\n<li><code>logger.Log</code>可以使用<code>return error</code>方式返回<code>msg</code>校验类的错误</li>\n<li><code>logger.Log</code>发送日志采用的是异步批量方式向AWS Kinesis发送数据，向AWS Kinesis发送数据相关的错误无法通过<code>panic</code>或者<code>return error</code>方式直接报告给调用程序。最好的方式是允许调用程序向<code>logger</code>注册发送失败处理的<code>handler</code>，出现发送失败错误时执行<code>handler</code>逻辑。（暂未实现）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何实现一个logger只能接收对应类型的data-log\"><a href=\"#如何实现一个logger只能接收对应类型的data-log\" class=\"headerlink\" title=\"如何实现一个logger只能接收对应类型的data log\"></a>如何实现一个<code>logger</code>只能接收对应类型的<code>data log</code></h2><p>要实现一个<code>logger</code>只能接收对应类型的<code>data log</code>，主要思路如下：</p>\n<ul>\n<li><code>Logger</code>的定义中通过属性<code>msgType reflect.Type</code>记住能够接受的消息类型</li>\n<li>通过<code>NewLogger</code>方法创建<code>logger</code>的时候，指定<code>logger</code>可以接受的消息类型</li>\n<li><code>Log</code>方法中首先校验<code>msg</code>的类型是否是创建<code>logger</code>时指定的类型</li>\n</ul>\n<p>以下是相关代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msgType保存Logger能够接受的消息类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    msgType    reflect.Type</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获得msg的reflect.Type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">msgType</span><span class=\"params\">(msg <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> (reflect.Type, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    t := reflect.TypeOf(msg)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">        t = t.Elem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Kind() != reflect.Struct &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;dlog message must be either *struct or struct&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> t, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLogger</span><span class=\"params\">(example <span class=\"keyword\">interface</span>&#123;&#125;, opts *Options)</span></span> (*Logger, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    t, e := msgType(example)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, e</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    l := &amp;Logger&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        msgType:    t,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Log(msg <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t, e := msgType(msg); e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> !t.AssignableTo(l.msgType) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;parameter (%+v) not assignable to %v&quot;</span>, msg, l.msgType)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Log</code>方法中为什么要用<code>AssignableTo</code>，而不是直接判断两个类型相等。其实都可以，在<code>msg</code>是<code>struct</code>情况下，<code>AssignableTo</code>返回<code>True</code>意味着两个类型相等。参考下面的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> Fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span></span><br><span class=\"line\">    id := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> zeroFn Fn</span><br><span class=\"line\">    log.Println(reflect.TypeOf(id).AssignableTo(reflect.TypeOf(zeroFn)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">type</span> MyInt <span class=\"type\">int</span></span><br><span class=\"line\">    mi := <span class=\"number\">1</span></span><br><span class=\"line\">    log.Println(reflect.TypeOf(<span class=\"number\">2</span>).AssignableTo(reflect.TypeOf(mi)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name <span class=\"type\">string</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> S2 S1</span><br><span class=\"line\"></span><br><span class=\"line\">    s1 := S1&#123;</span><br><span class=\"line\">        name: <span class=\"string\">&quot;ethan&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s2 := S2&#123;</span><br><span class=\"line\">        name: <span class=\"string\">&quot;ethan&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// s2 = s1\t// if uncomment this line, will report &quot;cannot use s1 (type S1) as type S2 in assignment&quot; when compile</span></span><br><span class=\"line\">    log.Println(reflect.TypeOf(s1).AssignableTo(reflect.TypeOf(s2)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>执行上面代码请点击<a href=\"https://play.golang.org/p/eDmzxW-ayk\">这里</a></em></p>\n<h2 id=\"如何实现批量发送data-log\"><a href=\"#如何实现批量发送data-log\" class=\"headerlink\" title=\"如何实现批量发送data log\"></a>如何实现批量发送<code>data log</code></h2><p>要实现批量发送，首先我们可以想到应该要有个<code>buffer</code>用来收集一定数量的的<code>message</code>，等待<code>buffer</code>中的数据积累到一定程度后，一次性发送给AWS Kinesis。设计<code>buffer</code>结构不难，难点在于如何解决多线程(goroutine)并发读写<code>buffer</code>的问题，主要的解决方案有两种：</p>\n<ul>\n<li>基于锁机制实现对<code>buffer</code>访问控制</li>\n<li>基于<code>channel</code>实现对<code>buffer</code>的访问控制</li>\n</ul>\n<p>前者对于有Java、.NET等语言的并发编程经验的工程师来说，非常熟悉。而后者则体现了CSP(Communicating Sequential Processes)并发编程模型的优势。</p>\n<img src=\"/2016/04/20/experiences-about-develop-dlog/channel.png\" class=\"\" title=\"CSP Model\">\n\n<p><code>dlog</code>的<code>Log</code>方法把收到的<code>msg</code>写到名字叫<code>buffer</code>的<code>channel</code>中，另外一个单独的<code>goroutine</code>在<code>channel</code>的另一头收集编码后的日志信息，然后保存到<code>buf := make([][]byte, 0)</code>中。当<code>buf</code>中的数据量要达到一次向AWS Kinesis发送的最大量时，调用<code>flush</code>方法向AWS Kinesis发送数据。由于只有一个<code>goroutine</code>对<code>buf</code>进行访问，所以不需要通过锁机制控制对<code>buf</code>的读写。</p>\n<!--\ndigraph G {\n    fontname=\"Microsoft YaHei\";\n    fontsize=10;\n    rankdir = LR;\n\n    \"buffer channel\" [shape=box];\n\n    \"Logger.Log goroutine 1\" -> \"buffer channel\";\n    \"Logger.Log goroutine 2\" -> \"buffer channel\";\n    \"Logger.Log goroutine 3\" -> \"buffer channel\";\n    \"buffer channel\" -> \"sync goroutine\";\n    \"sync goroutine\" -> \"AWS Kinesis Stream\";\n}\n-->\n\n<!-- ![Thread Model](http://g.gravizo.com/g?digraph%20G%20%7B%0A%20%20%20%20fontname%3D%22Microsoft%20YaHei%22%3B%0A%20%20%20%20fontsize%3D10%3B%0A%20%20%20%20rankdir%20%3D%20LR%3B%0A%0A%20%20%20%20%22buffer%20channel%22%20%5Bshape%3Dbox%5D%3B%0A%0A%20%20%20%20%22Logger.Log%20goroutine%201%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%202%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22Logger.Log%20goroutine%203%22%20-%3E%20%22buffer%20channel%22%3B%0A%20%20%20%20%22buffer%20channel%22%20-%3E%20%22sync%20goroutine%22%3B%0A%20%20%20%20%22sync%20goroutine%22%20-%3E%20%22AWS%20Kinesis%20Stream%22%3B%0A%20%7D) -->\n\n<img src=\"/2016/04/20/experiences-about-develop-dlog/use_channel.png\" class=\"\" title=\"使用Channel\">\n\n<p>具体代码实现：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLogger</span><span class=\"params\">(example <span class=\"keyword\">interface</span>&#123;&#125;, opts *Options)</span></span> (*Logger, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">go</span> l.sync()    <span class=\"comment\">// 启动sync goroutine</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> l, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Log(msg <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    en := encode(msg)       <span class=\"comment\">// 对msg进行编码</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> l.buffer &lt;- en:    <span class=\"comment\">// 向buffer channel写入编码后的msg</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> sync() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    buf := <span class=\"built_in\">make</span>([][]<span class=\"type\">byte</span>, <span class=\"number\">0</span>) <span class=\"comment\">// 用于收集从buffer channel读取的日志数据</span></span><br><span class=\"line\">    bufSize := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> msg := &lt;-l.buffer:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> bufSize+<span class=\"built_in\">len</span>(msg)+partitionKeySize &gt;= maxBatchSize &#123;  <span class=\"comment\">// 如果buf的大小接近一次批量发送的最大数据量</span></span><br><span class=\"line\">                l.flush(&amp;buf, &amp;bufSize)                             <span class=\"comment\">// 向AWS Kinesis批量发送数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            buf = <span class=\"built_in\">append</span>(buf, msg)                                  <span class=\"comment\">// 将从buffer channel读取日志数据保存到buf中</span></span><br><span class=\"line\">            bufSize += <span class=\"built_in\">len</span>(msg) + partitionKeySize</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何实现对Logger-Log方法的调用超时机制\"><a href=\"#如何实现对Logger-Log方法的调用超时机制\" class=\"headerlink\" title=\"如何实现对Logger.Log方法的调用超时机制\"></a>如何实现对<code>Logger.Log</code>方法的调用超时机制</h2><p>如果一个IO操作耗时较长，并且调用比较频繁的情况下，不仅会阻塞<code>caller</code>的执行，还会消耗大量系统资源。我们通常会使用超时机制，避免程序长时间等待或者对系统资源大量占用。</p>\n<p><code>Logger.Log</code>方法利用Go语言<code>channel</code>非常简洁的实现了超时机制：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Log(msg <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout &lt;-<span class=\"keyword\">chan</span> time.Time</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l.WriteTimeout &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        timeout = time.After(l.WriteTimeout)    <span class=\"comment\">// 初始化时长为l.WriteTimeout的计时器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> l.buffer &lt;- en:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-timeout: <span class=\"comment\">// 如果上一行代码一直阻塞，timeout计时器时间到点后会触发执行当前case下的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;dlog writes %+v timeout after %v&quot;</span>, msg, l.WriteTimeout)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比Java、.NET语言中超时机制的实现方法，Go语言的实现简洁的令人发指：</p>\n<ul>\n<li>C#<ul>\n<li><a href=\"http://weblogs.asp.net/israelio/159985\">Implementing .Net method timeout</a></li>\n<li><a href=\"http://stackoverflow.com/questions/18646650/how-to-implement-task-async-for-a-timer-in-c\">How to implement Task Async for a timer in C#?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/10143980/implementing-a-timeout-in-c-sharp\">Implementing a timeout in c#</a></li>\n</ul>\n</li>\n<li>Java<ul>\n<li><a href=\"http://www.coderanch.com/t/232213/threads/java/implement-timeout-threads\">How to implement timeout using threads</a></li>\n<li><a href=\"http://stackoverflow.com/questions/2275443/how-to-timeout-a-thread\">How to timeout a thread</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何在logger没有收到新msg情况下，保证buf中的数据依然会定期发送给AWS-Kinesis\"><a href=\"#如何在logger没有收到新msg情况下，保证buf中的数据依然会定期发送给AWS-Kinesis\" class=\"headerlink\" title=\"如何在logger没有收到新msg情况下，保证buf中的数据依然会定期发送给AWS Kinesis\"></a>如何在<code>logger</code>没有收到新<code>msg</code>情况下，保证<code>buf</code>中的数据依然会定期发送给AWS Kinesis</h2><p><code>dlog</code>在<code>Logger.sync()</code>方法中通过一个定时器，定期将<code>buf</code>中数据发送给AWS Kinesis。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> sync() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l.SyncPeriod &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        l.SyncPeriod = time.Second</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ticker := time.NewTicker(l.SyncPeriod)  <span class=\"comment\">// l.SyncPeriod是定期发送的数据的时间间隔，ticker定时触发器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    buf := <span class=\"built_in\">make</span>([][]<span class=\"type\">byte</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    bufSize := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;  <span class=\"comment\">// 无限循环保证sync goroutine一直工作</span></span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> msg := &lt;-l.buffer:</span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-ticker.C: <span class=\"comment\">// ticker.C的类型是&lt;-chan Time，每隔l.SyncPeriod时间会触发执行当前case的代码</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> bufSize &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                l.flush(&amp;buf, &amp;bufSize)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>ticker</code>，<code>dlog</code>保证了即使没有收到新的<code>msg</code>的时候，保存在<code>buf</code>中的数据最长<code>l.SyncPeriod</code>时间后也会发送给AWS Kinesis。</p>\n<p>互联网产品的生产环境的上线，通常的做法是，将现有服务分组，然后交替切流量、升级。如果没有类似的机制，那么在服务程序断掉流量，没有收到新的访问时候，保存在内存中的数据就不会发送出去，升级时就可能导致数据丢失。</p>\n<h2 id=\"如何向程序外部暴露运行指标\"><a href=\"#如何向程序外部暴露运行指标\" class=\"headerlink\" title=\"如何向程序外部暴露运行指标\"></a>如何向程序外部暴露运行指标</h2><p>Go语言的官方Package <code>expvar</code>提供一种标准化的接口，允许程序暴露公开访问的变量。<code>expvar</code>通过HTTP地址<code>/debug/vars</code>提供访问入口，并以JSON格式展示这些变量。下面是关于<code>expvar</code>常见用法的一个例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;expvar&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Stats is used to collect runtime metrics</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Stats <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    sync.Mutex</span><br><span class=\"line\">    TotalHit  <span class=\"type\">int</span></span><br><span class=\"line\">    ErrorNums <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stats)</span></span> IncreaseTotalHit(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    s.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.TotalHit += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stats)</span></span> IncreaseErrorNums(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    s.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.ErrorNums += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stats)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    s.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    b, err := json.Marshal(*s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&#123;&#125;&quot;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">string</span>(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    stats *Stats</span><br><span class=\"line\">    hits  *expvar.Map</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    expvar.Publish(<span class=\"string\">&quot;now&quot;</span>, expvar.Func(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time.Now().Format(<span class=\"string\">&quot;\\&quot;2006-01-02 15:04:05\\&quot;&quot;</span>)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">    stats = &amp;Stats&#123;&#125;</span><br><span class=\"line\">    expvar.Publish(<span class=\"string\">&quot;stats&quot;</span>, stats)</span><br><span class=\"line\"></span><br><span class=\"line\">    hits = expvar.NewMap(<span class=\"string\">&quot;hits&quot;</span>).Init()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">homeHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    p := r.URL.Path[<span class=\"number\">1</span>:]</span><br><span class=\"line\">    hits.Add(p, <span class=\"number\">1</span>)</span><br><span class=\"line\">    stats.IncreaseTotalHit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hey! I love %s! hits: %v\\n&quot;</span>, p, hits.Get(p))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">errHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    stats.IncreaseErrorNums(<span class=\"number\">1</span>)</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Error Nums: %v\\n&quot;</span>, stats.ErrorNums)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/err&quot;</span>, errHandler)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, homeHandler)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照如下步骤测试运行效果：</p>\n<ul>\n<li><code>go run expvarexample.go</code>运行例子代码</li>\n<li>在浏览器中访问<code>http://localhost:8080/ethan</code></li>\n<li>在浏览器中访问<code>http://localhost:8080/err</code></li>\n<li>在浏览器中访问<code>http://localhost:8080/debug/vars</code>，得到如下结果：</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cmdline&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;/var/folders/jf/65ft181j33j_d75ktgv67bsc0000gn/T/go-build467453980/command-line-arguments/_obj/exe/expvarsample&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hits&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;ethan&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;favicon.ico&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;memstats&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> ... <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;now&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;\\&quot;2016-04-19 20:17:40\\&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;stats&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;TotalHit&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;ErrorNums&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/divan/expvarmon\">expvarmon</a>是一个帮助查看<code>expvar</code>暴露运行指标的工具，用法如下：</p>\n<ul>\n<li>安装：<code>go get github.com/divan/expvarmon</code></li>\n<li>运行：<code>expvarmon -ports=&quot;8080&quot; -vars=&quot;hits.ethan,stats.TotalHit,stats.ErrorNums,now&quot;</code></li>\n<li>效果如下：</li>\n</ul>\n<img src=\"/2016/04/20/experiences-about-develop-dlog/expvarmon_screen.png\" class=\"\" title=\"expvarmon screen\">\n\n<p><code>dlog</code>使用<code>expvar</code>向程序外部（比如监控程序）暴露运行指标，目前<code>dlog</code>中定义的运行指标包括：</p>\n<ul>\n<li><code>writtenRecords</code>: 成功写到AWS Kinesis的<code>msg</code>数量</li>\n<li><code>writtenBatches</code>: 成功调用AWS Kinesis批量写数据API的次数</li>\n<li><code>failedRecords</code>: 写到AWS Kinesis失败的<code>msg</code>数量</li>\n<li><code>tooBigMesssages</code>: 编码后体积过大(加上partitionKeySize大于1MB)的<code>msg</code>数量</li>\n</ul>\n<p>未来还需要根据运维的需求对运行指标进行调整，当前的用法也有一些问题，后期需要重构。</p>\n<h2 id=\"如何在单元测试中实现Setup和TearDown\"><a href=\"#如何在单元测试中实现Setup和TearDown\" class=\"headerlink\" title=\"如何在单元测试中实现Setup和TearDown\"></a>如何在单元测试中实现<code>Setup</code>和<code>TearDown</code></h2><p>Go语言提供一种<strong>轻量级</strong>的单元测试框架（无需第三方工具或者程序包）。通过使用<code>go test</code>命令和<code>testing</code> package，可以非常快速的实现单元测试。先借用官方文档中的<a href=\"http://docs.studygolang.com/doc/code.html#Testing\">例子</a>回顾一下Go单元测试框架的用法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$GOPATH/src/github.com/user/stringutil/reverse_test.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> stringutil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestReverse</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    cases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        in, want <span class=\"type\">string</span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;Hello, world&quot;</span>, <span class=\"string\">&quot;dlrow ,olleH&quot;</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;Hello, 世界&quot;</span>, <span class=\"string\">&quot;界世 ,olleH&quot;</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, c := <span class=\"keyword\">range</span> cases &#123;</span><br><span class=\"line\">        got := Reverse(c.in)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> got != c.want &#123;</span><br><span class=\"line\">            t.Errorf(<span class=\"string\">&quot;Reverse(%q) == %q, want %q&quot;</span>, c.in, got, c.want)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行测试只需要简单的输入命令：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> test github.com/user/stringutil</span><br><span class=\"line\">ok  \tgithub.com/user/stringutil <span class=\"number\">0.165</span>s</span><br></pre></td></tr></table></figure>\n\n<p>很多情况下，要执行单元测试，我们需要依赖一些外部资源，比如已完成初始化数据的数据库、公有云上的一些IaaS服务等。这些依赖资源，我们希望在单元测试执行前，能够自动的被初始化；单元测试完成后，能够自动的被清理。<a href=\"https://github.com/stretchr/testify/suite\">testify&#x2F;suite</a> package就提供这样的支持。通过<a href=\"https://github.com/stretchr/testify/suite\">testify&#x2F;suite</a>，你可以构建一个测试集<code>struct</code>，建立测试集的<code>setup</code>(初始化)&#x2F;<code>teardown</code>(清理)方法，和最终实现测试用例逻辑的方法。而运行测试，仍然只需要一句简单的<code>go test</code>。</p>\n<p>以下是使用<a href=\"https://github.com/stretchr/testify/suite\">testify&#x2F;suite</a>实现测试集的常见模式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> suite</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SuiteTester <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Include our basic suite logic.</span></span><br><span class=\"line\">    Suite</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Other properties</span></span><br><span class=\"line\">    propertyN <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SetupSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// start of the testing suite, before any tests are run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> SetupSuite() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The TearDownSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// end of the testing suite, after all tests have been run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TearDownSuite() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SetupTest method will be run before every test in the suite.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> SetupTest() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The TearDownTest method will be run after every test in the suite.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TearDownTest() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a test method</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TestOne() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// another test method</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *SuiteTester)</span></span> TestTwo() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TestRunSuite will be run by the &#x27;go test&#x27; command, so within it, we</span></span><br><span class=\"line\"><span class=\"comment\">// can run our suite using the Run(*testing.T, TestingSuite) function.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestRunSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    suiteTester := <span class=\"built_in\">new</span>(SuiteTester)</span><br><span class=\"line\">    Run(t, suiteTester)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dlog</code>中为了测试<code>Logger.Log</code>方法能否正常工作，按照上面的模式编写了相应的测试代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> dlog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> WriteLogSuiteTester <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    suite.Suite</span><br><span class=\"line\"></span><br><span class=\"line\">    options     *Options</span><br><span class=\"line\">    seachLogger *Logger</span><br><span class=\"line\">    clickLogger *Logger</span><br><span class=\"line\">    streamNames []<span class=\"type\">string</span> <span class=\"comment\">// save the created AWS Kinesis Streams, which will be removed in TearDownSuite()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SetupSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// start of the testing suite, before any tests are run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *WriteLogSuiteTester)</span></span> SetupSuite() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// create stream 1</span></span><br><span class=\"line\">    err = s.seachLogger.kinesis.CreateStream(s.seachLogger.streamName, testingShardCount)</span><br><span class=\"line\">    s.Nil(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// create stream 2</span></span><br><span class=\"line\">    err = s.clickLogger.kinesis.CreateStream(s.clickLogger.streamName, testingShardCount)</span><br><span class=\"line\">    s.Nil(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    s.streamNames = []<span class=\"type\">string</span>&#123;s.seachLogger.streamName, s.clickLogger.streamName&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"comment\">// waiting created stream&#x27;s status to be active</span></span><br><span class=\"line\">        time.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">        resp1, err1 := s.seachLogger.kinesis.DescribeStream(s.seachLogger.streamName)</span><br><span class=\"line\">        s.Nil(err1)</span><br><span class=\"line\"></span><br><span class=\"line\">        resp2, err2 := s.seachLogger.kinesis.DescribeStream(s.clickLogger.streamName)</span><br><span class=\"line\">        s.Nil(err2)</span><br><span class=\"line\"></span><br><span class=\"line\">        status1 := strings.ToLower(<span class=\"type\">string</span>(resp1.StreamStatus))</span><br><span class=\"line\">        status2 := strings.ToLower(<span class=\"type\">string</span>(resp2.StreamStatus))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> status1 == <span class=\"string\">&quot;active&quot;</span> &amp;&amp; status2 == <span class=\"string\">&quot;active&quot;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The TearDownSuite method will be run by testify once, at the very</span></span><br><span class=\"line\"><span class=\"comment\">// end of the testing suite, after all tests have been run.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *WriteLogSuiteTester)</span></span> TearDownSuite() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.streamNames == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(s.streamNames) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, streamName := <span class=\"keyword\">range</span> s.streamNames &#123;</span><br><span class=\"line\">        err := s.seachLogger.kinesis.DeleteStream(streamName)</span><br><span class=\"line\">        s.Nil(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *WriteLogSuiteTester)</span></span> TestWriteLog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">// Recover if panicking to make sure TearDownSuite will be executed</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            s.Fail(fmt.Sprint(r))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestRunWriteLogSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    suiteTester := <span class=\"built_in\">new</span>(WriteLogSuiteTester)</span><br><span class=\"line\">    suite.Run(t, suiteTester)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注：</p>\n<ul>\n<li>很多场景下，测试程序自动创建依赖的资源需要运维部门的授权，所以实现前有必要先和运维部门沟通。</li>\n<li>云环境下，出于安全上的考虑，需要对创建、删除测试资源的账户管理严格管理<ul>\n<li>账户信息不能写在可以公开访问的测试代码、配置文件中</li>\n<li>只给账户分配必要资源的最小权限</li>\n<li>为账户能够创建的资源设定配额</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何实现kinesisMock\"><a href=\"#如何实现kinesisMock\" class=\"headerlink\" title=\"如何实现kinesisMock\"></a>如何实现<code>kinesisMock</code></h2><p>上一节我们提到在测试执行前初始化依赖资源，现实场景中，并不是任何情况下都能够获得依赖的测试资源，或者测试资源也会出现不可用的情况。通过Mock技术，可以减少测试代码对其它资源（或模块）的依赖。</p>\n<p><code>dlog</code>的测试代码中，首先定义了一个<code>KinesisInterface</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> KinesisInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>)</span><br><span class=\"line\">    CreateStream(name <span class=\"type\">string</span>, shardCount <span class=\"type\">int</span>) <span class=\"type\">error</span></span><br><span class=\"line\">    DescribeStream(name <span class=\"type\">string</span>) (resp *kinesis.StreamDescription, err <span class=\"type\">error</span>)</span><br><span class=\"line\">    DeleteStream(name <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KinesisInterface</code>包含了<code>dlog</code>用到的<a href=\"https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go\">github.com&#x2F;AdRoll&#x2F;goamz&#x2F;kinesis&#x2F;kinesis</a>的所有方法。因为Go语言<code>interface</code>实现<strong>非侵入式</strong>的特点，<a href=\"https://github.com/AdRoll/goamz/blob/master/kinesis/kinesis.go\">github.com&#x2F;AdRoll&#x2F;goamz&#x2F;kinesis&#x2F;kinesis</a>自动实现了<code>KinesisInterface</code>，我们再定义一个<code>kinesisMock</code>实现<code>KinesisInterface</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> kinesisMock <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mapping from steam name to batches of batches</span></span><br><span class=\"line\">    storage <span class=\"keyword\">map</span>[<span class=\"type\">string</span>][][]kinesis.PutRecordsRequestEntry</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// simulate lantency that sync to Kinesis</span></span><br><span class=\"line\">    putRecordLatency time.Duration</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// created streams&#x27; names</span></span><br><span class=\"line\">    streamNames []<span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lock to solve concurrent call</span></span><br><span class=\"line\">    lock sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newKinesisMock</span><span class=\"params\">(putRecordsLatency time.Duration)</span></span> *kinesisMock &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;kinesisMock&#123;</span><br><span class=\"line\">        storage:          <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>][][]kinesis.PutRecordsRequestEntry),</span><br><span class=\"line\">        putRecordLatency: putRecordsLatency,</span><br><span class=\"line\">        streamNames:      <span class=\"built_in\">make</span>([]<span class=\"type\">string</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> CreateStream(name <span class=\"type\">string</span>, shardCount <span class=\"type\">int</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> DescribeStream(name <span class=\"type\">string</span>) (resp *kinesis.StreamDescription, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> DeleteStream(name <span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，把业务代码中所有类型<code>kinesis</code>的变量，替换成<code>KinesisInterface</code>类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    kinesis    KinesisInterface</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码中，在构造<code>Logger</code>时传入<code>kinesisMock</code>，而不是真实的<code>kinesis</code>，这样就做到了“狸猫换太子”。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestLoggingToMockKinesis</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    assert := assert.New(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    l, e := NewLogger(&amp;impression&#123;&#125;, &amp;Options&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        UseMockKinesis: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        MockKinesis:    newKinesisMock(<span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何模拟AWS-Kinesis响应慢或者不可用\"><a href=\"#如何模拟AWS-Kinesis响应慢或者不可用\" class=\"headerlink\" title=\"如何模拟AWS Kinesis响应慢或者不可用\"></a>如何模拟AWS Kinesis响应慢或者不可用</h2><p><code>kinesisMock</code>完全是我们“虚构”出来的一个<code>kinesis</code>，在它的基础上，我们完全可以模拟响应慢或者不可用的情况。</p>\n<p>上一节中，不知道大家注意到没有，<code>kinesisMock</code>有个属性叫<code>putRecordLatency</code>，用来模拟调用<code>PutRecords</code>方法的延迟时间。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> kinesisMock <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// simulate lantency that sync to Kinesis</span></span><br><span class=\"line\">    putRecordLatency time.Duration</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *kinesisMock)</span></span> PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(mock.putRecordLatency) <span class=\"comment\">// 模拟延迟</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>模拟不可用的<code>kinesis</code>则重新定义了一个<code>brokenKinesisMock</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> brokenKinesisMock <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    *kinesisMock</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newBrokenKinesisMock</span><span class=\"params\">()</span></span> *brokenKinesisMock &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;brokenKinesisMock&#123;</span><br><span class=\"line\">        kinesisMock: newKinesisMock(<span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mock *brokenKinesisMock)</span></span> PutRecords(streamName <span class=\"type\">string</span>, records []kinesis.PutRecordsRequestEntry) (resp *kinesis.PutRecordsResponse, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;Kinesis is broken&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>kinesisMock</code>是<code>brokenKinesisMock</code>的嵌入<code>struct</code>，<code>brokenKinesisMock</code>会自动拥有<code>kinesisMock</code>的所有公开方法，这样也就实现了<code>KinesisInterface</code>。</p>\n<h2 id=\"提交到代码库中的测试代码是否可以保留log-Print\"><a href=\"#提交到代码库中的测试代码是否可以保留log-Print\" class=\"headerlink\" title=\"提交到代码库中的测试代码是否可以保留log.Print\"></a>提交到代码库中的测试代码是否可以保留<code>log.Print</code></h2><p>结论是“不可以”，原因总结如下：</p>\n<ul>\n<li>测试代码中的<code>log.Print</code>，一般用于调试代码，或者在<code>stdout</code>打印出一些信息帮助判断测试失败原因。不论哪种目的，这样的代码目的都仅仅是为了辅助开发，而不应该出现在最终交付的产品代码中。</li>\n<li><code>go test</code>命令会在控制台输出失败的测试方法，如果加上<code>-v</code>标志会打印出所有测试方法的执行结果，<code>log.Print</code>会影响执行结果的展示效果。团队合作开发，如果每个人都在测试代码中加上自己的<code>log.Print</code>，那么控制台打印出来的测试结果就没法看了。</li>\n</ul>\n<h1 id=\"踩过的一些坑\"><a href=\"#踩过的一些坑\" class=\"headerlink\" title=\"踩过的一些坑\"></a>踩过的一些坑</h1><ul>\n<li><a href=\"http://docs.aws.amazon.com/kinesis/latest/APIReference/API_CreateStream.html\">AWS Kinesis API - CreateStream</a>是异步创建Stream，而且耗时10+秒，才能完成一个Stream的创建。开始以为是同步创建，结果执行测试逻辑的时候总是出错。</li>\n<li><a href=\"https://github.com/AdRoll/goamz/blob/master/aws/regions.go\">github.com&#x2F;AdRoll&#x2F;goamz&#x2F;aws&#x2F;regions.go</a>中缺少中国区AWS Kinesis的URL地址，调用中国区AWS Kinesis会出错。</li>\n<li>Travis CI会Kill掉执行时间超过1分钟的CI过程，而不是如它文档中介绍的“10分钟”</li>\n</ul>\n<h1 id=\"未来可以优化的地方\"><a href=\"#未来可以优化的地方\" class=\"headerlink\" title=\"未来可以优化的地方\"></a>未来可以优化的地方</h1><ul>\n<li>发送失败的错误事件机制</li>\n<li>实现Kinesis服务不可用或者响应慢的场景下<code>dlog</code>的容错处理</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://docs.studygolang.com/doc/effective_go.html\">Effective Go</a></li>\n<li><a href=\"https://aws.amazon.com/cn/documentation/kinesis/\">Amazon Kinesis Documentation</a></li>\n<li><a href=\"http://blog.golang.org/advanced-go-concurrency-patterns\">Advanced Go Concurrency Patterns</a></li>\n<li><a href=\"https://github.com/afex/hystrix-go\">hystrix-go</a></li>\n</ul>\n<h1 id=\"招聘消息\"><a href=\"#招聘消息\" class=\"headerlink\" title=\"招聘消息\"></a>招聘消息</h1><p>我所在的<a href=\"http://www.augmn.com/\">奥阁门科技有限公司</a>正在招聘后端、运维工程师，想加入的朋友、或者有朋友可以推荐的都可以联系我(<a href=\"mailto:&#x65;&#x74;&#104;&#x61;&#110;&#99;&#x61;&#105;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;\">ethancai@qq.com</a>)。</p>\n<img src=\"/2016/04/20/experiences-about-develop-dlog/2016-04-21_07-12-24.png\" class=\"\" title=\"办公环境1\">\n\n<img src=\"/2016/04/20/experiences-about-develop-dlog/2016-04-21_07-12-40.png\" class=\"\" title=\"办公环境2\">\n\n<p><strong>后端工程师 &#x2F; Backend Engineer</strong></p>\n<p>职责</p>\n<ul>\n<li>研讨和设计产品功能特性；</li>\n<li>设计研发系统后端的一个或多个独立服务（micro-service）模块；</li>\n<li>设计研发业务运营管理系统；</li>\n<li>Code Review。</li>\n</ul>\n<p>要求</p>\n<ul>\n<li>有良好的编程习惯和代码风格；</li>\n<li>精通至少一种后台开发语言，包括但不限于Go、Node.js、C++、Python；</li>\n<li>对RESTful、RPC等架构有深刻理解和运用经验；</li>\n<li>有丰富的web service、web app开发经验；使用过著名的开源应用框架，并完整阅读过源代码；</li>\n<li>对Mysql、Redis、MongoDB或同类数据存储技术有丰富的使用经验；</li>\n<li>有提交代码到著名开源库或创建过开源项目者优先；</li>\n<li>能熟练查阅英文技术文档；</li>\n<li>有开放、坦诚的沟通心态，乐于分享；</li>\n<li>5年以上工作经验，3年以上后台系统开发经验。</li>\n</ul>\n<p><strong>高级系统运维工程师 &#x2F; Senior Ops Engineer</strong></p>\n<p>职责</p>\n<ul>\n<li>负责日常业务系统基础实施（AWS）、网络及各子系统的管理维护。</li>\n<li>负责设计并部署相关应用平台，并提出平台的实施、运行报告。</li>\n<li>负责配合开发搭建测试平台，协助开发设计、推行、实施和持续改进。</li>\n<li>负责相关故障、疑难问题排查处理，编制汇总故障、问题，定期提交汇总报告。</li>\n<li>负责网络监控和应急反应，以确保网络系统有7*24小时的持续运作能力。</li>\n<li>负责日常系统维护，及监控，提供IT方面的服务和支持，保证系统的稳定。</li>\n</ul>\n<p>要求</p>\n<ul>\n<li>深入理解Linux&#x2F;Unix操作系统并能熟练使用，了解Linux系统内核，有相关操作系统调优经验优先；</li>\n<li>熟悉计算机网络基础知识，了解TCP&#x2F;IP、HTTP等网络协议；</li>\n<li>熟悉系统服务的管理和维护，例如：Nginx、DNS服务器、NTP服务等；</li>\n<li>熟悉一种或者多种脚本语言，例如：Shell、Python、Perl 、Ruby等；</li>\n<li>熟练掌握Linux管理相关命令行工具，例如：grep、awk、sed、tmux、vim等；</li>\n<li>对数据库系统（MySQL）运维管理有一定的了解；</li>\n<li>熟悉常见分布式系统系统架构部署管理，熟悉基础设施管理、并具有较强的故障排查和解决问题的能力；</li>\n<li>具有 2 年以上中大型互联网系统或亚马逊AWS管理经验者优先；</li>\n<li>有DevOps经验者优先；</li>\n<li>学习能力和沟通能力较强，具有良好的团队协作精神；</li>\n<li>工作中需要胆大心细，具备探索创新精神；</li>\n<li>具有良好的文档编写能力；</li>\n<li>具有一定的英文技术文档阅读能力。</li>\n</ul>\n"},{"title":"Go语言中的错误处理（Error Handling in Go）","date":"2017-12-29T02:23:06.000Z","_content":"\n\n\n{% asset_img d2a2d12e1a00f819d7fd7af4b536efa2.png %}\n<small>_上图来自 {% link \"go proverbs\" https://go-proverbs.github.io/ %}_</small>\n\n\n# 概述\n\n在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。\n\nGo语言没有提供像Java、C#语言中的`try...catch`异常处理方式，而是通过函数返回值逐层往上抛。\n\n这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码啰嗦。\n\n\n# Go标准包提供的错误处理功能\n\n`error`是个`interface`:\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n如何创建`error`:\n\n```go\n// example 1\nfunc Sqrt(f float64) (float64, error) {\n    if f < 0 {\n        return 0, errors.New(\"math: square root of negative number\")\n    }\n    // implementation\n}\n\n// example 2\nif f < 0 {\n    return 0, fmt.Errorf(\"math: square root of negative number %g\", f)\n}\n```\n\n如何自定义`error`:\n\n```go\n// errorString is a trivial implementation of error.\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) Error() string {\n    return e.s\n}\n```\n\n自定义`error`类型可以拥有一些附加方法。比如`net.Error`定义如下：\n\n```go\npackage net\n\ntype Error interface {\n    error\n    Timeout() bool   // Is the error a timeout?\n    Temporary() bool // Is the error temporary?\n}\n```\n\n网络客户端程序代码可以使用类型断言判断网络错误是瞬时错误还是永久错误。比如，一个网络爬虫可以在碰到瞬时错误的时候，等待一段时间然后重试。\n\n```go\nif nerr, ok := err.(net.Error); ok && nerr.Temporary() {\n    time.Sleep(1e9)\n    continue\n}\nif err != nil {\n    log.Fatal(err)\n}\n```\n\n# 错误处理策略\n\n实际项目开发、运维过程中，会经常碰到如下问题：\n\n- 函数该如何返回错误，是用值，还是用特殊的错误类型\n- 如何检查被调用函数返回的错误，是判断错误值，还是用类型断言\n- 程序中每层代码在碰到错误的时候，是每层都处理，还是只用在最上层处理，如何做到优雅\n- 日志中的异常信息不够完整、缺少stack strace，不方便定位错误原因\n\n上面的问题都涉及到该如何处理错误，下面来介绍了生产级Go语言代码中如何处理错误。\n\n\n## 三种错误处理策略\n\nGo语言中一般有三种错误处理策略：\n\n- **返回和检查错误值**：通过特定值表示成功和不同的错误，上层代码检查错误的值，来判断被调用`func`的执行状态\n- **自定义错误类型**：通过自定义的错误类型来表示特定的错误，上层代码通过类型断言判断错误的类型\n- **隐藏内部细节的错误处理**：上层代码不应该知道（依赖）被调用函数返回错误的任何细节\n\n\n### 返回和检查错误值\n\n这种方式在其它语言中，也很常见。比如，[C Error Codes in Linux](http://www.virtsync.com/c-error-codes-include-errno)。\n\ngo标准库中提供一些例子：\n\n- `io.EOF`: 参考[这里](https://github.com/golang/go/blob/master/src/io/io.go#L38)\n- `syscall.ENOENT`: 参考[这里](https://github.com/golang/go/blob/master/src/syscall/zerrors_linux_amd64.go#L1280)\n- `go/build.NoGoError`: 参考[这里](https://github.com/golang/go/blob/master/src/go/build/build.go#L446)\n- `path/filepath.SkipDir`: 参考[这里](https://github.com/golang/go/blob/master/src/path/filepath/path.go#L331)\n\n<u>这种策略是最不灵活的错误处理策略，上层代码需要判断返回错误值是否等于特定值。如果想修改返回的错误值，则会破坏上层调用代码的逻辑。</u>\n\n```go\nbuf := make([]byte, 100)\nn, err := r.Read(buf)   // 如果修改 r.Read，在读到文件结尾时，返回另外一个 error，比如 io.END，而不是 io.EOF，则所有调用 r.Read 的代码都必须修改\nbuf = buf[:n]\nif err == io.EOF {\n    log.Fatal(\"read failed:\", err)\n}\n```\n\n另外一种场景也属于这类情况，上层代码通过检查错误的`Error()`方法的返回值是否包含特定字符串，来判定如何进行错误处理。\n\n```go\nfunc readfile(path string) error {\n    err := openfile(path)\n    if err != nil {\n        return fmt.Errorf(\"cannot open file: %v\", err)\n    }\n    //...\n}\n\nfunc main() {\n    err := readfile(\".bashrc\")\n    if strings.Contains(error.Error(), \"not found\") {\n        // handle error\n    }\n}\n```\n\n> **`error` interface 的 `Error` 方法的输出，是给人看的，不是给机器看的。我们通常会把`Error`方法返回的字符串打印到日志中，或者显示在控制台上。永远不要通过判断`Error`方法返回的字符串是否包含特定字符串，来决定错误处理的方式。**\n\n如果你是开发一个公共库，库的API返回了特定值的错误值。那么必须把这个特定值的错误定义为`public`，写在文档中。\n\n“高内聚、低耦合”是衡量公共库质量的一个重要方面，而返回特定错误值的方式，增加了公共库和调用代码的耦合性。让模块之间产生了依赖。\n\n\n### 自定义错误类型\n\n这种方式的典型用法如下：\n\n```go\n// 定义错误类型\ntype MyError struct {\n    Msg string\n    File string\n    Line int\n}\n\nfunc (e *MyError) Error() string {\n    return fmt.Sprintf(\"%s:%d: %s\", e.File, e.Line, e.Msg)\n}\n\n\n// 被调用函数\nfunc doSomething() {\n    // do something\n    return &MyError{\"Something happened\", \"server.go\", 42}\n}\n\n// 调用代码\nerr := doSomething()\nif err, ok := err.(SomeType); ok {    // 使用 类型断言 获得错误详细信息\n    //...\n}\n```\n\n这种方式相比于“返回和检查错误值”，很大一个优点在于可以将 底层错误 包起来一起返回给上层，这样可以提供更多的上下文信息。比如`os.PathError`：\n\n```go\n// PathError records an error and the operation\n// and file path that caused it.\ntype PathError struct {\n    Op string\n    Path string\n    Err error\n}\n\nfunc (e *PathError) Error() string\n```\n\n然而，这种方式依然会增加模块之间的依赖。\n\n\n### 隐藏内部细节的错误处理\n\n这种策略之所以叫“隐藏内部细节的错误处理”，是因为当上层代码碰到错误发生的时候，不知道错误的内部细节。\n\n**作为上层代码，你所需要知道的只是被调用函数是否正常工作。** 如果你接受这个原则，将极大降低模块之间的耦合性。\n\n```go\nimport “github.com/quux/bar”\n\nfunc fn() error {\n    x, err := bar.Foo()\n    if err != nil {\n        return err\n    }\n    // use x\n}\n```\n\n上面的例子中，`Foo`这个方法不返回的错误的具体内容。这样，`Foo`函数的开发者可以不断调整返回错误的内容来提供更多的错误信息，而不会破坏`Foo`提供的协议。这就是“隐藏内部细节”的内涵。\n\n\n## 最合适的错误处理策略\n\n上面我们提到了三种错误处理策略，其中第三种策略耦合性最低。然而，第三种方式也存在一些问题：\n\n- 如何获得更详细错误信息，比如`stack trace`，帮助定位错误原因\n- 如何优雅的处理错误\n    - 有些场景需要了解错误细节，比如网络调用，需要知道是否是瞬时的中断\n    - 是否每层捕捉到错误的时候都需要处理\n\n\n### 输出更详细的错误信息来定位问题\n\n```go\nfunc AuthenticateRequest(r *Request) error {\n    err := authenticate(r.User)\n    if err != nil {\n        return err  // No such file or directory\n    }\n    return nil\n}\n```\n\n上面这段代码，在我看来，在顶层打印错误的时候，只看到一个类似于\"No such file or directory\"的文字，从这段文字中，无法了解到错误是哪行代码产生的，也无法知道当时出错的调用堆栈。\n\n我们调整一下代码，如下：\n\n```go\nfunc AuthenticateRequest(r *Request) error {\n    err := authenticate(r.User)\n    if err != nil {\n        return fmt.Errorf(\"authenticate failed: %v\", err)    // authenticate failed: No such file or directory\n    }\n    return nil\n}\n```\n\n通过`fmt.Errorf`创建一个新的错误，添加更多的上下文信息到新的错误中，但这样仍不能解决上面提出的问题（错误发生的位置和调用堆栈）。\n\ngoErrorHandlingSample](https://github.com/EthanCai/goErrorHandlingSample)这个repo中的例子演示了，不同错误处理方式，输出的错误信息的区别。\n\n```\n> go run sample1/main.go\n\nopen ~/.settings.xml: no such file or directory\nexit status 1\n```\n\n```\n> go run sample2/main.go\n\ncould not read config: open failed: open ~/.settings.xml: no such file or directory\nexit status 1\n```\n\n```\n> go run sample3/main.go\n\ncould not read config: open failed: open ~/.settings.xml: no such file or directory\nexit status 1\n```\n\n```\n> go run sample4/main.go\n\nopen ~/.settings.xml: no such file or directory\nopen failed\nmain.ReadFile\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:15\nmain.ReadConfig\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:27\nmain.main\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32\nruntime.main\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195\nruntime.goexit\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337\ncould not read config\nmain.ReadConfig\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:28\nmain.main\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32\nruntime.main\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195\nruntime.goexit\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337\nexit status 1\n\n```\n\n`sample4/main.go`中将出错的代码行数也打印了出来，这样的日志，可以帮助我们更方便的定位问题原因。\n\n\n### 通过行为断言错误\n\n在有些场景下，仅仅知道是否出错是不够的。比如，和进程外其它服务通信，需要了解错误的属性，以决定是否需要重试操作。\n\n这种情况下，<u>不要判断错误值或者错误的类型，可以判断错误是否实现某个行为</u>。\n\n```go\ntype temporary interface {\n    Temporary() bool    // IsTemporary returns true if err is temporary.\n}\n\nfunc IsTemporary(err error) bool {\n    te, ok := err.(temporary)\n    return ok && te.Temporary()\n}\n```\n\n这种实现方式的好处在于，不需要知道具体的错误类型，也就不需要引用定义了错误类型的三方`package`。如果你是底层代码的开发者，哪天你想更换一个实现更好的`error`，也不用担心影响上层代码逻辑。如果你是上层代码的开发者，你只需要关注`error`是否实现了特定行为，不用担心引用的三方`package`升级后，程序逻辑失败。\n\n\n### 不要忽略错误，也不要重复处理错误\n\n遇到错误，而不去处理，导致信息缺失，会增加后期的运维成本\n\n```go\nfunc Write(w io.Writer, buf []byte) {\n    w.Write(buf)    // Write(p []byte) (n int, err error)，Write方法的定义见 https://golang.org/pkg/io/#Writer\n}\n```\n\n重复处理，添加了不必要的处理逻辑，导致信息冗余，也会增加后期的运维成本\n\n```go\nfunc Write(w io.Writer, buf []byte) error {\n    _, err := w.Write(buf)\n    if err != nil {\n        log.Println(\"unable to write:\", err)    // 第1次错误处理\n\n        return err\n    }\n    return nil\n}\n\nfunc main() {\n    // create writer and read data into buf\n\n    err := Write(w, buf)\n    if err != nil {\n        log.Println(\"Write error:\", err)        // 第2次错误处理\n        os.Exit(1)\n    }\n\n    os.Exit(0)\n}\n```\n\n## 补充的错误处理原则\n\n从稳定性视角出发，为了便于发现和分析问题：\n\n* 错误信息需要记录到日志\n* 错误量需要体现在metrics中\n\n# Package `github.com/pkg/errors` \n\n建议使用包 [`github.com/pkg/errors`](https://github.com/pkg/errors) 来处理错误。这个包提供这样几个主要的API：\n\n```go\n// 以下代码在errors.go中\n\n// New returns an error with the supplied message.\n// New also records the stack trace at the point it was called.\nfunc New(message string) error\n\n// Errorf formats according to a format specifier and returns the string\n// as a value that satisfies error.\n// Errorf also records the stack trace at the point it was called.\nfunc Errorf(format string, args ...interface{}) error\n\n// WithStack annotates err with a stack trace at the point WithStack was called.\n// If err is nil, WithStack returns nil.\nfunc WithStack(err error) error\n\n// Wrap returns an error annotating err with a stack trace\n// at the point Wrap is called, and the supplied message.\n// If err is nil, Wrap returns nil.\nfunc Wrap(err error, message string) error\n\n// Wrapf returns an error annotating err with a stack trace\n// at the point Wrapf is called, and the format specifier.\n// If err is nil, Wrapf returns nil.\nfunc Wrapf(err error, format string, args ...interface{}) error\n\n// WithMessage annotates err with a new message.\n// If err is nil, WithMessage returns nil.\nfunc WithMessage(err error, message string) error\n\n// WithMessagef annotates err with the format specifier.\n// If err is nil, WithMessagef returns nil.\nfunc WithMessagef(err error, format string, args ...interface{}) error\n\n// Cause returns the underlying cause of the error, if possible.\n// An error value has a cause if it implements the following\n// interface:\n//\n//     type causer interface {\n//            Cause() error\n//     }\n//\n// If the error does not implement Cause, the original error will\n// be returned. If the error is nil, nil will be returned without further\n// investigation.\nfunc Cause(err error) error\n\n\n\n// 以下代码在 go113.go 中\n\n// Is reports whether any error in err's chain matches target.\n//\n// The chain consists of err itself followed by the sequence of errors obtained by\n// repeatedly calling Unwrap.\n//\n// An error is considered to match a target if it is equal to that target or if\n// it implements a method Is(error) bool such that Is(target) returns true.\nfunc Is(err, target error) bool\n\n// As finds the first error in err's chain that matches target, and if so, sets\n// target to that error value and returns true.\n//\n// The chain consists of err itself followed by the sequence of errors obtained by\n// repeatedly calling Unwrap.\n//\n// An error matches target if the error's concrete value is assignable to the value\n// pointed to by target, or if the error has a method As(interface{}) bool such that\n// As(target) returns true. In the latter case, the As method is responsible for\n// setting target.\n//\n// As will panic if target is not a non-nil pointer to either a type that implements\n// error, or to any interface type. As returns false if err is nil.\nfunc As(err error, target interface{}) bool\n\n// Unwrap returns the result of calling the Unwrap method on err, if err's\n// type contains an Unwrap method returning error.\n// Otherwise, Unwrap returns nil.\nfunc Unwrap(err error) error\n```\n\n[`example_test.go`](https://github.com/pkg/errors/blob/master/example_test.go)有一些使用案例。\n\n# 各种场景下的错误处理案例\n\n## error相等判断\n\n当不确定待处理的error是否被包装时，不能直接使用相等进行判断。\n\n**例子**\n\n*Bad：*\n\n```go\nif err == EOF {\n}\n```\n\n*Good：*\n\n```go\nif errors.Is(err, EOF) {\t// it will succeed if err wraps EOF\n}\n```\n\n## error类型转换\n\n当不确定待处理的error是否被包装时，不能直接使用类型断言进行。\n\n**例子**\n\n*Bad：*\n\n```go\nnerr, ok := err.(*CError)\nif ok {\n}\n```\n\n*Good：*\n\n```go\nvar nerr *CError\nif errors.As(err, &nerr) {\t// it will succeed if err wraps an *CError\n  \t// nerr is set as *CError\n    ...\n}\n```\n\n## 如何向外暴露error\n\n**例子**\n\n*Bad：*\n\n```go\n// package io\nvar FileNotFoundErr = fmt.Errorf(\"file not found\")\n\n// package service\nif errors.Is(err, io.FileNotFoundErr) {\n}\n```\n\n*Good：*\n\n```go\n// package io\nvar fileNotFoundErr = fmt.Errorf(\"file not found\")\nfunc IsFileNotFoundErr(err) bool {\n    return errors.Is(err, fileNotFoundErr)\n}\n\n// package service\nif io.IsFileNotFoundErr(err) {\n}\n```\n\n## 程序启动时，如何处理依赖的三方资源无法连接 或者 不存在\n\n根据三方资源的对于业务逻辑的重要性，采取是强依赖、还是弱依赖的处理策略，比如：\n\n* 如果三方资源是 类似DB的强依赖 资源，启动时无法连接，记录错误并`panic`\n* 如果三方资源是 弱依赖的服务，启动时无法连接，记录错误但无需`panic`\n\n## 服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\n\n在没有安全要求的情况下，B尽量返回详细的错误信息（`message`、`stack trace` 等），方便看到错误信息时候，能够直接定位错误原因。\n\n在存在安全限制的场景下，B返回在安全限制以内尽量详细的错误信息，比如：\n\n* A是自有的C端的 客户端应用或者前端web应用，B不能返回`stack trace`\n* A是外部的应用，调用服务B，B不能返回 内部的错误`message`、`stack trace`\n\n## 数据访问层，使用gorm等orm框架查不到结果不应该报error\n\n数据访问层，使用gorm等orm框架查不到结果不应该报error，原因如下：\n\n* 从业务逻辑的角度来看，查不到结果 是一种正常的现象，不应当视为错误。比如，注册的时候检查账户是否已经存在，去掉订单的时候检查订单是否存在 等情况下，不应该将查不到数据视为错误。\n* 如果在业务逻辑里判断`err != gorm.errnotfound`，不符合开闭原则，如果后面要换一个数据库框架，需要改动业务逻辑代码\n\n数据访问层建议的处理方式：\n\n```go\n// Dao层的查询函数\nfunc GetByID(id int) (*Object, error) {\n\t\t// 查询逻辑\n\n    if err != nil && err != gorm.ErrRecordNotFound {\n        return nil, err// 仅在 err 是非ErrRecordNotFound类型的时候，才认为是错误\n    }\n\n    if err == gorm.ErrRecordNotFound {\n        return nil, nil\n    }\n\n    return &result, nil\n}\n```\n\n# 总结\n\n错误处理策略满足以下要求\n\n- 从代码结构的角度出发，不增加代码耦合度\n\n- 从服务稳定性的角度出发，便于发现和分析问题\n\n没有最好的策略，只有最合适的策略。在实际的项目开发过程中，不要拘泥于教条，灵活运用各种策略。让代码更健壮，让服务更稳定。\n\n\n# 参考\n\n- The Go Blog\n    - [Error handling in Go](https://blog.golang.org/error-handling-and-go)\n    - [Defer, Panic, and Recover](https://blog.golang.org/defer-panic-and-recover)\n- Dave Cheney\n    - [presentation on my philosophy for error handling](https://dave.cheney.net/paste/gocon-spring-2016.pdf)\n    - [Don’t just check errors, handle them gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully)\n    - [Stack traces and the errors package](https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package)\n- Go Packages\n    - [errors](https://golang.org/pkg/errors/)\n    - [runtime](https://golang.org/pkg/runtime/)\n- pkg: Artisanal, hand crafted, barrel aged, Go packages\n    - [github.com/pkg/errors](https://godoc.org/github.com/pkg/errors)\n- [Go 2 Draft Designs](https://go.googlesource.com/proposal/+/master/design/go2draft.md)\n    + [go2draft-error-handling-overview.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling-overview.md)\n    + [go2draft-error-handling.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling.md)\n    + [go2draft-error-inspection.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-inspection.md)\n    + [go2draft-error-printing.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-printing.md)\n    + [go2draft-error-values-overview.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-values-overview.md)\n\n","source":"_posts/2017-12-29-error-handling-in-go.md","raw":"---\ntitle: Go语言中的错误处理（Error Handling in Go）\ncategories:\n  - 编程开发\ntags:\n  - golang\ndate: 2017-12-29 10:23:06\n---\n\n\n\n{% asset_img d2a2d12e1a00f819d7fd7af4b536efa2.png %}\n<small>_上图来自 {% link \"go proverbs\" https://go-proverbs.github.io/ %}_</small>\n\n\n# 概述\n\n在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。\n\nGo语言没有提供像Java、C#语言中的`try...catch`异常处理方式，而是通过函数返回值逐层往上抛。\n\n这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码啰嗦。\n\n\n# Go标准包提供的错误处理功能\n\n`error`是个`interface`:\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n如何创建`error`:\n\n```go\n// example 1\nfunc Sqrt(f float64) (float64, error) {\n    if f < 0 {\n        return 0, errors.New(\"math: square root of negative number\")\n    }\n    // implementation\n}\n\n// example 2\nif f < 0 {\n    return 0, fmt.Errorf(\"math: square root of negative number %g\", f)\n}\n```\n\n如何自定义`error`:\n\n```go\n// errorString is a trivial implementation of error.\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) Error() string {\n    return e.s\n}\n```\n\n自定义`error`类型可以拥有一些附加方法。比如`net.Error`定义如下：\n\n```go\npackage net\n\ntype Error interface {\n    error\n    Timeout() bool   // Is the error a timeout?\n    Temporary() bool // Is the error temporary?\n}\n```\n\n网络客户端程序代码可以使用类型断言判断网络错误是瞬时错误还是永久错误。比如，一个网络爬虫可以在碰到瞬时错误的时候，等待一段时间然后重试。\n\n```go\nif nerr, ok := err.(net.Error); ok && nerr.Temporary() {\n    time.Sleep(1e9)\n    continue\n}\nif err != nil {\n    log.Fatal(err)\n}\n```\n\n# 错误处理策略\n\n实际项目开发、运维过程中，会经常碰到如下问题：\n\n- 函数该如何返回错误，是用值，还是用特殊的错误类型\n- 如何检查被调用函数返回的错误，是判断错误值，还是用类型断言\n- 程序中每层代码在碰到错误的时候，是每层都处理，还是只用在最上层处理，如何做到优雅\n- 日志中的异常信息不够完整、缺少stack strace，不方便定位错误原因\n\n上面的问题都涉及到该如何处理错误，下面来介绍了生产级Go语言代码中如何处理错误。\n\n\n## 三种错误处理策略\n\nGo语言中一般有三种错误处理策略：\n\n- **返回和检查错误值**：通过特定值表示成功和不同的错误，上层代码检查错误的值，来判断被调用`func`的执行状态\n- **自定义错误类型**：通过自定义的错误类型来表示特定的错误，上层代码通过类型断言判断错误的类型\n- **隐藏内部细节的错误处理**：上层代码不应该知道（依赖）被调用函数返回错误的任何细节\n\n\n### 返回和检查错误值\n\n这种方式在其它语言中，也很常见。比如，[C Error Codes in Linux](http://www.virtsync.com/c-error-codes-include-errno)。\n\ngo标准库中提供一些例子：\n\n- `io.EOF`: 参考[这里](https://github.com/golang/go/blob/master/src/io/io.go#L38)\n- `syscall.ENOENT`: 参考[这里](https://github.com/golang/go/blob/master/src/syscall/zerrors_linux_amd64.go#L1280)\n- `go/build.NoGoError`: 参考[这里](https://github.com/golang/go/blob/master/src/go/build/build.go#L446)\n- `path/filepath.SkipDir`: 参考[这里](https://github.com/golang/go/blob/master/src/path/filepath/path.go#L331)\n\n<u>这种策略是最不灵活的错误处理策略，上层代码需要判断返回错误值是否等于特定值。如果想修改返回的错误值，则会破坏上层调用代码的逻辑。</u>\n\n```go\nbuf := make([]byte, 100)\nn, err := r.Read(buf)   // 如果修改 r.Read，在读到文件结尾时，返回另外一个 error，比如 io.END，而不是 io.EOF，则所有调用 r.Read 的代码都必须修改\nbuf = buf[:n]\nif err == io.EOF {\n    log.Fatal(\"read failed:\", err)\n}\n```\n\n另外一种场景也属于这类情况，上层代码通过检查错误的`Error()`方法的返回值是否包含特定字符串，来判定如何进行错误处理。\n\n```go\nfunc readfile(path string) error {\n    err := openfile(path)\n    if err != nil {\n        return fmt.Errorf(\"cannot open file: %v\", err)\n    }\n    //...\n}\n\nfunc main() {\n    err := readfile(\".bashrc\")\n    if strings.Contains(error.Error(), \"not found\") {\n        // handle error\n    }\n}\n```\n\n> **`error` interface 的 `Error` 方法的输出，是给人看的，不是给机器看的。我们通常会把`Error`方法返回的字符串打印到日志中，或者显示在控制台上。永远不要通过判断`Error`方法返回的字符串是否包含特定字符串，来决定错误处理的方式。**\n\n如果你是开发一个公共库，库的API返回了特定值的错误值。那么必须把这个特定值的错误定义为`public`，写在文档中。\n\n“高内聚、低耦合”是衡量公共库质量的一个重要方面，而返回特定错误值的方式，增加了公共库和调用代码的耦合性。让模块之间产生了依赖。\n\n\n### 自定义错误类型\n\n这种方式的典型用法如下：\n\n```go\n// 定义错误类型\ntype MyError struct {\n    Msg string\n    File string\n    Line int\n}\n\nfunc (e *MyError) Error() string {\n    return fmt.Sprintf(\"%s:%d: %s\", e.File, e.Line, e.Msg)\n}\n\n\n// 被调用函数\nfunc doSomething() {\n    // do something\n    return &MyError{\"Something happened\", \"server.go\", 42}\n}\n\n// 调用代码\nerr := doSomething()\nif err, ok := err.(SomeType); ok {    // 使用 类型断言 获得错误详细信息\n    //...\n}\n```\n\n这种方式相比于“返回和检查错误值”，很大一个优点在于可以将 底层错误 包起来一起返回给上层，这样可以提供更多的上下文信息。比如`os.PathError`：\n\n```go\n// PathError records an error and the operation\n// and file path that caused it.\ntype PathError struct {\n    Op string\n    Path string\n    Err error\n}\n\nfunc (e *PathError) Error() string\n```\n\n然而，这种方式依然会增加模块之间的依赖。\n\n\n### 隐藏内部细节的错误处理\n\n这种策略之所以叫“隐藏内部细节的错误处理”，是因为当上层代码碰到错误发生的时候，不知道错误的内部细节。\n\n**作为上层代码，你所需要知道的只是被调用函数是否正常工作。** 如果你接受这个原则，将极大降低模块之间的耦合性。\n\n```go\nimport “github.com/quux/bar”\n\nfunc fn() error {\n    x, err := bar.Foo()\n    if err != nil {\n        return err\n    }\n    // use x\n}\n```\n\n上面的例子中，`Foo`这个方法不返回的错误的具体内容。这样，`Foo`函数的开发者可以不断调整返回错误的内容来提供更多的错误信息，而不会破坏`Foo`提供的协议。这就是“隐藏内部细节”的内涵。\n\n\n## 最合适的错误处理策略\n\n上面我们提到了三种错误处理策略，其中第三种策略耦合性最低。然而，第三种方式也存在一些问题：\n\n- 如何获得更详细错误信息，比如`stack trace`，帮助定位错误原因\n- 如何优雅的处理错误\n    - 有些场景需要了解错误细节，比如网络调用，需要知道是否是瞬时的中断\n    - 是否每层捕捉到错误的时候都需要处理\n\n\n### 输出更详细的错误信息来定位问题\n\n```go\nfunc AuthenticateRequest(r *Request) error {\n    err := authenticate(r.User)\n    if err != nil {\n        return err  // No such file or directory\n    }\n    return nil\n}\n```\n\n上面这段代码，在我看来，在顶层打印错误的时候，只看到一个类似于\"No such file or directory\"的文字，从这段文字中，无法了解到错误是哪行代码产生的，也无法知道当时出错的调用堆栈。\n\n我们调整一下代码，如下：\n\n```go\nfunc AuthenticateRequest(r *Request) error {\n    err := authenticate(r.User)\n    if err != nil {\n        return fmt.Errorf(\"authenticate failed: %v\", err)    // authenticate failed: No such file or directory\n    }\n    return nil\n}\n```\n\n通过`fmt.Errorf`创建一个新的错误，添加更多的上下文信息到新的错误中，但这样仍不能解决上面提出的问题（错误发生的位置和调用堆栈）。\n\ngoErrorHandlingSample](https://github.com/EthanCai/goErrorHandlingSample)这个repo中的例子演示了，不同错误处理方式，输出的错误信息的区别。\n\n```\n> go run sample1/main.go\n\nopen ~/.settings.xml: no such file or directory\nexit status 1\n```\n\n```\n> go run sample2/main.go\n\ncould not read config: open failed: open ~/.settings.xml: no such file or directory\nexit status 1\n```\n\n```\n> go run sample3/main.go\n\ncould not read config: open failed: open ~/.settings.xml: no such file or directory\nexit status 1\n```\n\n```\n> go run sample4/main.go\n\nopen ~/.settings.xml: no such file or directory\nopen failed\nmain.ReadFile\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:15\nmain.ReadConfig\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:27\nmain.main\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32\nruntime.main\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195\nruntime.goexit\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337\ncould not read config\nmain.ReadConfig\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:28\nmain.main\n        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32\nruntime.main\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195\nruntime.goexit\n        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337\nexit status 1\n\n```\n\n`sample4/main.go`中将出错的代码行数也打印了出来，这样的日志，可以帮助我们更方便的定位问题原因。\n\n\n### 通过行为断言错误\n\n在有些场景下，仅仅知道是否出错是不够的。比如，和进程外其它服务通信，需要了解错误的属性，以决定是否需要重试操作。\n\n这种情况下，<u>不要判断错误值或者错误的类型，可以判断错误是否实现某个行为</u>。\n\n```go\ntype temporary interface {\n    Temporary() bool    // IsTemporary returns true if err is temporary.\n}\n\nfunc IsTemporary(err error) bool {\n    te, ok := err.(temporary)\n    return ok && te.Temporary()\n}\n```\n\n这种实现方式的好处在于，不需要知道具体的错误类型，也就不需要引用定义了错误类型的三方`package`。如果你是底层代码的开发者，哪天你想更换一个实现更好的`error`，也不用担心影响上层代码逻辑。如果你是上层代码的开发者，你只需要关注`error`是否实现了特定行为，不用担心引用的三方`package`升级后，程序逻辑失败。\n\n\n### 不要忽略错误，也不要重复处理错误\n\n遇到错误，而不去处理，导致信息缺失，会增加后期的运维成本\n\n```go\nfunc Write(w io.Writer, buf []byte) {\n    w.Write(buf)    // Write(p []byte) (n int, err error)，Write方法的定义见 https://golang.org/pkg/io/#Writer\n}\n```\n\n重复处理，添加了不必要的处理逻辑，导致信息冗余，也会增加后期的运维成本\n\n```go\nfunc Write(w io.Writer, buf []byte) error {\n    _, err := w.Write(buf)\n    if err != nil {\n        log.Println(\"unable to write:\", err)    // 第1次错误处理\n\n        return err\n    }\n    return nil\n}\n\nfunc main() {\n    // create writer and read data into buf\n\n    err := Write(w, buf)\n    if err != nil {\n        log.Println(\"Write error:\", err)        // 第2次错误处理\n        os.Exit(1)\n    }\n\n    os.Exit(0)\n}\n```\n\n## 补充的错误处理原则\n\n从稳定性视角出发，为了便于发现和分析问题：\n\n* 错误信息需要记录到日志\n* 错误量需要体现在metrics中\n\n# Package `github.com/pkg/errors` \n\n建议使用包 [`github.com/pkg/errors`](https://github.com/pkg/errors) 来处理错误。这个包提供这样几个主要的API：\n\n```go\n// 以下代码在errors.go中\n\n// New returns an error with the supplied message.\n// New also records the stack trace at the point it was called.\nfunc New(message string) error\n\n// Errorf formats according to a format specifier and returns the string\n// as a value that satisfies error.\n// Errorf also records the stack trace at the point it was called.\nfunc Errorf(format string, args ...interface{}) error\n\n// WithStack annotates err with a stack trace at the point WithStack was called.\n// If err is nil, WithStack returns nil.\nfunc WithStack(err error) error\n\n// Wrap returns an error annotating err with a stack trace\n// at the point Wrap is called, and the supplied message.\n// If err is nil, Wrap returns nil.\nfunc Wrap(err error, message string) error\n\n// Wrapf returns an error annotating err with a stack trace\n// at the point Wrapf is called, and the format specifier.\n// If err is nil, Wrapf returns nil.\nfunc Wrapf(err error, format string, args ...interface{}) error\n\n// WithMessage annotates err with a new message.\n// If err is nil, WithMessage returns nil.\nfunc WithMessage(err error, message string) error\n\n// WithMessagef annotates err with the format specifier.\n// If err is nil, WithMessagef returns nil.\nfunc WithMessagef(err error, format string, args ...interface{}) error\n\n// Cause returns the underlying cause of the error, if possible.\n// An error value has a cause if it implements the following\n// interface:\n//\n//     type causer interface {\n//            Cause() error\n//     }\n//\n// If the error does not implement Cause, the original error will\n// be returned. If the error is nil, nil will be returned without further\n// investigation.\nfunc Cause(err error) error\n\n\n\n// 以下代码在 go113.go 中\n\n// Is reports whether any error in err's chain matches target.\n//\n// The chain consists of err itself followed by the sequence of errors obtained by\n// repeatedly calling Unwrap.\n//\n// An error is considered to match a target if it is equal to that target or if\n// it implements a method Is(error) bool such that Is(target) returns true.\nfunc Is(err, target error) bool\n\n// As finds the first error in err's chain that matches target, and if so, sets\n// target to that error value and returns true.\n//\n// The chain consists of err itself followed by the sequence of errors obtained by\n// repeatedly calling Unwrap.\n//\n// An error matches target if the error's concrete value is assignable to the value\n// pointed to by target, or if the error has a method As(interface{}) bool such that\n// As(target) returns true. In the latter case, the As method is responsible for\n// setting target.\n//\n// As will panic if target is not a non-nil pointer to either a type that implements\n// error, or to any interface type. As returns false if err is nil.\nfunc As(err error, target interface{}) bool\n\n// Unwrap returns the result of calling the Unwrap method on err, if err's\n// type contains an Unwrap method returning error.\n// Otherwise, Unwrap returns nil.\nfunc Unwrap(err error) error\n```\n\n[`example_test.go`](https://github.com/pkg/errors/blob/master/example_test.go)有一些使用案例。\n\n# 各种场景下的错误处理案例\n\n## error相等判断\n\n当不确定待处理的error是否被包装时，不能直接使用相等进行判断。\n\n**例子**\n\n*Bad：*\n\n```go\nif err == EOF {\n}\n```\n\n*Good：*\n\n```go\nif errors.Is(err, EOF) {\t// it will succeed if err wraps EOF\n}\n```\n\n## error类型转换\n\n当不确定待处理的error是否被包装时，不能直接使用类型断言进行。\n\n**例子**\n\n*Bad：*\n\n```go\nnerr, ok := err.(*CError)\nif ok {\n}\n```\n\n*Good：*\n\n```go\nvar nerr *CError\nif errors.As(err, &nerr) {\t// it will succeed if err wraps an *CError\n  \t// nerr is set as *CError\n    ...\n}\n```\n\n## 如何向外暴露error\n\n**例子**\n\n*Bad：*\n\n```go\n// package io\nvar FileNotFoundErr = fmt.Errorf(\"file not found\")\n\n// package service\nif errors.Is(err, io.FileNotFoundErr) {\n}\n```\n\n*Good：*\n\n```go\n// package io\nvar fileNotFoundErr = fmt.Errorf(\"file not found\")\nfunc IsFileNotFoundErr(err) bool {\n    return errors.Is(err, fileNotFoundErr)\n}\n\n// package service\nif io.IsFileNotFoundErr(err) {\n}\n```\n\n## 程序启动时，如何处理依赖的三方资源无法连接 或者 不存在\n\n根据三方资源的对于业务逻辑的重要性，采取是强依赖、还是弱依赖的处理策略，比如：\n\n* 如果三方资源是 类似DB的强依赖 资源，启动时无法连接，记录错误并`panic`\n* 如果三方资源是 弱依赖的服务，启动时无法连接，记录错误但无需`panic`\n\n## 服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\n\n在没有安全要求的情况下，B尽量返回详细的错误信息（`message`、`stack trace` 等），方便看到错误信息时候，能够直接定位错误原因。\n\n在存在安全限制的场景下，B返回在安全限制以内尽量详细的错误信息，比如：\n\n* A是自有的C端的 客户端应用或者前端web应用，B不能返回`stack trace`\n* A是外部的应用，调用服务B，B不能返回 内部的错误`message`、`stack trace`\n\n## 数据访问层，使用gorm等orm框架查不到结果不应该报error\n\n数据访问层，使用gorm等orm框架查不到结果不应该报error，原因如下：\n\n* 从业务逻辑的角度来看，查不到结果 是一种正常的现象，不应当视为错误。比如，注册的时候检查账户是否已经存在，去掉订单的时候检查订单是否存在 等情况下，不应该将查不到数据视为错误。\n* 如果在业务逻辑里判断`err != gorm.errnotfound`，不符合开闭原则，如果后面要换一个数据库框架，需要改动业务逻辑代码\n\n数据访问层建议的处理方式：\n\n```go\n// Dao层的查询函数\nfunc GetByID(id int) (*Object, error) {\n\t\t// 查询逻辑\n\n    if err != nil && err != gorm.ErrRecordNotFound {\n        return nil, err// 仅在 err 是非ErrRecordNotFound类型的时候，才认为是错误\n    }\n\n    if err == gorm.ErrRecordNotFound {\n        return nil, nil\n    }\n\n    return &result, nil\n}\n```\n\n# 总结\n\n错误处理策略满足以下要求\n\n- 从代码结构的角度出发，不增加代码耦合度\n\n- 从服务稳定性的角度出发，便于发现和分析问题\n\n没有最好的策略，只有最合适的策略。在实际的项目开发过程中，不要拘泥于教条，灵活运用各种策略。让代码更健壮，让服务更稳定。\n\n\n# 参考\n\n- The Go Blog\n    - [Error handling in Go](https://blog.golang.org/error-handling-and-go)\n    - [Defer, Panic, and Recover](https://blog.golang.org/defer-panic-and-recover)\n- Dave Cheney\n    - [presentation on my philosophy for error handling](https://dave.cheney.net/paste/gocon-spring-2016.pdf)\n    - [Don’t just check errors, handle them gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully)\n    - [Stack traces and the errors package](https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package)\n- Go Packages\n    - [errors](https://golang.org/pkg/errors/)\n    - [runtime](https://golang.org/pkg/runtime/)\n- pkg: Artisanal, hand crafted, barrel aged, Go packages\n    - [github.com/pkg/errors](https://godoc.org/github.com/pkg/errors)\n- [Go 2 Draft Designs](https://go.googlesource.com/proposal/+/master/design/go2draft.md)\n    + [go2draft-error-handling-overview.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling-overview.md)\n    + [go2draft-error-handling.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling.md)\n    + [go2draft-error-inspection.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-inspection.md)\n    + [go2draft-error-printing.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-printing.md)\n    + [go2draft-error-values-overview.md](https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-values-overview.md)\n\n","slug":"error-handling-in-go","published":1,"updated":"2025-05-19T15:07:15.842Z","_id":"cm9zwlzc60008fdjh0wb5efet","comments":1,"layout":"post","photos":[],"content":"<img src=\"/2017/12/29/error-handling-in-go/d2a2d12e1a00f819d7fd7af4b536efa2.png\" class=\"\">\n<p><small><em>上图来自 <a href=\"https://go-proverbs.github.io/\" title=\"\" target=\"\">go proverbs</a></em></small></p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。</p>\n<p>Go语言没有提供像Java、C#语言中的<code>try...catch</code>异常处理方式，而是通过函数返回值逐层往上抛。</p>\n<p>这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码啰嗦。</p>\n<h1 id=\"Go标准包提供的错误处理功能\"><a href=\"#Go标准包提供的错误处理功能\" class=\"headerlink\" title=\"Go标准包提供的错误处理功能\"></a>Go标准包提供的错误处理功能</h1><p><code>error</code>是个<code>interface</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">error</span> <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何创建<code>error</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sqrt</span><span class=\"params\">(f <span class=\"type\">float64</span>)</span></span> (<span class=\"type\">float64</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">&quot;math: square root of negative number&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// implementation</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// example 2</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>, fmt.Errorf(<span class=\"string\">&quot;math: square root of negative number %g&quot;</span>, f)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何自定义<code>error</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// errorString is a trivial implementation of error.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    s <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义<code>error</code>类型可以拥有一些附加方法。比如<code>net.Error</code>定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">error</span></span><br><span class=\"line\">    Timeout() <span class=\"type\">bool</span>   <span class=\"comment\">// Is the error a timeout?</span></span><br><span class=\"line\">    Temporary() <span class=\"type\">bool</span> <span class=\"comment\">// Is the error temporary?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>网络客户端程序代码可以使用类型断言判断网络错误是瞬时错误还是永久错误。比如，一个网络爬虫可以在碰到瞬时错误的时候，等待一段时间然后重试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class=\"line\">    time.Sleep(<span class=\"number\">1e9</span>)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"错误处理策略\"><a href=\"#错误处理策略\" class=\"headerlink\" title=\"错误处理策略\"></a>错误处理策略</h1><p>实际项目开发、运维过程中，会经常碰到如下问题：</p>\n<ul>\n<li>函数该如何返回错误，是用值，还是用特殊的错误类型</li>\n<li>如何检查被调用函数返回的错误，是判断错误值，还是用类型断言</li>\n<li>程序中每层代码在碰到错误的时候，是每层都处理，还是只用在最上层处理，如何做到优雅</li>\n<li>日志中的异常信息不够完整、缺少stack strace，不方便定位错误原因</li>\n</ul>\n<p>上面的问题都涉及到该如何处理错误，下面来介绍了生产级Go语言代码中如何处理错误。</p>\n<h2 id=\"三种错误处理策略\"><a href=\"#三种错误处理策略\" class=\"headerlink\" title=\"三种错误处理策略\"></a>三种错误处理策略</h2><p>Go语言中一般有三种错误处理策略：</p>\n<ul>\n<li><strong>返回和检查错误值</strong>：通过特定值表示成功和不同的错误，上层代码检查错误的值，来判断被调用<code>func</code>的执行状态</li>\n<li><strong>自定义错误类型</strong>：通过自定义的错误类型来表示特定的错误，上层代码通过类型断言判断错误的类型</li>\n<li><strong>隐藏内部细节的错误处理</strong>：上层代码不应该知道（依赖）被调用函数返回错误的任何细节</li>\n</ul>\n<h3 id=\"返回和检查错误值\"><a href=\"#返回和检查错误值\" class=\"headerlink\" title=\"返回和检查错误值\"></a>返回和检查错误值</h3><p>这种方式在其它语言中，也很常见。比如，<a href=\"http://www.virtsync.com/c-error-codes-include-errno\">C Error Codes in Linux</a>。</p>\n<p>go标准库中提供一些例子：</p>\n<ul>\n<li><code>io.EOF</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/io/io.go#L38\">这里</a></li>\n<li><code>syscall.ENOENT</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/syscall/zerrors_linux_amd64.go#L1280\">这里</a></li>\n<li><code>go/build.NoGoError</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/go/build/build.go#L446\">这里</a></li>\n<li><code>path/filepath.SkipDir</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/path/filepath/path.go#L331\">这里</a></li>\n</ul>\n<p><u>这种策略是最不灵活的错误处理策略，上层代码需要判断返回错误值是否等于特定值。如果想修改返回的错误值，则会破坏上层调用代码的逻辑。</u></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">n, err := r.Read(buf)   <span class=\"comment\">// 如果修改 r.Read，在读到文件结尾时，返回另外一个 error，比如 io.END，而不是 io.EOF，则所有调用 r.Read 的代码都必须修改</span></span><br><span class=\"line\">buf = buf[:n]</span><br><span class=\"line\"><span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">    log.Fatal(<span class=\"string\">&quot;read failed:&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种场景也属于这类情况，上层代码通过检查错误的<code>Error()</code>方法的返回值是否包含特定字符串，来判定如何进行错误处理。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readfile</span><span class=\"params\">(path <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    err := openfile(path)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot open file: %v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    err := readfile(<span class=\"string\">&quot;.bashrc&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> strings.Contains(<span class=\"type\">error</span>.Error(), <span class=\"string\">&quot;not found&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle error</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong><code>error</code> interface 的 <code>Error</code> 方法的输出，是给人看的，不是给机器看的。我们通常会把<code>Error</code>方法返回的字符串打印到日志中，或者显示在控制台上。永远不要通过判断<code>Error</code>方法返回的字符串是否包含特定字符串，来决定错误处理的方式。</strong></p>\n</blockquote>\n<p>如果你是开发一个公共库，库的API返回了特定值的错误值。那么必须把这个特定值的错误定义为<code>public</code>，写在文档中。</p>\n<p>“高内聚、低耦合”是衡量公共库质量的一个重要方面，而返回特定错误值的方式，增加了公共库和调用代码的耦合性。让模块之间产生了依赖。</p>\n<h3 id=\"自定义错误类型\"><a href=\"#自定义错误类型\" class=\"headerlink\" title=\"自定义错误类型\"></a>自定义错误类型</h3><p>这种方式的典型用法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义错误类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Msg <span class=\"type\">string</span></span><br><span class=\"line\">    File <span class=\"type\">string</span></span><br><span class=\"line\">    Line <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *MyError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%s:%d: %s&quot;</span>, e.File, e.Line, e.Msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被调用函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;MyError&#123;<span class=\"string\">&quot;Something happened&quot;</span>, <span class=\"string\">&quot;server.go&quot;</span>, <span class=\"number\">42</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用代码</span></span><br><span class=\"line\">err := doSomething()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err, ok := err.(SomeType); ok &#123;    <span class=\"comment\">// 使用 类型断言 获得错误详细信息</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式相比于“返回和检查错误值”，很大一个优点在于可以将 底层错误 包起来一起返回给上层，这样可以提供更多的上下文信息。比如<code>os.PathError</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PathError records an error and the operation</span></span><br><span class=\"line\"><span class=\"comment\">// and file path that caused it.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PathError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Op <span class=\"type\">string</span></span><br><span class=\"line\">    Path <span class=\"type\">string</span></span><br><span class=\"line\">    Err <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *PathError)</span></span> Error() <span class=\"type\">string</span></span><br></pre></td></tr></table></figure>\n\n<p>然而，这种方式依然会增加模块之间的依赖。</p>\n<h3 id=\"隐藏内部细节的错误处理\"><a href=\"#隐藏内部细节的错误处理\" class=\"headerlink\" title=\"隐藏内部细节的错误处理\"></a>隐藏内部细节的错误处理</h3><p>这种策略之所以叫“隐藏内部细节的错误处理”，是因为当上层代码碰到错误发生的时候，不知道错误的内部细节。</p>\n<p><strong>作为上层代码，你所需要知道的只是被调用函数是否正常工作。</strong> 如果你接受这个原则，将极大降低模块之间的耦合性。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> “github.com/quux/bar”</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fn</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    x, err := bar.Foo()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// use x</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，<code>Foo</code>这个方法不返回的错误的具体内容。这样，<code>Foo</code>函数的开发者可以不断调整返回错误的内容来提供更多的错误信息，而不会破坏<code>Foo</code>提供的协议。这就是“隐藏内部细节”的内涵。</p>\n<h2 id=\"最合适的错误处理策略\"><a href=\"#最合适的错误处理策略\" class=\"headerlink\" title=\"最合适的错误处理策略\"></a>最合适的错误处理策略</h2><p>上面我们提到了三种错误处理策略，其中第三种策略耦合性最低。然而，第三种方式也存在一些问题：</p>\n<ul>\n<li>如何获得更详细错误信息，比如<code>stack trace</code>，帮助定位错误原因</li>\n<li>如何优雅的处理错误<ul>\n<li>有些场景需要了解错误细节，比如网络调用，需要知道是否是瞬时的中断</li>\n<li>是否每层捕捉到错误的时候都需要处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"输出更详细的错误信息来定位问题\"><a href=\"#输出更详细的错误信息来定位问题\" class=\"headerlink\" title=\"输出更详细的错误信息来定位问题\"></a>输出更详细的错误信息来定位问题</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AuthenticateRequest</span><span class=\"params\">(r *Request)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    err := authenticate(r.User)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err  <span class=\"comment\">// No such file or directory</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码，在我看来，在顶层打印错误的时候，只看到一个类似于”No such file or directory”的文字，从这段文字中，无法了解到错误是哪行代码产生的，也无法知道当时出错的调用堆栈。</p>\n<p>我们调整一下代码，如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AuthenticateRequest</span><span class=\"params\">(r *Request)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    err := authenticate(r.User)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;authenticate failed: %v&quot;</span>, err)    <span class=\"comment\">// authenticate failed: No such file or directory</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>fmt.Errorf</code>创建一个新的错误，添加更多的上下文信息到新的错误中，但这样仍不能解决上面提出的问题（错误发生的位置和调用堆栈）。</p>\n<p>goErrorHandlingSample](<a href=\"https://github.com/EthanCai/goErrorHandlingSample)%E8%BF%99%E4%B8%AArepo%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%E6%BC%94%E7%A4%BA%E4%BA%86%EF%BC%8C%E4%B8%8D%E5%90%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BE%93%E5%87%BA%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82\">https://github.com/EthanCai/goErrorHandlingSample)这个repo中的例子演示了，不同错误处理方式，输出的错误信息的区别。</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample1/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">exit status 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample2/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">could not read config: open failed: open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">exit status 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample3/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">could not read config: open failed: open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">exit status 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample4/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">open failed</span><br><span class=\"line\">main.ReadFile</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:15</span><br><span class=\"line\">main.ReadConfig</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:27</span><br><span class=\"line\">main.main</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32</span><br><span class=\"line\">runtime.main</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195</span><br><span class=\"line\">runtime.goexit</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337</span><br><span class=\"line\">could not read config</span><br><span class=\"line\">main.ReadConfig</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:28</span><br><span class=\"line\">main.main</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32</span><br><span class=\"line\">runtime.main</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195</span><br><span class=\"line\">runtime.goexit</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337</span><br><span class=\"line\">exit status 1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>sample4/main.go</code>中将出错的代码行数也打印了出来，这样的日志，可以帮助我们更方便的定位问题原因。</p>\n<h3 id=\"通过行为断言错误\"><a href=\"#通过行为断言错误\" class=\"headerlink\" title=\"通过行为断言错误\"></a>通过行为断言错误</h3><p>在有些场景下，仅仅知道是否出错是不够的。比如，和进程外其它服务通信，需要了解错误的属性，以决定是否需要重试操作。</p>\n<p>这种情况下，<u>不要判断错误值或者错误的类型，可以判断错误是否实现某个行为</u>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> temporary <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Temporary() <span class=\"type\">bool</span>    <span class=\"comment\">// IsTemporary returns true if err is temporary.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsTemporary</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    te, ok := err.(temporary)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ok &amp;&amp; te.Temporary()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种实现方式的好处在于，不需要知道具体的错误类型，也就不需要引用定义了错误类型的三方<code>package</code>。如果你是底层代码的开发者，哪天你想更换一个实现更好的<code>error</code>，也不用担心影响上层代码逻辑。如果你是上层代码的开发者，你只需要关注<code>error</code>是否实现了特定行为，不用担心引用的三方<code>package</code>升级后，程序逻辑失败。</p>\n<h3 id=\"不要忽略错误，也不要重复处理错误\"><a href=\"#不要忽略错误，也不要重复处理错误\" class=\"headerlink\" title=\"不要忽略错误，也不要重复处理错误\"></a>不要忽略错误，也不要重复处理错误</h3><p>遇到错误，而不去处理，导致信息缺失，会增加后期的运维成本</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer, buf []<span class=\"type\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">    w.Write(buf)    <span class=\"comment\">// Write(p []byte) (n int, err error)，Write方法的定义见 https://golang.org/pkg/io/#Writer</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重复处理，添加了不必要的处理逻辑，导致信息冗余，也会增加后期的运维成本</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer, buf []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    _, err := w.Write(buf)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Println(<span class=\"string\">&quot;unable to write:&quot;</span>, err)    <span class=\"comment\">// 第1次错误处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create writer and read data into buf</span></span><br><span class=\"line\"></span><br><span class=\"line\">    err := Write(w, buf)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Println(<span class=\"string\">&quot;Write error:&quot;</span>, err)        <span class=\"comment\">// 第2次错误处理</span></span><br><span class=\"line\">        os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    os.Exit(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充的错误处理原则\"><a href=\"#补充的错误处理原则\" class=\"headerlink\" title=\"补充的错误处理原则\"></a>补充的错误处理原则</h2><p>从稳定性视角出发，为了便于发现和分析问题：</p>\n<ul>\n<li>错误信息需要记录到日志</li>\n<li>错误量需要体现在metrics中</li>\n</ul>\n<h1 id=\"Package-github-com-pkg-errors\"><a href=\"#Package-github-com-pkg-errors\" class=\"headerlink\" title=\"Package github.com/pkg/errors\"></a>Package <code>github.com/pkg/errors</code></h1><p>建议使用包 <a href=\"https://github.com/pkg/errors\"><code>github.com/pkg/errors</code></a> 来处理错误。这个包提供这样几个主要的API：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下代码在errors.go中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New returns an error with the supplied message.</span></span><br><span class=\"line\"><span class=\"comment\">// New also records the stack trace at the point it was called.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(message <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Errorf formats according to a format specifier and returns the string</span></span><br><span class=\"line\"><span class=\"comment\">// as a value that satisfies error.</span></span><br><span class=\"line\"><span class=\"comment\">// Errorf also records the stack trace at the point it was called.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Errorf</span><span class=\"params\">(format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WithStack annotates err with a stack trace at the point WithStack was called.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, WithStack returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithStack</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Wrap returns an error annotating err with a stack trace</span></span><br><span class=\"line\"><span class=\"comment\">// at the point Wrap is called, and the supplied message.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, Wrap returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Wrap</span><span class=\"params\">(err <span class=\"type\">error</span>, message <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Wrapf returns an error annotating err with a stack trace</span></span><br><span class=\"line\"><span class=\"comment\">// at the point Wrapf is called, and the format specifier.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, Wrapf returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Wrapf</span><span class=\"params\">(err <span class=\"type\">error</span>, format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WithMessage annotates err with a new message.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, WithMessage returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithMessage</span><span class=\"params\">(err <span class=\"type\">error</span>, message <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WithMessagef annotates err with the format specifier.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, WithMessagef returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithMessagef</span><span class=\"params\">(err <span class=\"type\">error</span>, format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cause returns the underlying cause of the error, if possible.</span></span><br><span class=\"line\"><span class=\"comment\">// An error value has a cause if it implements the following</span></span><br><span class=\"line\"><span class=\"comment\">// interface:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//     type causer interface &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            Cause() error</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If the error does not implement Cause, the original error will</span></span><br><span class=\"line\"><span class=\"comment\">// be returned. If the error is nil, nil will be returned without further</span></span><br><span class=\"line\"><span class=\"comment\">// investigation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Cause</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下代码在 go113.go 中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Is reports whether any error in err&#x27;s chain matches target.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The chain consists of err itself followed by the sequence of errors obtained by</span></span><br><span class=\"line\"><span class=\"comment\">// repeatedly calling Unwrap.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// An error is considered to match a target if it is equal to that target or if</span></span><br><span class=\"line\"><span class=\"comment\">// it implements a method Is(error) bool such that Is(target) returns true.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Is</span><span class=\"params\">(err, target <span class=\"type\">error</span>)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// As finds the first error in err&#x27;s chain that matches target, and if so, sets</span></span><br><span class=\"line\"><span class=\"comment\">// target to that error value and returns true.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The chain consists of err itself followed by the sequence of errors obtained by</span></span><br><span class=\"line\"><span class=\"comment\">// repeatedly calling Unwrap.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// An error matches target if the error&#x27;s concrete value is assignable to the value</span></span><br><span class=\"line\"><span class=\"comment\">// pointed to by target, or if the error has a method As(interface&#123;&#125;) bool such that</span></span><br><span class=\"line\"><span class=\"comment\">// As(target) returns true. In the latter case, the As method is responsible for</span></span><br><span class=\"line\"><span class=\"comment\">// setting target.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// As will panic if target is not a non-nil pointer to either a type that implements</span></span><br><span class=\"line\"><span class=\"comment\">// error, or to any interface type. As returns false if err is nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">As</span><span class=\"params\">(err <span class=\"type\">error</span>, target <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unwrap returns the result of calling the Unwrap method on err, if err&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\">// type contains an Unwrap method returning error.</span></span><br><span class=\"line\"><span class=\"comment\">// Otherwise, Unwrap returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unwrap</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">error</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/pkg/errors/blob/master/example_test.go\"><code>example_test.go</code></a>有一些使用案例。</p>\n<h1 id=\"各种场景下的错误处理案例\"><a href=\"#各种场景下的错误处理案例\" class=\"headerlink\" title=\"各种场景下的错误处理案例\"></a>各种场景下的错误处理案例</h1><h2 id=\"error相等判断\"><a href=\"#error相等判断\" class=\"headerlink\" title=\"error相等判断\"></a>error相等判断</h2><p>当不确定待处理的error是否被包装时，不能直接使用相等进行判断。</p>\n<p><strong>例子</strong></p>\n<p><em>Bad：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err == EOF &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Good：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, EOF) &#123;\t<span class=\"comment\">// it will succeed if err wraps EOF</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"error类型转换\"><a href=\"#error类型转换\" class=\"headerlink\" title=\"error类型转换\"></a>error类型转换</h2><p>当不确定待处理的error是否被包装时，不能直接使用类型断言进行。</p>\n<p><strong>例子</strong></p>\n<p><em>Bad：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nerr, ok := err.(*CError)</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Good：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nerr *CError</span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.As(err, &amp;nerr) &#123;\t<span class=\"comment\">// it will succeed if err wraps an *CError</span></span><br><span class=\"line\">  \t<span class=\"comment\">// nerr is set as *CError</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何向外暴露error\"><a href=\"#如何向外暴露error\" class=\"headerlink\" title=\"如何向外暴露error\"></a>如何向外暴露error</h2><p><strong>例子</strong></p>\n<p><em>Bad：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package io</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> FileNotFoundErr = fmt.Errorf(<span class=\"string\">&quot;file not found&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// package service</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, io.FileNotFoundErr) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Good：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package io</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fileNotFoundErr = fmt.Errorf(<span class=\"string\">&quot;file not found&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsFileNotFoundErr</span><span class=\"params\">(err)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.Is(err, fileNotFoundErr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// package service</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> io.IsFileNotFoundErr(err) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序启动时，如何处理依赖的三方资源无法连接-或者-不存在\"><a href=\"#程序启动时，如何处理依赖的三方资源无法连接-或者-不存在\" class=\"headerlink\" title=\"程序启动时，如何处理依赖的三方资源无法连接 或者 不存在\"></a>程序启动时，如何处理依赖的三方资源无法连接 或者 不存在</h2><p>根据三方资源的对于业务逻辑的重要性，采取是强依赖、还是弱依赖的处理策略，比如：</p>\n<ul>\n<li>如果三方资源是 类似DB的强依赖 资源，启动时无法连接，记录错误并<code>panic</code></li>\n<li>如果三方资源是 弱依赖的服务，启动时无法连接，记录错误但无需<code>panic</code></li>\n</ul>\n<h2 id=\"服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\"><a href=\"#服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\" class=\"headerlink\" title=\"服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\"></a>服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方</h2><p>在没有安全要求的情况下，B尽量返回详细的错误信息（<code>message</code>、<code>stack trace</code> 等），方便看到错误信息时候，能够直接定位错误原因。</p>\n<p>在存在安全限制的场景下，B返回在安全限制以内尽量详细的错误信息，比如：</p>\n<ul>\n<li>A是自有的C端的 客户端应用或者前端web应用，B不能返回<code>stack trace</code></li>\n<li>A是外部的应用，调用服务B，B不能返回 内部的错误<code>message</code>、<code>stack trace</code></li>\n</ul>\n<h2 id=\"数据访问层，使用gorm等orm框架查不到结果不应该报error\"><a href=\"#数据访问层，使用gorm等orm框架查不到结果不应该报error\" class=\"headerlink\" title=\"数据访问层，使用gorm等orm框架查不到结果不应该报error\"></a>数据访问层，使用gorm等orm框架查不到结果不应该报error</h2><p>数据访问层，使用gorm等orm框架查不到结果不应该报error，原因如下：</p>\n<ul>\n<li>从业务逻辑的角度来看，查不到结果 是一种正常的现象，不应当视为错误。比如，注册的时候检查账户是否已经存在，去掉订单的时候检查订单是否存在 等情况下，不应该将查不到数据视为错误。</li>\n<li>如果在业务逻辑里判断<code>err != gorm.errnotfound</code>，不符合开闭原则，如果后面要换一个数据库框架，需要改动业务逻辑代码</li>\n</ul>\n<p>数据访问层建议的处理方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dao层的查询函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetByID</span><span class=\"params\">(id <span class=\"type\">int</span>)</span></span> (*Object, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 查询逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; err != gorm.ErrRecordNotFound &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err<span class=\"comment\">// 仅在 err 是非ErrRecordNotFound类型的时候，才认为是错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;result, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>错误处理策略满足以下要求</p>\n<ul>\n<li><p>从代码结构的角度出发，不增加代码耦合度</p>\n</li>\n<li><p>从服务稳定性的角度出发，便于发现和分析问题</p>\n</li>\n</ul>\n<p>没有最好的策略，只有最合适的策略。在实际的项目开发过程中，不要拘泥于教条，灵活运用各种策略。让代码更健壮，让服务更稳定。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>The Go Blog<ul>\n<li><a href=\"https://blog.golang.org/error-handling-and-go\">Error handling in Go</a></li>\n<li><a href=\"https://blog.golang.org/defer-panic-and-recover\">Defer, Panic, and Recover</a></li>\n</ul>\n</li>\n<li>Dave Cheney<ul>\n<li><a href=\"https://dave.cheney.net/paste/gocon-spring-2016.pdf\">presentation on my philosophy for error handling</a></li>\n<li><a href=\"https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully\">Don’t just check errors, handle them gracefully</a></li>\n<li><a href=\"https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package\">Stack traces and the errors package</a></li>\n</ul>\n</li>\n<li>Go Packages<ul>\n<li><a href=\"https://golang.org/pkg/errors/\">errors</a></li>\n<li><a href=\"https://golang.org/pkg/runtime/\">runtime</a></li>\n</ul>\n</li>\n<li>pkg: Artisanal, hand crafted, barrel aged, Go packages<ul>\n<li><a href=\"https://godoc.org/github.com/pkg/errors\">github.com&#x2F;pkg&#x2F;errors</a></li>\n</ul>\n</li>\n<li><a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft.md\">Go 2 Draft Designs</a><ul>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling-overview.md\">go2draft-error-handling-overview.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling.md\">go2draft-error-handling.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-inspection.md\">go2draft-error-inspection.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-printing.md\">go2draft-error-printing.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-values-overview.md\">go2draft-error-values-overview.md</a></li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<img src=\"/2017/12/29/error-handling-in-go/d2a2d12e1a00f819d7fd7af4b536efa2.png\" class=\"\">\n<p><small><em>上图来自 <a href=\"https://go-proverbs.github.io/\" title=\"\" target=\"\">go proverbs</a></em></small></p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。</p>\n<p>Go语言没有提供像Java、C#语言中的<code>try...catch</code>异常处理方式，而是通过函数返回值逐层往上抛。</p>\n<p>这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码啰嗦。</p>\n<h1 id=\"Go标准包提供的错误处理功能\"><a href=\"#Go标准包提供的错误处理功能\" class=\"headerlink\" title=\"Go标准包提供的错误处理功能\"></a>Go标准包提供的错误处理功能</h1><p><code>error</code>是个<code>interface</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">error</span> <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何创建<code>error</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sqrt</span><span class=\"params\">(f <span class=\"type\">float64</span>)</span></span> (<span class=\"type\">float64</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">&quot;math: square root of negative number&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// implementation</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// example 2</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>, fmt.Errorf(<span class=\"string\">&quot;math: square root of negative number %g&quot;</span>, f)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何自定义<code>error</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// errorString is a trivial implementation of error.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    s <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义<code>error</code>类型可以拥有一些附加方法。比如<code>net.Error</code>定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">error</span></span><br><span class=\"line\">    Timeout() <span class=\"type\">bool</span>   <span class=\"comment\">// Is the error a timeout?</span></span><br><span class=\"line\">    Temporary() <span class=\"type\">bool</span> <span class=\"comment\">// Is the error temporary?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>网络客户端程序代码可以使用类型断言判断网络错误是瞬时错误还是永久错误。比如，一个网络爬虫可以在碰到瞬时错误的时候，等待一段时间然后重试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class=\"line\">    time.Sleep(<span class=\"number\">1e9</span>)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"错误处理策略\"><a href=\"#错误处理策略\" class=\"headerlink\" title=\"错误处理策略\"></a>错误处理策略</h1><p>实际项目开发、运维过程中，会经常碰到如下问题：</p>\n<ul>\n<li>函数该如何返回错误，是用值，还是用特殊的错误类型</li>\n<li>如何检查被调用函数返回的错误，是判断错误值，还是用类型断言</li>\n<li>程序中每层代码在碰到错误的时候，是每层都处理，还是只用在最上层处理，如何做到优雅</li>\n<li>日志中的异常信息不够完整、缺少stack strace，不方便定位错误原因</li>\n</ul>\n<p>上面的问题都涉及到该如何处理错误，下面来介绍了生产级Go语言代码中如何处理错误。</p>\n<h2 id=\"三种错误处理策略\"><a href=\"#三种错误处理策略\" class=\"headerlink\" title=\"三种错误处理策略\"></a>三种错误处理策略</h2><p>Go语言中一般有三种错误处理策略：</p>\n<ul>\n<li><strong>返回和检查错误值</strong>：通过特定值表示成功和不同的错误，上层代码检查错误的值，来判断被调用<code>func</code>的执行状态</li>\n<li><strong>自定义错误类型</strong>：通过自定义的错误类型来表示特定的错误，上层代码通过类型断言判断错误的类型</li>\n<li><strong>隐藏内部细节的错误处理</strong>：上层代码不应该知道（依赖）被调用函数返回错误的任何细节</li>\n</ul>\n<h3 id=\"返回和检查错误值\"><a href=\"#返回和检查错误值\" class=\"headerlink\" title=\"返回和检查错误值\"></a>返回和检查错误值</h3><p>这种方式在其它语言中，也很常见。比如，<a href=\"http://www.virtsync.com/c-error-codes-include-errno\">C Error Codes in Linux</a>。</p>\n<p>go标准库中提供一些例子：</p>\n<ul>\n<li><code>io.EOF</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/io/io.go#L38\">这里</a></li>\n<li><code>syscall.ENOENT</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/syscall/zerrors_linux_amd64.go#L1280\">这里</a></li>\n<li><code>go/build.NoGoError</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/go/build/build.go#L446\">这里</a></li>\n<li><code>path/filepath.SkipDir</code>: 参考<a href=\"https://github.com/golang/go/blob/master/src/path/filepath/path.go#L331\">这里</a></li>\n</ul>\n<p><u>这种策略是最不灵活的错误处理策略，上层代码需要判断返回错误值是否等于特定值。如果想修改返回的错误值，则会破坏上层调用代码的逻辑。</u></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">n, err := r.Read(buf)   <span class=\"comment\">// 如果修改 r.Read，在读到文件结尾时，返回另外一个 error，比如 io.END，而不是 io.EOF，则所有调用 r.Read 的代码都必须修改</span></span><br><span class=\"line\">buf = buf[:n]</span><br><span class=\"line\"><span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">    log.Fatal(<span class=\"string\">&quot;read failed:&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种场景也属于这类情况，上层代码通过检查错误的<code>Error()</code>方法的返回值是否包含特定字符串，来判定如何进行错误处理。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readfile</span><span class=\"params\">(path <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    err := openfile(path)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot open file: %v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    err := readfile(<span class=\"string\">&quot;.bashrc&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> strings.Contains(<span class=\"type\">error</span>.Error(), <span class=\"string\">&quot;not found&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle error</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong><code>error</code> interface 的 <code>Error</code> 方法的输出，是给人看的，不是给机器看的。我们通常会把<code>Error</code>方法返回的字符串打印到日志中，或者显示在控制台上。永远不要通过判断<code>Error</code>方法返回的字符串是否包含特定字符串，来决定错误处理的方式。</strong></p>\n</blockquote>\n<p>如果你是开发一个公共库，库的API返回了特定值的错误值。那么必须把这个特定值的错误定义为<code>public</code>，写在文档中。</p>\n<p>“高内聚、低耦合”是衡量公共库质量的一个重要方面，而返回特定错误值的方式，增加了公共库和调用代码的耦合性。让模块之间产生了依赖。</p>\n<h3 id=\"自定义错误类型\"><a href=\"#自定义错误类型\" class=\"headerlink\" title=\"自定义错误类型\"></a>自定义错误类型</h3><p>这种方式的典型用法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义错误类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Msg <span class=\"type\">string</span></span><br><span class=\"line\">    File <span class=\"type\">string</span></span><br><span class=\"line\">    Line <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *MyError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%s:%d: %s&quot;</span>, e.File, e.Line, e.Msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被调用函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;MyError&#123;<span class=\"string\">&quot;Something happened&quot;</span>, <span class=\"string\">&quot;server.go&quot;</span>, <span class=\"number\">42</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用代码</span></span><br><span class=\"line\">err := doSomething()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err, ok := err.(SomeType); ok &#123;    <span class=\"comment\">// 使用 类型断言 获得错误详细信息</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式相比于“返回和检查错误值”，很大一个优点在于可以将 底层错误 包起来一起返回给上层，这样可以提供更多的上下文信息。比如<code>os.PathError</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PathError records an error and the operation</span></span><br><span class=\"line\"><span class=\"comment\">// and file path that caused it.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PathError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Op <span class=\"type\">string</span></span><br><span class=\"line\">    Path <span class=\"type\">string</span></span><br><span class=\"line\">    Err <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *PathError)</span></span> Error() <span class=\"type\">string</span></span><br></pre></td></tr></table></figure>\n\n<p>然而，这种方式依然会增加模块之间的依赖。</p>\n<h3 id=\"隐藏内部细节的错误处理\"><a href=\"#隐藏内部细节的错误处理\" class=\"headerlink\" title=\"隐藏内部细节的错误处理\"></a>隐藏内部细节的错误处理</h3><p>这种策略之所以叫“隐藏内部细节的错误处理”，是因为当上层代码碰到错误发生的时候，不知道错误的内部细节。</p>\n<p><strong>作为上层代码，你所需要知道的只是被调用函数是否正常工作。</strong> 如果你接受这个原则，将极大降低模块之间的耦合性。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> “github.com/quux/bar”</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fn</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    x, err := bar.Foo()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// use x</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，<code>Foo</code>这个方法不返回的错误的具体内容。这样，<code>Foo</code>函数的开发者可以不断调整返回错误的内容来提供更多的错误信息，而不会破坏<code>Foo</code>提供的协议。这就是“隐藏内部细节”的内涵。</p>\n<h2 id=\"最合适的错误处理策略\"><a href=\"#最合适的错误处理策略\" class=\"headerlink\" title=\"最合适的错误处理策略\"></a>最合适的错误处理策略</h2><p>上面我们提到了三种错误处理策略，其中第三种策略耦合性最低。然而，第三种方式也存在一些问题：</p>\n<ul>\n<li>如何获得更详细错误信息，比如<code>stack trace</code>，帮助定位错误原因</li>\n<li>如何优雅的处理错误<ul>\n<li>有些场景需要了解错误细节，比如网络调用，需要知道是否是瞬时的中断</li>\n<li>是否每层捕捉到错误的时候都需要处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"输出更详细的错误信息来定位问题\"><a href=\"#输出更详细的错误信息来定位问题\" class=\"headerlink\" title=\"输出更详细的错误信息来定位问题\"></a>输出更详细的错误信息来定位问题</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AuthenticateRequest</span><span class=\"params\">(r *Request)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    err := authenticate(r.User)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err  <span class=\"comment\">// No such file or directory</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码，在我看来，在顶层打印错误的时候，只看到一个类似于”No such file or directory”的文字，从这段文字中，无法了解到错误是哪行代码产生的，也无法知道当时出错的调用堆栈。</p>\n<p>我们调整一下代码，如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AuthenticateRequest</span><span class=\"params\">(r *Request)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    err := authenticate(r.User)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;authenticate failed: %v&quot;</span>, err)    <span class=\"comment\">// authenticate failed: No such file or directory</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>fmt.Errorf</code>创建一个新的错误，添加更多的上下文信息到新的错误中，但这样仍不能解决上面提出的问题（错误发生的位置和调用堆栈）。</p>\n<p>goErrorHandlingSample](<a href=\"https://github.com/EthanCai/goErrorHandlingSample)%E8%BF%99%E4%B8%AArepo%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%E6%BC%94%E7%A4%BA%E4%BA%86%EF%BC%8C%E4%B8%8D%E5%90%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BE%93%E5%87%BA%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82\">https://github.com/EthanCai/goErrorHandlingSample)这个repo中的例子演示了，不同错误处理方式，输出的错误信息的区别。</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample1/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">exit status 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample2/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">could not read config: open failed: open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">exit status 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample3/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">could not read config: open failed: open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">exit status 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; go run sample4/main.go</span><br><span class=\"line\"></span><br><span class=\"line\">open ~/.settings.xml: no such file or directory</span><br><span class=\"line\">open failed</span><br><span class=\"line\">main.ReadFile</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:15</span><br><span class=\"line\">main.ReadConfig</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:27</span><br><span class=\"line\">main.main</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32</span><br><span class=\"line\">runtime.main</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195</span><br><span class=\"line\">runtime.goexit</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337</span><br><span class=\"line\">could not read config</span><br><span class=\"line\">main.ReadConfig</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:28</span><br><span class=\"line\">main.main</span><br><span class=\"line\">        ~/go/src/github.com/ethancai/goErrorHandlingSample/sample4/main.go:32</span><br><span class=\"line\">runtime.main</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/proc.go:195</span><br><span class=\"line\">runtime.goexit</span><br><span class=\"line\">        /usr/local/Cellar/go/1.9.2/libexec/src/runtime/asm_amd64.s:2337</span><br><span class=\"line\">exit status 1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>sample4/main.go</code>中将出错的代码行数也打印了出来，这样的日志，可以帮助我们更方便的定位问题原因。</p>\n<h3 id=\"通过行为断言错误\"><a href=\"#通过行为断言错误\" class=\"headerlink\" title=\"通过行为断言错误\"></a>通过行为断言错误</h3><p>在有些场景下，仅仅知道是否出错是不够的。比如，和进程外其它服务通信，需要了解错误的属性，以决定是否需要重试操作。</p>\n<p>这种情况下，<u>不要判断错误值或者错误的类型，可以判断错误是否实现某个行为</u>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> temporary <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Temporary() <span class=\"type\">bool</span>    <span class=\"comment\">// IsTemporary returns true if err is temporary.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsTemporary</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    te, ok := err.(temporary)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ok &amp;&amp; te.Temporary()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种实现方式的好处在于，不需要知道具体的错误类型，也就不需要引用定义了错误类型的三方<code>package</code>。如果你是底层代码的开发者，哪天你想更换一个实现更好的<code>error</code>，也不用担心影响上层代码逻辑。如果你是上层代码的开发者，你只需要关注<code>error</code>是否实现了特定行为，不用担心引用的三方<code>package</code>升级后，程序逻辑失败。</p>\n<h3 id=\"不要忽略错误，也不要重复处理错误\"><a href=\"#不要忽略错误，也不要重复处理错误\" class=\"headerlink\" title=\"不要忽略错误，也不要重复处理错误\"></a>不要忽略错误，也不要重复处理错误</h3><p>遇到错误，而不去处理，导致信息缺失，会增加后期的运维成本</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer, buf []<span class=\"type\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">    w.Write(buf)    <span class=\"comment\">// Write(p []byte) (n int, err error)，Write方法的定义见 https://golang.org/pkg/io/#Writer</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重复处理，添加了不必要的处理逻辑，导致信息冗余，也会增加后期的运维成本</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer, buf []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    _, err := w.Write(buf)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Println(<span class=\"string\">&quot;unable to write:&quot;</span>, err)    <span class=\"comment\">// 第1次错误处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create writer and read data into buf</span></span><br><span class=\"line\"></span><br><span class=\"line\">    err := Write(w, buf)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Println(<span class=\"string\">&quot;Write error:&quot;</span>, err)        <span class=\"comment\">// 第2次错误处理</span></span><br><span class=\"line\">        os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    os.Exit(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充的错误处理原则\"><a href=\"#补充的错误处理原则\" class=\"headerlink\" title=\"补充的错误处理原则\"></a>补充的错误处理原则</h2><p>从稳定性视角出发，为了便于发现和分析问题：</p>\n<ul>\n<li>错误信息需要记录到日志</li>\n<li>错误量需要体现在metrics中</li>\n</ul>\n<h1 id=\"Package-github-com-pkg-errors\"><a href=\"#Package-github-com-pkg-errors\" class=\"headerlink\" title=\"Package github.com/pkg/errors\"></a>Package <code>github.com/pkg/errors</code></h1><p>建议使用包 <a href=\"https://github.com/pkg/errors\"><code>github.com/pkg/errors</code></a> 来处理错误。这个包提供这样几个主要的API：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下代码在errors.go中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New returns an error with the supplied message.</span></span><br><span class=\"line\"><span class=\"comment\">// New also records the stack trace at the point it was called.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(message <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Errorf formats according to a format specifier and returns the string</span></span><br><span class=\"line\"><span class=\"comment\">// as a value that satisfies error.</span></span><br><span class=\"line\"><span class=\"comment\">// Errorf also records the stack trace at the point it was called.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Errorf</span><span class=\"params\">(format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WithStack annotates err with a stack trace at the point WithStack was called.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, WithStack returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithStack</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Wrap returns an error annotating err with a stack trace</span></span><br><span class=\"line\"><span class=\"comment\">// at the point Wrap is called, and the supplied message.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, Wrap returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Wrap</span><span class=\"params\">(err <span class=\"type\">error</span>, message <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Wrapf returns an error annotating err with a stack trace</span></span><br><span class=\"line\"><span class=\"comment\">// at the point Wrapf is called, and the format specifier.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, Wrapf returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Wrapf</span><span class=\"params\">(err <span class=\"type\">error</span>, format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WithMessage annotates err with a new message.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, WithMessage returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithMessage</span><span class=\"params\">(err <span class=\"type\">error</span>, message <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WithMessagef annotates err with the format specifier.</span></span><br><span class=\"line\"><span class=\"comment\">// If err is nil, WithMessagef returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithMessagef</span><span class=\"params\">(err <span class=\"type\">error</span>, format <span class=\"type\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cause returns the underlying cause of the error, if possible.</span></span><br><span class=\"line\"><span class=\"comment\">// An error value has a cause if it implements the following</span></span><br><span class=\"line\"><span class=\"comment\">// interface:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//     type causer interface &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            Cause() error</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If the error does not implement Cause, the original error will</span></span><br><span class=\"line\"><span class=\"comment\">// be returned. If the error is nil, nil will be returned without further</span></span><br><span class=\"line\"><span class=\"comment\">// investigation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Cause</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下代码在 go113.go 中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Is reports whether any error in err&#x27;s chain matches target.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The chain consists of err itself followed by the sequence of errors obtained by</span></span><br><span class=\"line\"><span class=\"comment\">// repeatedly calling Unwrap.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// An error is considered to match a target if it is equal to that target or if</span></span><br><span class=\"line\"><span class=\"comment\">// it implements a method Is(error) bool such that Is(target) returns true.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Is</span><span class=\"params\">(err, target <span class=\"type\">error</span>)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// As finds the first error in err&#x27;s chain that matches target, and if so, sets</span></span><br><span class=\"line\"><span class=\"comment\">// target to that error value and returns true.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The chain consists of err itself followed by the sequence of errors obtained by</span></span><br><span class=\"line\"><span class=\"comment\">// repeatedly calling Unwrap.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// An error matches target if the error&#x27;s concrete value is assignable to the value</span></span><br><span class=\"line\"><span class=\"comment\">// pointed to by target, or if the error has a method As(interface&#123;&#125;) bool such that</span></span><br><span class=\"line\"><span class=\"comment\">// As(target) returns true. In the latter case, the As method is responsible for</span></span><br><span class=\"line\"><span class=\"comment\">// setting target.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// As will panic if target is not a non-nil pointer to either a type that implements</span></span><br><span class=\"line\"><span class=\"comment\">// error, or to any interface type. As returns false if err is nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">As</span><span class=\"params\">(err <span class=\"type\">error</span>, target <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unwrap returns the result of calling the Unwrap method on err, if err&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\">// type contains an Unwrap method returning error.</span></span><br><span class=\"line\"><span class=\"comment\">// Otherwise, Unwrap returns nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unwrap</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">error</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/pkg/errors/blob/master/example_test.go\"><code>example_test.go</code></a>有一些使用案例。</p>\n<h1 id=\"各种场景下的错误处理案例\"><a href=\"#各种场景下的错误处理案例\" class=\"headerlink\" title=\"各种场景下的错误处理案例\"></a>各种场景下的错误处理案例</h1><h2 id=\"error相等判断\"><a href=\"#error相等判断\" class=\"headerlink\" title=\"error相等判断\"></a>error相等判断</h2><p>当不确定待处理的error是否被包装时，不能直接使用相等进行判断。</p>\n<p><strong>例子</strong></p>\n<p><em>Bad：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err == EOF &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Good：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, EOF) &#123;\t<span class=\"comment\">// it will succeed if err wraps EOF</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"error类型转换\"><a href=\"#error类型转换\" class=\"headerlink\" title=\"error类型转换\"></a>error类型转换</h2><p>当不确定待处理的error是否被包装时，不能直接使用类型断言进行。</p>\n<p><strong>例子</strong></p>\n<p><em>Bad：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nerr, ok := err.(*CError)</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Good：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nerr *CError</span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.As(err, &amp;nerr) &#123;\t<span class=\"comment\">// it will succeed if err wraps an *CError</span></span><br><span class=\"line\">  \t<span class=\"comment\">// nerr is set as *CError</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何向外暴露error\"><a href=\"#如何向外暴露error\" class=\"headerlink\" title=\"如何向外暴露error\"></a>如何向外暴露error</h2><p><strong>例子</strong></p>\n<p><em>Bad：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package io</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> FileNotFoundErr = fmt.Errorf(<span class=\"string\">&quot;file not found&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// package service</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, io.FileNotFoundErr) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Good：</em></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package io</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fileNotFoundErr = fmt.Errorf(<span class=\"string\">&quot;file not found&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsFileNotFoundErr</span><span class=\"params\">(err)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.Is(err, fileNotFoundErr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// package service</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> io.IsFileNotFoundErr(err) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序启动时，如何处理依赖的三方资源无法连接-或者-不存在\"><a href=\"#程序启动时，如何处理依赖的三方资源无法连接-或者-不存在\" class=\"headerlink\" title=\"程序启动时，如何处理依赖的三方资源无法连接 或者 不存在\"></a>程序启动时，如何处理依赖的三方资源无法连接 或者 不存在</h2><p>根据三方资源的对于业务逻辑的重要性，采取是强依赖、还是弱依赖的处理策略，比如：</p>\n<ul>\n<li>如果三方资源是 类似DB的强依赖 资源，启动时无法连接，记录错误并<code>panic</code></li>\n<li>如果三方资源是 弱依赖的服务，启动时无法连接，记录错误但无需<code>panic</code></li>\n</ul>\n<h2 id=\"服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\"><a href=\"#服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\" class=\"headerlink\" title=\"服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方\"></a>服务之间的调用（比如A调用B），被调用服务程序逻辑内部发生的错误，是否要把错误信息返回给调用方</h2><p>在没有安全要求的情况下，B尽量返回详细的错误信息（<code>message</code>、<code>stack trace</code> 等），方便看到错误信息时候，能够直接定位错误原因。</p>\n<p>在存在安全限制的场景下，B返回在安全限制以内尽量详细的错误信息，比如：</p>\n<ul>\n<li>A是自有的C端的 客户端应用或者前端web应用，B不能返回<code>stack trace</code></li>\n<li>A是外部的应用，调用服务B，B不能返回 内部的错误<code>message</code>、<code>stack trace</code></li>\n</ul>\n<h2 id=\"数据访问层，使用gorm等orm框架查不到结果不应该报error\"><a href=\"#数据访问层，使用gorm等orm框架查不到结果不应该报error\" class=\"headerlink\" title=\"数据访问层，使用gorm等orm框架查不到结果不应该报error\"></a>数据访问层，使用gorm等orm框架查不到结果不应该报error</h2><p>数据访问层，使用gorm等orm框架查不到结果不应该报error，原因如下：</p>\n<ul>\n<li>从业务逻辑的角度来看，查不到结果 是一种正常的现象，不应当视为错误。比如，注册的时候检查账户是否已经存在，去掉订单的时候检查订单是否存在 等情况下，不应该将查不到数据视为错误。</li>\n<li>如果在业务逻辑里判断<code>err != gorm.errnotfound</code>，不符合开闭原则，如果后面要换一个数据库框架，需要改动业务逻辑代码</li>\n</ul>\n<p>数据访问层建议的处理方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dao层的查询函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetByID</span><span class=\"params\">(id <span class=\"type\">int</span>)</span></span> (*Object, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 查询逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; err != gorm.ErrRecordNotFound &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err<span class=\"comment\">// 仅在 err 是非ErrRecordNotFound类型的时候，才认为是错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;result, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>错误处理策略满足以下要求</p>\n<ul>\n<li><p>从代码结构的角度出发，不增加代码耦合度</p>\n</li>\n<li><p>从服务稳定性的角度出发，便于发现和分析问题</p>\n</li>\n</ul>\n<p>没有最好的策略，只有最合适的策略。在实际的项目开发过程中，不要拘泥于教条，灵活运用各种策略。让代码更健壮，让服务更稳定。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>The Go Blog<ul>\n<li><a href=\"https://blog.golang.org/error-handling-and-go\">Error handling in Go</a></li>\n<li><a href=\"https://blog.golang.org/defer-panic-and-recover\">Defer, Panic, and Recover</a></li>\n</ul>\n</li>\n<li>Dave Cheney<ul>\n<li><a href=\"https://dave.cheney.net/paste/gocon-spring-2016.pdf\">presentation on my philosophy for error handling</a></li>\n<li><a href=\"https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully\">Don’t just check errors, handle them gracefully</a></li>\n<li><a href=\"https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package\">Stack traces and the errors package</a></li>\n</ul>\n</li>\n<li>Go Packages<ul>\n<li><a href=\"https://golang.org/pkg/errors/\">errors</a></li>\n<li><a href=\"https://golang.org/pkg/runtime/\">runtime</a></li>\n</ul>\n</li>\n<li>pkg: Artisanal, hand crafted, barrel aged, Go packages<ul>\n<li><a href=\"https://godoc.org/github.com/pkg/errors\">github.com&#x2F;pkg&#x2F;errors</a></li>\n</ul>\n</li>\n<li><a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft.md\">Go 2 Draft Designs</a><ul>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling-overview.md\">go2draft-error-handling-overview.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-handling.md\">go2draft-error-handling.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-inspection.md\">go2draft-error-inspection.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-printing.md\">go2draft-error-printing.md</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/%2B/master/design/go2draft-error-values-overview.md\">go2draft-error-values-overview.md</a></li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/2017-12-29-error-handling-in-go/d2a2d12e1a00f819d7fd7af4b536efa2.png","slug":"d2a2d12e1a00f819d7fd7af4b536efa2.png","post":"cm9zwlzc60008fdjh0wb5efet","modified":0,"renderable":0},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/2016-04-21_07-12-24.png","slug":"2016-04-21_07-12-24.png","post":"cm9zwlzc60007fdjh02midzgz","modified":0,"renderable":0},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/2016-04-21_07-12-40.png","slug":"2016-04-21_07-12-40.png","post":"cm9zwlzc60007fdjh02midzgz","modified":0,"renderable":0},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/channel.png","slug":"channel.png","post":"cm9zwlzc60007fdjh02midzgz","modified":0,"renderable":0},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/expvarmon_screen.png","slug":"expvarmon_screen.png","post":"cm9zwlzc60007fdjh02midzgz","modified":0,"renderable":0},{"_id":"source/_posts/2016-04-20-experiences-about-develop-dlog/use_channel.png","slug":"use_channel.png","post":"cm9zwlzc60007fdjh02midzgz","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cm9zwlzc20001fdjh8l2s8eko","category_id":"cm9zwlzc50004fdjhbnwv3p2a","_id":"cm9zwlzc7000bfdjh9a8keqf2"},{"post_id":"cm9zwlzc40003fdjh7bagfwwo","category_id":"cm9zwlzc60009fdjh0j7u3jui","_id":"cm9zwlzc7000hfdjh6iclc2lz"},{"post_id":"cm9zwlzc60007fdjh02midzgz","category_id":"cm9zwlzc60009fdjh0j7u3jui","_id":"cm9zwlzc7000jfdjh0qzk5pq2"},{"post_id":"cm9zwlzc60008fdjh0wb5efet","category_id":"cm9zwlzc60009fdjh0j7u3jui","_id":"cm9zwlzc7000mfdjhflyy1b1a"}],"PostTag":[{"post_id":"cm9zwlzc20001fdjh8l2s8eko","tag_id":"cm9zwlzc50005fdjh11f160ih","_id":"cm9zwlzc7000efdjhaekwflt8"},{"post_id":"cm9zwlzc20001fdjh8l2s8eko","tag_id":"cm9zwlzc6000afdjh4qmlhk1f","_id":"cm9zwlzc7000ffdjh5715hg35"},{"post_id":"cm9zwlzc40003fdjh7bagfwwo","tag_id":"cm9zwlzc7000dfdjhfv6jh4h5","_id":"cm9zwlzc7000lfdjh6mle2ywn"},{"post_id":"cm9zwlzc40003fdjh7bagfwwo","tag_id":"cm9zwlzc7000ifdjhcakl5dj6","_id":"cm9zwlzc7000nfdjhcppcf8uq"},{"post_id":"cm9zwlzc60007fdjh02midzgz","tag_id":"cm9zwlzc7000dfdjhfv6jh4h5","_id":"cm9zwlzc7000pfdjh9cvw9db3"},{"post_id":"cm9zwlzc60008fdjh0wb5efet","tag_id":"cm9zwlzc7000dfdjhfv6jh4h5","_id":"cm9zwlzc7000qfdjhbe22ffwf"}],"Tag":[{"name":"产品设计","_id":"cm9zwlzc50005fdjh11f160ih"},{"name":"需求分析","_id":"cm9zwlzc6000afdjh4qmlhk1f"},{"name":"golang","_id":"cm9zwlzc7000dfdjhfv6jh4h5"},{"name":"json","_id":"cm9zwlzc7000ifdjhcakl5dj6"}]}}